ఈ క్లౌడ్ కంప్యూటింగ్(cloud computing) యొక్క ఈ కోర్సు(course)కు
స్వాగతం.
క్లౌడ్(cloud) యొక్క వివిధ అంశాలపై మన
చర్చ కొనసాగుతుంది.
నేడు మనము ఏమి చూసేందుకు ప్రయత్నిస్తున్నాం
అంటే, అండర్ లైనింగ్ టెక్నాలజీ(underlining technology)
అంటే ఏమిటి మరియు అండర్ లైనింగ్ ప్రోటోకాల్
(underlining protocols), ఏదైతే అన్నిటిని కలుపుతుందో.
ఇవన్నీ క్లౌడ్(cloud)లో ఉన్నాయని మనము చర్చించాము,
ఇక్కడ వివిధ రకాలైన సర్విస్(services) లు లేదా
XaaS, ఏదైనా ఒక సర్విస్(service) గా ఉండే మోడల్(model)
ఉంది. కాబట్టి, మనకు కొన్ని మార్గాలు
లేదా ఇతర ప్రోటోకోల్స్ (protocols)ని కలిగి ఉండాలి.
ఇప్పుడు, మీరు వినియోగదారుని లేదా కస్టమర్(customer)
లేదా క్లౌడ్(cloud) యొక్క వినియోగదారుని చూసినప్పుడు,
క్లౌడ్ ప్రొవైడర్(cloud provider) యొక్క సర్విస్
(service)ను తీసుకుంటారు.
అందుచే, ఇది ఈ క్లౌడ్ (cloud) , క్లౌడ్ ప్రొవైడర్
(cloud provider) లో ఎక్కడ, ఎలా హోస్ట్ (host) అవ్వడం
అనేది స్వతంత్రంగా ఉంటుంది.
యూజర్ క్లయింట్(user client) ఎలా యాక్సెస్(access)
చేస్తారు.
కాబట్టి, ఇది సర్విస్ ఓరియెంటెడ్ ఆర్కిటెక్చర్
(service oriented architecture) కంటే ఎక్కువ, మనం ఏదైతే
సాధారణం గా అమలు చేస్తామొ అది. వెబ్
సర్విస్ ఓరియెంటెడ్ ఆర్కిటెక్చర్(web service
oriented architecture) లేదా వెబ్ సర్విస్(web services) లు
మనకు తెలిసినట్లుగా, ఏదైతే లూసెలి కపుల్డ్(loosely
coupled) వైవిధ్య సర్విస్ (services)ల మధ్య పరస్పరం
అనుసంధానించడానికి, ఎక్స్పెక్టెడ్ ఔట్పుట్
(expected output) సాధించడానికి అనుమతిస్తుంది.
కాబట్టి, ఈ రకమైన సర్విస్ ఎక్స్ఛేంజీ(service
exchanges) లు లేదా సర్వీసు డ్రివెన్ ఆర్కిటెక్చర్
(service driven architecture) యొక్క ప్రాధమిక అంశం లేదా
ప్రాథమిక నిర్మాణ బ్లాక్(block)లో ఒకటి
XML. కాబట్టి, మనము నేడు చర్చించబోతున్నాము,
బహుశా ఒకటి లేదా రెండు ఉపన్యాసాలు
XML యొక్క బేసిక్స్ మీద ఉంటాయి.
దీని అర్థం ఏమిటంటే, మీరు ఎక్కువగా XML
వాడతారు లేదా మీరు XML అంటే ఏమిటో తెలుసుకుంటారు.
మీలో చాలా మందికి XML యూస్ (use) చేస్తుంటాము
లేదా XML అంటే తెలుసే ఉంటుంది.
కానీ దీని గురించి తెలియని వారికి , అన్నీ
రకాల శ్రోతలకి మనము XML యొక్క చాలా ప్రాథమిక
విషయాలను చర్చిస్తాము , దాని లక్షణాలను
మరియు దానిని ఎలా అనుమతిస్తుందో తెలుసుకుందాం.
మనము XMLను చూసినట్లైతే.
పెరుగుతున్న సాఫ్ట్వేర్ టూల్స్(software tools), XML స్టాండర్డ్స్(standards)
మరియు ఐడియాస్ (ideas) కోసం ఉద్భవించిన
ఎక్రోనిం(acronym) XML. కాబట్టి, మనమిప్పటికీ XML యొక్క
విభిన్న ప్రాపర్టీ (properties)లు ఏవి?
ఇది ఎలా ఉంది, అది ఏ విధంగా పరస్పరం
పంచుకుంటుంది.
పార్సెర్(parser) యొక్క వివిధ రకాలు ఏమిటి
లేదా XML లో ఉన్న ఇతర రకాల టెక్నాలజీస్
(technologies) ఏవి ఉన్నాయి.
ఇది ఎక్స్టెంసిబల్ మార్కప్ లాంగ్వేజ్(extensible
markup language).
మనము HTML, హైపర్ టెక్స్ట్ మార్కప్ లాంగ్వేజ్(hypertext
markup language) వాడతాము, ఇవి ప్రధానంగా ఇంటర్నెట్
(internet) యొక్క వరల్డ్ (world) లో డాక్యుమెంట్(document)
చూసేందుకు ఉపయోగించబడతాయి, కాబట్టి, XML ఎక్స్టెన్సిబుల్
మార్కప్ లాంగ్వేజ్(extensible markup language) మరియు HTML ల
కాకుండా, అంతకంటే ఎక్కువ డేటా డిస్ప్లే
(data display) లేదా డేటా రిప్రజెంటేషన్ లాంగ్వేజ్(data representation
language).
మీ ఇన్ఫర్మేషన్ రెప్రెసెంటేషన్ (information representation language) XML
అనేది డేటా ట్రాన్స్ఫార్మేషన్ లాంగ్వేజ్ (data transformation
language) కంటే ఎక్కువైంది.
అది మనకు ఇంట్రాపోరేషన్స్ (interoperation) ను సాధించటానికి
అనుమతిస్తుంది.
ఎన్కోడింగ్(encoding) కోసం సింటాక్స్(syntax) అనేది
టెక్స్ట్(text) ఆధారితంగా ఉంటుంది.
వర్డ్ ఫ్రేస్ నంబర్స్(word phrase numbers).
కాబట్టి, ఇది చదవగలిగేది, ఒక టెక్స్ట్(text) ఆధారిత
సింటాక్స్(syntax) మరియు XML అనేది ముద్రించదగిన
యూనికోడ్ కారెక్టర్(character), ఎక్ష్ప్లిసీట్ బైనరీ
డేటా(explicit binary data), కారెక్టర్ ఎన్కోడింగ్(character encoding)
సమస్యలు ఉండవు; ఇది ఎక్ష్టెన్సిబుల్
(extensible); XML లో మనం మన సొంత అంశాలను నిర్వచిస్తాము.
డేటా రకాలు వలె, HTML వలె కాకుండా HTML కు
ఉపయోగించిన లేదా HTML చూసినప్పటికీ,
మనకు ముందుగా ఉన్న ట్యాగ్(tag)ల సెట్(set)
ఉంటుంది.
XML లో మనము మన స్వంత అంశాలు లేదా స్వంత
ట్యాగ్ (tag) లను నిర్వచించవచ్చు.
దీని సిన్టాక్స్ రూల్(syntax rule) స్థిరంగా
ఉంటుంది, ఖచ్చితంగా మీరు సింటాక్స్(syntax)
యొక్క సందర్భంలో నిర్వచించగలరు.
దీన్ని కొన్నిసార్లు యునివర్సల్ ఫార్మాట్(universal
format) కూడా సూచిస్తుంది.
అన్ని XML ప్రాసెసింగ్ సాఫ్ట్ వేర్(processing
software) సైతం XML డాటా (data) ఇచ్చిన సాఫ్ట్వేర్
పీస్ (software piece) నిర్వహించాలని ఈ సింటాక్స్(syntax) నియమం
నిర్ధారిస్తుంది.
కాబట్టి, అది యునివర్సల్ (universal).
మీరు XML డేటా(data) మరియు XML ప్రాసెసింగ్ సాఫ్ట్వేర్(processing
software) లేదా XML పార్సర్(parser) ను కలిగి ఉంటే, ఇది
అన్ని రకాల XML నిర్వహించగలుగుతుంది, కనుక ఇది యునివర్సల్
(universal).
కాబట్టి, ఇది ఒక XML యొక్క విలక్షణ ప్రాథమిక
లక్షణాలలో ఒకటి, ఇది XML ఊబిక్యుఎస్
(ubiquous) చేస్తుంది.
కాబట్టి, మీరు చదివి దానిని ప్రాసెస్
చేయగలిగితే; మీరు దానిని చదివి మరియు
ప్రాసెస్(process) చేయగలిగితే, ప్రతి ఒక్కరూ అదే
డేటా(data)ను చదవగలరు మరియు ప్రాసెస్(process)
చేయగలరు.
మనము రిసోర్సస్ (resources)నుండి తీసిన మాదిరిగానే
ఒక సరళమైన ఉదాహరణ చూడండి.
ఒక XML డిక్లరేషన్(declaration) ఉన్నటువంటి కొన్ని
విషయాలు ఉన్నాయి.
ఇక్కడ వెర్షన్(version), XML నేమ్ స్పేస్(namespace)
ఉంది మరియు వివిధ అంశాల నిర్వచనం ఉన్నాయి.
ఇవి వివిధ XML ట్యాగ్స్(tags), ఈ ట్యాగ్(tag) లు మనం
చూసినట్లైతే వీటిని యూజర్ డిఫైన్డ్ (user
defined) చేశారు, కాబట్టి వీటిని యూజర్ డిఫైన్డ్
(defined) టాగ్ (tags) లు అంటాం; అంటే, మనం సొంత టాగ్లు(tags)
నిర్వచించగలము, partorders, description,మరియు partnumber, ఇవి
అన్ని యూసర్ (user) నిర్వచించిన టాగ్లు(tags).
కాబట్టి, html లా కాకుండా, దేనిలో అయితే ట్యాగ్లు
ఫ్రే డెఫినేడ్ (pre defined) గా ఉంటాయో మరియు
ఇక్కడ మీ సొంత ట్యాగ్ల(tags)ను నిర్వచించలేరు, అయితే
XML లో మీరు మీ స్వంత ట్యాగ్ల(tags)ను నిర్వచించవచ్చు.
ఇప్పుడు మీరు మీ సొంత ట్యాగ్ల(tags)ను
నిర్వచించినట్లయితే, ఆ తరువాత వెలుగులోకి
వచ్చే విషయాలు ఏవి అంటే టాగ్(tags)లు ఎలా
నిర్వచించారు అనేది చెప్పాల్సిని అవసరం
ఉంది. నేను టేబుల్(table) అనే ట్యాగ్(tag)ను నిర్వచించాను.
ఇప్పుడు, ఈ టేబుల్(table) కొన్ని ఫర్నిచర్(furniture)
తరగతులు లేదా ఫర్నిచర్(furniture) వర్గంలో ఉన్న సమూహాన్ని
సూచిస్తుందో లేదో లేదా టేబుల్ వర్డ్
ప్రాసెసింగ్(table word processing) లేదా ఫ్రేస్
(phrase) వర్గీకరించడంలో ప్రధానంగా ఉంటుంది.
కాబట్టి, ఇది ముఖ్యమైనది.
నేను ఒక ట్యాగ్ను నిర్వచించాను.
ఇప్పుడు నేను తెలుకోవాల్సిన విషయం, టాగ్(tag) ను
డిఫైన్ (define) చేస్తే, నేను ఫర్నిచర్(furniture)
కేటగిరి నుండి ఒకటి మరియు వర్డ్ ప్రాసెసింగ్(word
processing) వర్గం నుండి మరొకదాన్ని ఉపయోగిస్తున్నాం
అని. అప్పుడు నేను నిర్వచించవలసి ఉంది,
మరో వైపు నేను ఏమి కావాలనుకుంటున్నాను
అనేది ఎలా తెలుసుకుంటారు.
XML నేమ్పేస్(namespace) యొక్క భావన ఉంది, ఇది ప్రధానంగా
మన సొంత యూజర్(user) నిర్వచించిన అంశాలు
మరియు ఇతర విషయాలను నిర్వచించటానికి
అనుమతిస్తుంది.
కాబట్టి, మనము XML డాక్యుమెంట్(document) ను చూస్తే, అది క్రమానుగత
మరియు నిర్మాణాత్మక సమాచారం.
నేను ఈ డాక్యుమెంట్(document) చూస్తే.
ఇది ఒక పార్ట్ ఆర్డర్(Partorder).
ఇది ఒక XML నేమ్స్పేస్(namespace) అయిన టాప్ మోస్ట్(top
most) నోడ్(node), ఇది ఈ నేమ్స్పేస్(namespace) కి సంభందించిన పార్ట్
ఆర్డర్(Partorder) అని మరియు అది వేర్వేరు లెవెల్
(levels)లను కలిగి ఉంటుంది లేదా అది ప్రధానంగా
హైరార్ఖికల్ (hierarchical)గా కనిపిస్తుంది, కనుక
మేము ఒక XML ట్రీ (tree)ను ఉత్పత్తి చేస్తాము.
కాబట్టి, XML అనేది ట్రీ (tree) స్తృక్తుర్డ్
(structures) సమాచారం యొక్క ఈ లక్షణంతో వస్తుంది,
ఇది XML ట్రీ (tree)చే సూచించబడుతుంది.
కాబట్టి, మనం మళ్లీ మన ప్రాథమిక ఆవరణ
లేదా ప్రాథమిక నిర్వచనానికి తిరిగి వచ్చినా,
ఇది html వంటిది, కానీ అంత సులభం కాదు, html
చాలా వనిల్లా(vanilla) రకం. సింటాక్స్ ఎర్రోర్స్
(syntax errors) ని తొలగించడానికి ఖచ్చితమైన సింటాక్స్(syntax)
నియమాలు ఉంటాయి.
కాబట్టి, XML చాలా ఖచ్చితమైన సింటాక్స్ రూల్స్(syntax
rules) ని అనుసరిస్తుంది.
సింటాక్స్ స్ట్రక్చర్ హైరార్ఖికల్ ( structure
hierarchical) మరియు స్ట్రక్చురల్ (structural) ఎలిమెంట్స్
(elements) పేర్లను నిర్వచిస్తుంది మరియు ఇది స్వీయ
వర్ణన డేటా(data).
కాబట్టి, నా సొంత సెల్ఫ్ డిస్క్రైబింగ్
డేటా(self-describing data)ను కలిగి ఉండవచ్చు, ఇది html కేస్(case)
లా కాకుండా ఎక్స్టెన్షన్(extension) చేయబడుతుంది; ఇది
XML ఇక్కడ వాకబులరి (vocabulary) అనేది ఫిక్స్(fix)
అయ్యి ఉండదు.
మీరు మీ స్వంత వోకాబులరి(vocabulary) లేదా ట్యాగ్లు(tags)
లేదా అంశాలని నిర్వచించగలరు మరియు దీని అర్థం,
మీరు ప్రాథమికంగా ఈ డేటా(data)ను విస్తరించవచ్చు.
ఇది డిస్ట్రిబ్యూటెడ్ ఎన్విరాన్మెంట్(distributed
environment) కొరకు డిజైన్(design) చెయ్యబడింది, HTML లాగా,
ఇది కూడా డిస్ట్రిబ్యూటెడ్ ఎన్విరాన్మెంట్(distributed
environment) కొరకు డిజైన్(design) చెయ్యబడింది.
దీనికి డిస్ట్రిబ్యూటెడ్ సిస్టమ్ (distributed system)ల
యొక్క వేర్వేరు నోడ్ల(nodes)లో వివిధ వ్యవస్థలతో
కమ్యూనికేట్(communicate) చేయడానికి లేదా ఇంటర్ఫేస్
(interface) లేదా ఇంటెరోపేరేట్(interoperate) చేయగల సామర్థ్యం
ఉంది. కనుక, టాగ్(tags) ల యొక్క మన సొంత లాంగ్వేజ్
(language) మరియు ఎలిమెంట్స్(elements) ని సృష్టించవచ్చు,
అంతటా ఉన్న డేటా పొందవచ్చు మరియు
రిలయబుల్ (reliable)గా ఉపయోగించవచ్చు.
అందువల్ల, ఇది డిస్ట్రిబ్యూట్ (distribute) చేయబడుతుంది
మరియు వివిధ డేటా టైప్(datatypes) లను కలపవచ్చు
కాకుండా.
కాబట్టి, html దీన్ని చేయగలదు.
కానీ XML లో, నేను మల్టిపుల్ రిసోర్స్ (multiple resources)లను
కలిపి మరియు దాని నుండి ఇంకొక డేటా(data)ను
రూపొందించుకోవచ్చు.
దీని మాదిరిగా, నేను 2 రిపొజిటరీ(repositories)
ల నుండి వచ్చాను.
నేను డేటా యొక్క వివిధ కొంపోనెంట్స్
(components) తీసుకొని చివరిగా ఈ రెండు విషయాల మిశ్రమాన్ని
కలిగి ఉన్న ఇంకొక డాటా(data)ను రూపొందించవచ్చు,
అవి HTML, XML అలా చేయటానికి అనుమతిస్తుంది.
ఇది వివిధ సందర్భాల్లో చాలా ఉపయోగకరంగా
ఉంటుంది, మీరు డేటాను(data) రెండు రకాలుగా పొందుతున్నారంటే,
మీ విద్యాసంస్థలో చెప్పాలంటే, అకడెమిక్(academic)
విభాగానికి చెందిన ఒక డేటా(data), మరొక డాటా
అన్నీ మేనేజ్మెంట్ సెంటర్(management centers) ల
నుంచి విద్యార్థులందరికీ సంబంధించినవి తీసుకుని,
క్లబ్(club) చేసి ఈ ప్రత్యేక సెమిస్టర్(semester) లేదా
ప్రత్యేక బ్యాచ్(batch) లేదా ప్రత్యేక సంవత్సరం
ఉత్తమ విధ్యార్ధిని తెలుసుకోవాలనుకుంటున్నాను
వంటి కొన్ని విషయాలు కనుగొనేందుకు ప్రయత్నించండి.
కాబట్టి, నేను విద్యార్థికి సంభందించిన వివిధ
ఆక్టివిటి (activity) డేటా(data), విద్యార్థి అకడెమిక్
(academic) డేటా మరియు వేరొక రకమైన డాటా (data) ఉపయోగించి
మరొక డేటా సమితిని రోపొందించవచ్చు.
కనుక, ఈ విధమైన డిస్ట్రిబ్యూటెడ్(distribute) వైవిధ్యమైన డేటా
సెట్ (data set) ను మీరు ఎప్పుడైనా ఎలా కలపవచ్చు,
ఎలా ఇంటెరోపేరేట్ (interoperate) చెయ్యబడుతుంది,
మరియు కొత్త డాటా (data) ని ఎలా రూపొందిచవచ్చు.
ఈ విధమైన సంధర్భాలలో, ఈ XML ఉపయోగకరంగా ఉంటుంది.
కాబట్టి, ఇది వివిధ డేటా టైప్స్ (data types)ల
మిశ్రమం.
ఇతర యాక్సెస్(access), XML డేటా ఎలా ప్రాసెస్(process)
అవుతుంది.
కాబట్టి, మనము చూసిన ఒక విషయం ఏమిటంటే
అది ట్రీ (tree) స్ట్రక్చర్ (structure) ని కలిగి ఉంటుంది.
ఇప్పుడు HTML వంటి ఇతర స్టాండర్డ్(standard) లాగా
కాకుండా ,లేదా మీరు ఎటువంటి యూజర్ డెఫినేడ్
(user defined) విషయాలు లేకుండా ఉండేది చూస్తున్నాం.
కనుక, మీరు సింటెక్స్(syntax) మాత్రమే కాకుండా,
ఎలిమెంట్స్ (elements) మొదలైన వాటిని కూడా
డిఫైన్ (define) చెయ్యవచ్చు.
కానీ ఇక్కడ ఈ సందర్భంలో, నేను మొదట తెలుసుకోవాల్సిన
అవసరం ఏమిటంటే, ఎలిమెంట్ల నంబర్స్ (element numbers) ఏమి
ఉన్నాయి,వాటిలో ఏవి యూసర్ డెఫిన్ద్ (user
defined) మరియు వారు మొదట ఏమి చేయాలనుకుంటున్నారో
తెలుసుకోవాల్సిన అవసరం ఉంది. కాబట్టి,
ఈ డేటా(data)ని ప్రాసెస్(process) చేయడానికి, నేను
ఇటు వంటి డేటా(data)ను కలిగి ఉన్నాను, దాన్ని
కొన్ని ఇంటర్నెట్ రిసోర్స్ (resources)ల నుంచి
తీసుకున్నాను.
ఇలాగే, ఫైల్ ట్రాన్సఫర్(file transfer) తేదీ, చాలా మొత్తం
ట్రాన్సాక్షన్(transaction) ID మరియు వివిధ రకాల
ట్రాన్సాక్షన్ (transactions)లు అనేవి ఇంటర్బ్యాంకు(interbank)
కు సంభందించినవి.
ఇది బ్యాంకు లావాదేవీల లాగా ఉంటుంది, కొన్ని
బ్యాంక్ లోపల అంతర్గతంగా ఉంటాయి మరియు కొంతమంది
ఇంటర్బ్యాంక్(interbank) లేదా వివిధ బ్యాంకుల
మధ్య ఉంటాయి, అప్పుడు ఈ డేటా(data)ను ఎలా ప్రాసెస్(process)
చేయాలి.
దీనికి ముందుగా XML డేటా(data) నుండి ఇన్ఫర్మేషన్
(information)ను సేకరించిన తర్వాత ప్రాసెసింగ్(processing)
జరుగుతుంది.
ఇది ఒక XML రకమైన లాంగ్వేజ్(language) లో ప్రాథమికంగా కవర్
చేయబడి ఉంటుంది, అప్పుడు నేను దానిని
ఎక్స్ట్రాక్ట్ (extract) చెయ్యాలి మరియు కొన్ని
విధాలైన అప్లికేషన్ (applications)లను, డేటా(data)ను
సేకరించేందుకు అవసరమైన టూల్స్ (tools) ఉపయోగించి
ప్రాసెస్(process) చేస్తాను.
దీనిని మనము XML పార్సర్(parser) ద్వారా చేస్తాము.
XML పార్సర్(parser) ప్రాసెసింగ్(processing) మోడల్(model), ఇది XML డేటా
పార్సర్(data parser) అయినట్లయితే, డాటా (data) పార్సర్(parser)
గుండా వెళుతుంది మరియు ఇతర వైపు XML
బేస్డ్ అప్లికేషన్(based application), వీటి మధ్యలో
పార్సర్ ఇంటర్ఫేస్(parser interface) ఉంది. కాబట్టి,
XML డేటా(data) అప్పుడు ప్రాసెసర్(processor), అది
XML ఆధారిత అప్లికేషన్లు(applications) ప్రేరేపించిన విషయాలు
వెలికితీస్తుంది.
పార్సర్(parser), XML డేటా(data) సింటాక్తీకలి(syntactically)
సరైనదా కదా అని ధృవీకరించాలి.
కాబట్టి, పార్సర్(parser) యొక్క పాత్ర ఏమిటి
అంటే, మొదటిది, పార్సర్లో(parser) XML డేటా(data) వాక్యనిర్మాణంగా
సరైనదో ధృవీకరించాలి.
కాబట్టి, డేటాలో సింటాక్స్ ఎర్రర్(syntax
error)లేదు. రెండవది, అటువంటి డాటా (data)
ని వెల్ ఫోర్మ్ద్ (well formed) డాటా(data) అంటాము.
ఇది సీన్టాక్టికలి సరియైనది అయితే,
అప్పుడు దానిని వెల్ ఫోర్మ్ద్(well- formed) XML
అంటాము.
కాబట్టి, ఒక XML గా కనీస అవసరాన్ని సరిగ్గా
రూపొందించాలి, ఇది ప్రాసెస్(process) చేయదగినది,
మనము ఈ డేటా(data)ను ప్రాసెస్(process) చేయగలము.
డేటా(data) సరిగ్గా లేనట్లయితే, పార్సెర్(parser) డాటా
ప్రాసెసింగ్(data processing) ఆపి వేస్తుంది.
కాబట్టి, అది ఆపివేసిన ప్రాసెసింగ్(processing)
మరియు XML ఆధారిత అప్లికేషన్ (application) కు ఎక్ష్కెప్షన్
(exception) త్రో (throw) చేస్తుంది.
అది వెల్ ఫార్మ్డ్ కాకపోతే; అనగా, ఇది
సింటాక్తీకలి(syntactically) కరెక్ట్ (correct) డాటా(data)
కాదు. కాబట్టి, మనము తిరిగి గెర్తుచేసుకున్నట్లైతే,
వేర్వేరు భాగాలతో కలిపి XML ప్రాసెసింగ్(processing)
రూల్(rule) లో, DTD అని పిలువబడే అంశం ఉంది, ఇది డాక్యుమెంట్
టైప్ డిక్లరేషన్(document type declaration).
కాబట్టి, ఏదైనా XML డేటా(data)కు ముఖ్యమైనది
ఏమిటంటే, రిలేషనల్ డాటా బసెస్ (relational data
bases) వంటి డేటా బేస్(data base) విషయంలో మనము చూసినట్లుగా,
సాధారణం గా ఏమి చేస్థామంటే, ఒక టేబల్(table) లేదా
బహుళ టేబల్ (tables)ను డెఫినే చేస్తాము,
ఎక్కడైతే డేటా(data) వివిధ రూపాలలో లేదా
రికార్డు(records) రూపంలో లేదా వివిధ రో (rows)లుగా
లేదా టుపుల్స్(tuples) గా ఉంటుందో.
ఇప్పుడు, ఈ టేబల్(table) నిర్వచించటానికి,
మనము టేబల్(table) యొక్క నిర్మాణం నిర్వచించవలసి
ఉంటుంది లేదా దీనినే మనం టేబల్(table) యొక్క
స్కీమా(schema) అని అంటాము, కాబట్టి ఈ టేబల్(table)
లో వేర్వేరు వేరియబుల్(variables) ఉంటే, ఏ వేరియబుల్(variable),
ఏ స్కీమ(schema) కు సంభందించినది అనేది మనము నిర్వచించాల్సిన
అవసరం ఉంది. కాబట్టి, XML విషయంలో కూడా, ఇవి
యూసర్ డెఫినేడ్ (user defined) నిర్మాణం మరియు
ఇది క్ర హైరార్ఖికల్ (hierarchical).
మనం ఎలిమెంట్(element) ని ఎలా డిఫైన్(define)
చేశామో కూడా తెలియదు, అప్పుడు ఇతర ఎలిమెంట్స్
లెవెల్స్ (elements levels) మరియు ఎలిమెంట్స్(elements)
రకాలు ఏవి, మరియు అందుకే ఇక్కడ కూడా,
మనము ఒక స్కీమా(schema) డిఫైన్(define) చెయ్యాల్సిన
అవసరం ఉంది లేదా గతంలో మనం చూసినట్లుగా
దీనిని డాక్యుమెంట్ టైప్ డిక్లరేషన్(document
type declaration) అని పిలుస్తారు.
మొదటగా మీరు డాక్యుమెంట్ (document) రకం డిక్లేర్
చెయ్యాలి.
ఇప్పుడు డాక్యుమెంట్(document) రకంపై ఆధారపడి ఉంటుంది,
అది ఒకవేళ డేటా(data)లో మిగిలినది ఉంటే.
కాబట్టి, ఒక మార్గం; పార్సెర్ యొక్క పనిలో
ఒకటి డాటా (data) సింటాక్తీకలి(syntactically) కరెక్ట్ ఆ, కదా ఆని
చూడడం, ఇది ప్రత్యేకమైన డాక్యుమెంట్ (document),
నిర్వచనం ను అనుసరిస్తుందా లేదా అన్నది కాకుండా,
సింటాక్తీకలి(syntactically) కరెక్ట్ అని చెప్పుకోవాలంటే,
బాగా ఉపయోగపడుతుంది.
అప్పుడు స్కీమా(schema) లేదా డాక్యుమెంట్
టైప్ డెఫినిషన్(document type definition) తరువాత అది
చెల్లుబాటు అయ్యే XML అవసరం అవుతుంది.
XML డేటా(data)ను పొందడానికి, పార్సర్(parser) ఈ DTD ను
సంప్రదిస్తుంది.
ఇది సింటాక్తీకలి(syntactically) సరియైనదిగా ఉంటే,
ఈ ప్రత్యేకమైన ఆపరేషన్(operation)ల కోసం XML వాలిడ్ (valid)
అని చెబుతుంది.
మనకు XML పార్సర్(parser), DTD, మరొక ఇంటర్నల్
ఎంటిటీ(internal entities)లు ఉన్నాయి.
పార్సెర్(parser) ప్రక్రియల వలె, DTD కంటెంట్(content)
ఇంటర్నల్ ఎంటిటీ(internal entity) ని గుర్తిస్తుంది
మరియు ప్రతి ఎంటిటి(entity) వెల్ ఫోర్మ్ద్ (well
formed) ఆ కదా అని చెక్ చేస్తుంది.
DTD కంటెంట్(content) కోసం స్పష్టమైన సింటాక్స్(syntax)
రూల్ (rule) ఉండాలి.
వెల్ ఫోర్మ్ద్ (well formed) XML ఇక్కడ సరిగ్గా
ఉండాలి.
DTD కంటెంట్(content) కోసం స్పష్టమైన సింటాక్స్(syntax)
రూల్ (rule) ఉన్నాయి కాబట్టి, బాగా XML ఈ
విషయంలో సరిగ్గా ఉండాలి.
పార్సర్(parser) అప్పుడు ప్రస్తావించబడిన
ఎంటిటీ(entity) ద్వారా ఎంటిటీ రిఫరెన్స్(entity
reference) యొక్క ప్రతి సంఘటనను భర్తీ చేస్తుంది.
సో, రికార్సివ్(recursive) గా ఎంటిటి (entities)ల లోపల
చేస్తుంది.
కాబట్టి, రిఫరెన్స్(reference) చేయబడిన ఎంటిటీ(entity)
ద్వారా రిఫరెన్స్(reference) చేసిన ఎంటిటీ(entity)
తో, ఇది ముందు ఉన్న ఎంటిటి(entity) ని రిప్లేస్(replace)
చేస్తుంది.
కనుక ఇది ఎంటిటి రిఫరెన్స్(entity reference)
గా ఉంటుంది.
పరిష్కారం పొందిన డేటా ఆబ్జెక్ట్ (data
object), తర్వాత XML అప్లికేషన్(application)కి అందుబాటులో ఉంటుంది.
ఈ XML అప్లికేషన్(application) కు వెళ్లినప్పుడు,
మనం ఇంతకుముందే పిక్చర్ (picture) లో చూసినట్లుగా,
ఇది వెల్ ఫామ్ చెకింగ్(well from checking), సింటాక్టికల్
చెకింగ్(syntactical checking) చేయడాన్ని మరియు
DTD తో చెక్ (check) చేయడాన్ని కూడా రూపొందిస్తుంది,
ప్రత్యేకమైన డాక్యుమెంట్ను(document) మనము XML అప్లికేషన్(application)
పంపించే ముందు ఏదో విధమైన అప్లికేషన్
ధృవీకరించడం.
XML ప్రాసెసింగ్(processing) లో ఎక్ష్టెర్నల్
ఎంటిటీ(external entities)లు ఉండవచ్చు.
మనం ముందు చూసిన ఇంటర్నల్ (internal) ఎంటిటీలు
ఉన్నాయి, అనగా ఏమిటంటే డిటిడి(DTD) ఇక్కడే
డెఫినే (define) చేయబడింది లేదా స్కీమా(schema) కూడా
ఇక్కడే నిర్వచించబడిందని అర్థం.
కాబట్టి, ఎక్ష్టెర్నల్ ఎంటిటీ(external entities) ఒక
URL ద్వారా సూచిస్తారు.
ఇది ప్రాథమికంగా బాహ్య నిర్మాణం లేదా
స్కీమా(schema)ను ఏంటీటీఎస్ (entities) లో చూడవచ్చు.
కాబట్టి, పార్సర్(parser), DTD కంటెంట్(content)ని ప్రాసెస్(process)
చేస్తుంది, బాహ్య ఎంటిటీ(entity)లను గుర్తిస్తుంది
మరియు వాటిని పరిష్కరించడానికి ప్రయత్నిస్తుంది.
పార్సర్(parser), అప్పుడు, ఎంటిటీ రిఫరెన్స్
(entity reference) యొక్క ప్రతి సంఘటనను రేఫెరెన్స్డ్
ఎంటిటి (referenced entity)చే భర్తీ చేస్తుంది
మరియు ఇంటర్నల్ (internal) అంశాలతో సహా అన్ని
ఏంటీటీఎస్(entities)లతో రేకుర్సివ్ (recursive)
గా జరుగుతుంది.
ఎక్ష్టెర్నల్ ఏంటీటీఎస్ (external entities) లో కూడా రిప్లేస్(replace)
చేసేటప్పుడు ఔట్స్(outs) మరియు గో(go) ఉంటాయి.
కానీ పార్సర్(parser) ఎక్ష్టెర్నల్ ఏంటీటీఎస్
(external entities)ని కనుగొనలేకపోతే, అది ఫైర్వాల్(firewall)
అడ్డుకోవడం వల్ల కావచ్చు.
ఇది అప్లికేషన్(application) మరియు పార్సర్(parser)
రకాన్ని బట్టి ఉంటుంది.
రెండు రకాలైన XML పార్సర్(parsers)లు ఉన్నాయి.
అందులో ఒకటి అన్ని ఏంటీటీఎస్ (entities) ని
రిట్రీవ్ చేసుకుంటుంది.
మరొకటి వాటిని ఇగ్నోర్ (ignore) చేస్తుంది.
కాబట్టి, ఇది పార్సర్(parser) యొక్క ప్రాసెసింగ్
పాలసీ(processing policy) మరియు ప్రొసెసింగ్ రూల్స్
(processing rules)పై ఆధార పడి ఉంటుంది.
మనకు 2 రకాలైన XML పార్సర్(parsers) లు ఉన్నాయి, మొదటగా
చెప్పుకునే పార్సర్(parser); అన్ని ఎంటిటి (entities)లను
తిరిగి పొందాలి మరియు మొత్తం DTD కంటెంట్(content)
ను తప్పనిసరిగా ప్రాసెస్(process) చేయాలి, సరిగ్గా
చేయలేకపోతే, ప్రాసెస్(process)ను ఆపి వేస్తాము మరియు
విఫలమయిందని మేము సూచిస్తాము.
కాబట్టి, మేము ఏమి చెప్తున్నామంటే,
వాలిడేటింగ్ పార్సర్(validating parser) విషయంలో.
ఇది ఈ స్కీమా(schema) డెఫినిషన్(definition) కి లేదా DTD కంటెంట్కు(content)
అనుగుణంగా ఉండాలి.
నోన్ వాలిడేటింగ్ పార్సర్(non validating parser)
ఎంటిటీలో డెఫినే (define) చేసిన అన్ని ఎలిమెంట్స్
(elements) ని తిరిగి పొందేందుకు ప్రయత్నిస్తుంది,
కనుగొనలేకపోతే, కానీ మొదటి అంశం లో DTD కంటెంట్(content)
ను ప్రాసెసింగ్ (processing) ను తొలగిస్తుంది.
కాబట్టి, ఇది వాలిడేటింగ్ పార్సర్(validating parser) లేదా
నోన్ వాలిడేటింగ్ పార్సర్(non validating parser)
పై ఆధారపడి ఉంటుంది.
అప్లికేషన్ బిహెవీర్ (application behavior) ఖచ్చితంగా
పార్సర్(parser) రకంపై ఆధారపడి ఉంటుంది.
కాబట్టి, ఇది పని ఎలా పనిచేస్తుంది
అనేది పార్సెర్(parser) పై ఆధారపడి ఉంటుంది.
కాబట్టి, మనము ఇక్కడ XML డేటాను పార్సర్(parser)
కు పంపుతాము.
తర్వాత అది XML అప్లికేషన్(application) యొక్క పార్సర్ ఇంటర్ఫేస్(parser
interface) కు వెళుతుంది.
DTD పార్సర్(parser) తో ముడిపడి ఉంటుంది, ఇది పార్సర్
స్వభావంపై రేలేషన్షిప్(relationship), బెహెవీర్ డిపెండెన్సీ
(behavior dependency) ఇస్తుంది.
కాబట్టి, DTD అనేది ఈ పార్సరు(parser)ను తనిఖీ
చేయడానికి, వెల్ ఫోర్మ్ద్ (well formed) వెలిడేషన్
(validation) కు మరియు వెలిడేషన్ (validation) కోసం, సరియైనదిగా
చేస్తుంది.
కొన్ని ప్రత్యేక సమస్యలు ఉన్నాయి,
క్యారెక్టర్స్ (characters) మరియు క్యారెక్టర్
సెట్స్ (character sets) కాబట్టి, XML స్పెసిఫికేషన్(specification)
మాదిరిగా, వైట్ స్పేస్ టాగ్(white space tag) ని ఉపయోగించి
వైట్ క్యారెక్టర్స్ (characters) ని డెఫినే(define)
చెయ్యొచ్చు.
EBCIDIC క్యారెక్టర్స్ (characters), NEL ను వైట్ స్పేస్
టాగ్ (white space tag) గా ఉపయోగించలేరు.
ఎన్కోడింగ్(encoding) క్యారెక్టర్ సెట్(character set)లో నిర్వచించబడని
అక్షరాలను మీరు ఇంక్లూడ్ (include) చేయాలనుకుంటే
ఏమి జరుగుతుంది.
కాబట్టి, ఈ విధమైన క్యారెక్టర్ సెట్
(character set)ల నిర్వహణ కోసం వివిధ మార్గాలు ఉన్నాయి.
ఈ విధమైన క్యారెక్టర్ (character) సెట్ల(sets)ను నిర్వహించడానికి
XML కొన్ని విధానాలను అందిస్తుంది.
ఇప్పుడు, నేను లాంగ్వేజ్ డిఎలెక్ట్ (language dialect)ని
ఎలా నిర్వచించాలి, చివరికి మనం చూడాలని
ప్రయత్నిస్తున్నది సాధారణంగా ఒక XML డాక్యుమెంట్(document)
ను ఎలా నిర్వచించాలి మరియు ఇది ప్రాథమికంగా
ఇతర విషయాలతో ఎలా ఇంటెరక్ట్ (interact) అవుతుంది.
కాబట్టి, మనకు తెలుసు, సర్విస్ ఓరియెంటెడ్
ఆర్కిటెక్చర్(service oriented architecture) లో, మేము
3 ప్రధాన భాగాలను కలిగి ఉన్నాము.
కన్స్యూమర్(consumer), ప్రొవైడర్(provider) మరియు
రిజిస్ట్రీ(registry) లేదా సర్విస్ (services)ల రకాలు
లేదా రేపోసిటోరి(repository) కి కొన్ని విధాల
ఆర్రేస్ (arrays) వంటివి.
ఈ వేర్వేరు సర్వీసు ప్రొవైడర్లు(service
providers), సర్విస్ కన్స్యూమర్(consumer)ల మధ్య ఒక కమ్యూనికేషన్(communication)
ఉన్నప్పుడల్లా, సర్విస్ రిజిస్ట్రీ(service registry)
అంటే మనము చూడవలసినది ఏమిటంటే, ఈ డాటా కమ్యూనికేషన్(data
communication) ఎలా జరుగుతుందో, సర్వవ్యాప్త పద్ధతిలో
అమలు చేయబడుతుంది.
మేము మీకు తెలిసినట్లుగా ఇది ఒక స్కోప్ సందేశంగా
ఉంటుంది, ఇది ప్రాథమికంగా మరియు XML డాక్యుమెంట్(document)
లో సరైనది అయిన ఒక మెషిన్ (machine) కావచ్చు.
soap WSDL, UDDI, వంటివన్నీ అన్ని ప్రధానంగా
XML సరైన డాక్యుమెంట్స్(documents).
కాబట్టి, మీరు XML డాక్యుమెంట్(document) రకం, XML spec యొక్క డిక్లరేషన్(declaration)
భాగం, XML స్కీమా(schema), కొత్త XML స్పెసిఫికేషన్(specification),
XML డాక్యుమెంట్(document) పై బలమైన అడ్డంకులను
అనుమతించే రెండు మార్గాల్లో చూస్తే.
కాబట్టి, మీరు చూస్తున్నది DTD, ఇప్పుడు 2001 XML స్కీమా(schema)
లేదా XSD నిర్వచించబడింది.
కాబట్టి, స్పెక్ట్రం(spectrum)లో అధిక వెర్షన్(version).
ఇది XML డాక్యుమెంట్(document) నిర్మాణం యొక్క స్కీమా(schema)ను
నిర్వచించే ఒక కొత్త స్పెక్(spec).
ప్రధానంగా ఒకే విధమైన జాబ్ (job) చేస్తున్నదాని
కంటే ప్రాథమికంగా లేదా ప్రాథమికమైన
వ్యత్యాసం ఉంటుంది; XML స్కీమ(schema) XML లో రాస్తారు,
అంతేకాదు; అయితే DTD వాస్తవానికి వేరొక
విధంగా రాయబడింది.
కాబట్టి, ఇప్పుడు XML డేటాలో స్కీమా(schema)
ను హ్యాండిల్ (handle) చెయ్యడం.
కాబట్టి, మాండలిక వివరణ జతచేయడం అనేది
రెండు వర్గాల XML లను సూచిస్తుంది, ఒకటవది
వెల్ ఫోర్మ్ద్(well formed) XML డాక్యుమెంట్ను(document),
ఏదైతే సింటాక్తీకలి(syntactically) కరెక్ట్ (correct) గా ఉంటుందో
అది. కాబట్టి, మనము ఏమి చెపుతున్నామంటే
అది వెల్ ఫోర్మ్ద్(well formed) XML, మరియొకటి వ్యాలీడ్
(valid) XML అని పిలువబడే ఒక విషయం ఉన్నది.
కాబట్టి, ప్రత్యేకమైన DTD లేదా XSD లేదా స్కీమా(schema)తో
సరిగ్గా ఏర్పడిన వెల్ ఫోర్మ్ద్(well
formed) మరియు స్థిరమైన XML డాక్యుమెంట్లు(documents),
ఇవి వ్యాలిడేట్ (validate) అయ్యేవి.
ఇది ప్రాథమికంగా స్కీమా(schema) కు అనుగుణంగా
ఉంటుంది; అంటే, ఇది వ్యాలీడ్ స్కీమా(valid
schema).
కాబట్టి, అన్ని వ్యాలిడేట్ (validate) XML డాక్యుమెంట్(documents)లు
వెల్ ఫోర్మ్ద్(well formed).
కాబట్టి, DTD మరియు ఇతర స్కీమ(schema) అంశాలు
ఎలిమెంట్లను మరియు అట్రిబ్యూట్ డేటా(attribute
data), హైరార్ఖికల్ నెస్టింగ్ రూల్స్ (hierarchical nesting rules),
ఎలిమెంట్ (element), కంటెంట్(content) మరియు టైప్(type) నియంత్రణలను
అనుమతిస్తుంది.
కాబట్టి, ఇది స్కీమా(schema) లేదా పేర్కొన్న విషయం.
ఇది డేటా(data) కాదు.
XML స్కీమ(schema) లేదా DTD ఏ XML డేటా(data)ను సరిగా
కలిగి ఉండదు.
XML ఫైల్ లో ఇన్ఫర్మేషన్ (information) ఉంది, కానీ నిర్మాణం
ఇక్కడ నిర్వచించబడింది.
ఇది ఒక ప్రత్యేకమైన ప్రాపర్టీ(property), అనగా
ఎప్పుడు రెండు సంస్థలు A, B ఇన్ఫర్మేషన్ (information)ని
మార్పిడి చేయాలని కోరుతున్నాయి లాంటిది.
కాబట్టి, వారు వెతుకుతున్నది ఏమిటంటే, మొదటిది
ఈ ఎక్స్ఛేంజ్ ప్రోటోకాల్ నిర్మాణంపై ఒప్పుకోవాలి.
ఉదాహరణకు చెప్పాలంటే, ఐఐటీ ఖరగ్పూర్, డేటా
ట్రాన్సఫర్ (data transfer)ని కలిగి ఉంటుంది, పేమెంట్
గేట్వే(payment gateway) లేదా కొంత పేమెంట్ ట్రాన్సఫర్(payment
transfer), బ్యాంకుతో లేదా ఏదైనా ఆర్ధిక సంస్థతో
పేమెంట్(payment) పరస్పరంగా జరుగుతుంది.
ముఖ్యమైనది ఏమిటంటే, ఒక విద్యార్థి డేటా
యొక్క స్ట్రక్చర్ (structure) IIT ఖరగ్పూర్ లో
మరియు అవి స్టేట్ బ్యాంక్లో ఏ విధంగా
స్టోర్ అవుతుంది అనేది మొదటిది.
అవి ఏ బ్యాంకులు అయిన కావచ్చు స్టేట్
బ్యాంక్(state bank) లేదా పంజాబ్ బ్యాంకు(Punjab
bank) లేదా ఏదైనా,ఆ సంస్థతో ఒప్పందం ఉండాలి.
ఆ తేదీ కోసం, ఆ అవసరం కోసం ఏ డేటాను ఎక్స్ఛేంజి
(exchange) చెయ్యాల్సిన అవసరం లేదు?
కాబట్టి, ఇది సరైన విషయం యొక్క ప్రాథమిక
కర్తవ్యం.
దీనికి నేను ఏ డేటాను మార్పిడి చేసుకోవలసిన
అవసరం లేదు. మన అవసరం ఏమిటంటే నిర్మాణం
కంటే ఎక్కువగా, ఏమి ఎక్స్ఛేంజి (exchange)
చెయ్యాలి మరియు ఇన్సిడెంటల్(incidental)గా స్ట్రక్చర్ (structure)
ని ఎక్స్ఛేంజి(exchange) చేయడం అనేది క్లిష్టమైనది
కాదు. ఇక్కడ ప్రైవసీ (privacy) సమస్యలు, ఈ డేటా
నిర్వహణను సేకరించడం కోసం నిర్వహణ వ్యయాల
సమస్యలు ఉన్నాయి.
అది ప్రాథమికంగా మన చేజారిపోతుంది.
అందువల్ల, డేటా చాలా సమస్యలను కలిగి ఉన్నది,
అయితే ఐఐటీ ఖరగ్పూర్లో మనం చూస్తే గనక, ఈ
స్టూడెంట్ స్ట్రక్చర్ (student structure) ఇలా ఉంటుంది.
కాబట్టి, స్టూడెంట్ స్కీమా(student schema) ఇలా
ఉంటుంది.
నేను ఎంత మంది స్టూడెంట్స్ (students) ఉన్నారు, దాని
లక్షణాలు ఏమిటి అనేది చెప్పము, కానీ స్కూల్
(school) విద్యార్ధి యొక్క స్కీమా(schema) ఈ విధంగా
ఉటుంది.
ఇది ఇతర సంస్థతో ఇంటెరక్ట్ (interact) అయితే,
స్కీమా(schema) వారీగా ఇంటెగ్రేషన్ (integration)
సాధ్యమవుతుంది.
ఎలిమెంట్ అట్రిబ్యుట్(element attribute), హైరార్ఖికల్
నెస్టింగ్ రూల్స్ (hierarchical nesting rules), ఎలిమెంట్
(element), కంటెంట్(content) మరియు టైప్(type) పరిమితులను
దీని కొరకు అనుమతిస్తుంది.
స్కీమా(schema)లు, DTD ల కంటే మరింత శక్తివంతమైనవి,
అవి తరచూ టైప్ వ్యాలిడేషన్(type validation) కోసం లేదా XML
నమూనాలకు డేటాబేస్ స్కీమా(database schema) లను
రిలేట్ (relate)చేయ్యడానికి ఉపయోగిస్తాయి.
స్కీమా(schema)లు, DTD కన్నా మరింత శక్తివంతమైనవి.
వారు నిర్మాణాన్ని మాత్రమే ఉంచరు, కానీ
ఇది విభిన్న రకాల విషయాల కోసం ఉపయోగించబడుతుంది.
స్కీమా ఉపయోగించడం వంటి, నేను ఒక డేటాబేస్
టేబుల్(database table) క్రియేట్ (create) చేసి, తర్వాత
ఈ రెండిటి మధ్య ఉబిక్యుఎస్లీ(ubiquously) డేటాను బదిలీ చేయవచ్చు.
కాబట్టి, ఈ స్కీమా(schema)లకు అదనపు నిర్వహణను
అందిస్తుంది.
కాబట్టి, ఈ రోజుల్లో మేము ప్రధానంగా స్కీమాల(schemas)ను
ఉపయోగిస్తాము మరియు విభిన్న పార్టీ(parties)ల
మధ్య ఈ విధమైన ఇంటర్(inter) కార్యకలాపాలను నిర్వహించడానికి
స్కీమా(schema) ఒక ముఖ్యమైన పాత్రను పోషిస్తోంది.
మీరు DTD ఎక్సాంపుల్ (example) ని, డాక్యుమెంట్(document)
లో భాగంగా చూస్తే గనక. డాక్యుమెంట్
టైప్(document type), ఎలిమెంట్స్(elements) బదిలీ, కొన్ని ఇతర
రకాలు ఉన్నాయి.
ఇప్పుడు, మీరు దీనిని చూస్తే, ఇది నిజంగా
XML ఫైల్(file) లేదా XML డాక్యుమెంట్(document) ను సరిగ్గా అనుసరించడం
లేదు. అయితే, ఒక స్కీమా(schema) లో, ఇది XML డాక్యుమెంట్(document)
గా ఉంటుంది.
ఎక్ష్టెర్నల్ (external) DTD ఉంది, ఇక్కడ foo.org
అనేది ఒక DTD. దీన్ని ఎప్పుడైనా రెఫర్
(refer) చెయ్యాల్సిన అవసరం ఉన్నప్పుడు
ఇది ఎక్ష్తెరల్(external)గా రెఫర్ (refer) చేస్తాం.
కనుక, ఇది కొన్ని ఇతర DTD లను రెఫర్ (refer)
చెయ్యడానికి అనుమతి ఇస్తుంది మరియు ఏ
విధమైన డాటా వస్తున్నాయో చూడడానికి అనుమతిస్తుంది.
నేను మరొక ప్రొవైడర్ నుండి డేటాను వినియోగిస్తున్నప్పుడు
నేను చూడాలనుకుంటున్నాను, ఏ విధమైన డేటా వస్తోంది,
అనగా, ఒక ప్రత్యేకమైన ఆర్డర్(order)లో వస్తోందా
లేదా, నిర్తిష్ట హైరార్ఖి(hierarchy) లో
ఉందా. మరొక వైపు నేను ఎక్ష్టెర్నల్ (external)
DTD చేయవచ్చు మరియు అది ఏ విధమైన డేటా
అని చెక్ చెయ్యొచ్చు.
కనుక, ప్రాసెస్(process) చేయడానికి కావలసిన
డాటా, పార్సర్(parser) ద్వారా ఫిల్టర్(filter)
మరియు సేకరించేందుకు అనుమతిస్తుంది.
నా ఆబ్జెక్టివ్ (objective) నేను ఒక సోర్స్ (source)
నుండి డేటాను పొందుతున్నాను, నేను చేయాలనుకుంటున్న
డేటా యొక్క భాగాన్ని సేకరించేందుకు ఫిల్టర్(filter)
చేయాలనుకుంటున్నాను మరియు నేను సెంటైగ్రేడ్
(centigrade) నుండి ఫెరెన్హీట్(Fahrenheit) కు లేదా మీటర్ (meter)
నుండి ఫీట్ (feet) కు యూనిట్ను మార్చడానికి
కావలసిన విధంగా కొన్ని అప్లికేషన్ (applications)లు
అవసరం కావచ్చు.
మేము XML లో మా చర్చను కొనసాగిస్తాము.
XML లో మరికొందరు అర్థం చేసుకోవటానికి XML
యొక్క కొన్ని ఇతర లక్షణాలు అంటే ఈ
ఇంటర్పోపెరాట్(interoperate) కు ఎలా ఉపయోగపడుతున్నాయో
తెలుసుకోవడం మరియు ఎలా ఒక క్లౌడ్ ముఖ్యంగా
సాఫ్ట్వేర్ అస్ ఆ సర్విస్ మోడల్స్(SaaS)
రేయలిజేషన్ (realization) కోసం ఉపయోగపడుతుంది
అనేవి తెలుసుకుందాం.
ధన్యవాదాలు.
