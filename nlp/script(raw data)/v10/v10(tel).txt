స్వాగతం, నేడు మనము క్లౌడ్ కంప్యూటింగ్(cloud
computing)కి మూల కారకమైన మరియు దీని యొక్క
బిల్డింగ్ బ్లాక్(building block) లో ఒకటిగా పరిగణించబడే
వెబ్ సర్విస్ (services)లు మరియు సర్విస్ ఓరియెంటెడ్
ఆర్కిటెక్చర్ (service oriented architecture) ల గురించి
చూద్దాం.
సరిగ్గా దీని అర్థం ఏమిటో మనము చూద్దాం
మరియు మొత్తం ఒవెర్వ్యూ (overview)ని తెలుసుకోవడానికి
ప్రయత్నిద్దామ్.
ఇలా చేయడం వల్ల మనం క్లౌడ్ ని ఎలా నిర్మించాలో
తెలుసుకుంటాం.
వెబ్ సర్వీసెస్ (web services) అనగా ఏమిటి?
దీనికి అనేక వివరణలు ఉన్నాయి, మీరు లిటరేచర్
(literature) మరియు ఇంటర్నెట్(internet)లో కనుగొంటారు.
కాబట్టి, మీరు W3C వెబ్ సర్వీస్ ఆర్కిటెక్చర్(web
service architecture) రిక్వైర్మెంట్స్ (requirement) స్పెసిఫికేషన్
(specification) చూసినట్లయితే, అది ఒక URI చే గుర్తించబడిన
సాఫ్ట్వేర్ అప్లికేషన్(software application), దీని ఇంటర్ఫేస్లు(interfaces)
మరియు బైండింగ్లు(bindings) XML ఆర్టిఫక్ట్స్ (artifacts)ని
గుర్తిస్థాయి.
ఇది చాలా వర్సటైల్(versatile) నిర్వచనం.
కాబట్టి, ఇడి URI మరియు దీని ఇంటర్ఫేస్(interfaces)
లు లేదా బైండింగ్స్(bindings) గుర్తించగల సామర్ధ్యం
ఉన్న సాఫ్ట్ వేర్ అప్లికేషన్లు(software
applications) ను కలిగి ఉంటుంది, కనుక, దీనిని ఉపయోగించి
మీరు XML ఆధారిత లాంగ్వేజ్ (languages)లను ఉపయోగించి
నిర్వచించగలవు, మీరు కనుగొనవచ్చు.
అయితే మైక్రోసాఫ్ట్(Microsoft) ను చూసినట్లైతే,
ఇది ఒక ప్రామాణిక ఇంటర్నెట్ ప్రోటోకాల్(internet
protocol)ని ఉపయోగించి ఆక్సెస్ (access) చేయగల
ప్రోగ్రామబుల్ అప్లికేషన్ లాజిక్(programmable application
logic)గా డెఫినే (define) చేయబడి ఉంటుంది.
IBM ఇచ్చిన మోరోకా నిర్వచనం, వెబ్ సర్విస్
(web service) ఆపరేషన్ (operations) ల కలెక్షన్ (collection)ని
వివరించే ఒక ఇంటర్ఫేస్ (interface), అనగా XML మెస్సేజింగ్
(messaging) ద్వారా ఆక్సెస్ (access) చేయబడే నెట్వర్క్
అని అర్థం.
కాబట్టి, ఈ విభిన్న రకాల నిర్వచనాల నుండి
మనము చూడదగినది ఏమిటంటే ఒక విషయం, అది ఒక XML
ఆధారిత ఫెనిమిన (phenomena).
మనకు తెలిసిన XML ఇది ఎక్కువ డేటా ట్రాన్స్ఫర్మేషన్
లాంగ్వేజ్ (data transformation language), ఇది ఇంటర్పోపరాబిలిటీ(interoperability)లో
సహాయపడుతుంది మరియు అప్లికేషన్(applications)లు
ఒక దానితో ఒకటి కమ్యూనికట్ (communicate) అవ్వడం లో సహాయపడుతుంది.
అందువల్ల, వెబ్ సర్విస్ (web services)లు అనేవి అందుబాటులో
ఉన్న సర్విస్ (services)ల రకాలు, ఇవి URI ను ప్రామాణీకరించడం
ద్వారా అందుబాటులో ఉంటాయి మరియు ఇది
XML ఆధారిత మెసేజ్ ఎక్స్ఛేంజి ప్రోటోకాల్(message
exchange protocol)పై పనిచేస్తుంది.
ఇది ఇచ్చేది ఏమిటంటే ఒక అప్లికేషన్ (application)
మరొక అప్లికేషన్ (application) తో ఎలా అనుసందనీచబడి
ఉంటుంది, ఇక్కడ మనము బాక్ గ్రౌండ్ (background)
ప్రాసెస్ (process) గురించి ఏమాత్రం బాధపడటం
లేదు, మనము పట్టించుకోవలసింది సర్విస్ (service) ఎక్కడ
లభిస్తుంది, దాని మనము ఎలా పొందాలి
అనేది మాత్రమే.
ఇది ఇతర అప్లికేషన్(applications) లు మాట్లాడటానికి
ఈ లెగసీ అప్లికేషన్(legacy application) తీసుకురావడానికి
కూడా సహాయపడుతుంది.
మరొక మార్గంలో మనము చూస్తున్నాం, మరింత
టైట్లీ కాపుల్డ్ (tightly coupled) ప్రోటోకాల్(protocol)
యొక్క క్లయింట్ సర్వర్ రకం తో, వారు మరింత
లూస్లీ కాపుల్డ్ (loosely coupled) క్లయింట్
(client) చాలా సులభంగా ఇంటెరక్ట్ (interact) అవ్వవచ్చు.
ఈ వెబ్ సర్విస్ (services) లను ప్రచారం చేయటానికి
లేదా ప్రోత్సాహించే వివిధ కోణాలలో ఖచ్చితంగా
స్ట్రక్తర్డ్ ప్రోగ్రామ్మింగ్ (structured programming) ఒకటి, ఇది
మన మునుపటి ఉపన్యాసాలలో చర్చించుకున్నట్లుగా
ఆబ్జెక్ట్ ఓరియెంటెడ్ ప్రోగ్రామింగ్(object
oriented programming), డిస్ట్రిబ్యూటెడ్ సిస్టం(distributed system) కు
మరో అంశం గా పుట్టుకొచ్చింది.
కాబట్టి, ఇది ఒక ముఖ్యమైన పాత్ర పోషిస్తుంది.
ఇక్కడ మనం చూడవలసిన మరొక అంశం రెండు
ఏంటీటీ (entities)ల మద్య, ప్రధానంగా వ్యాపార
సంస్థల మధ్య ఎలక్ట్రానిక్ డేటా ఎక్స్ఛేంజి
(electronic data exchange) ఒక నిర్దిష్ట ప్రయోజనం కోసం డేటాను
అనుసంధానించాలనే మరొక భావన ఉంది. అయితే,
ఈ వరల్డ్ వైడ్ వెబ్(world wide web) మొత్తం కంప్యూటింగ్
ఫెనొమెనా(computing phenomena) ఇంటర్నెట్ను ప్రోటోకాల్(internet
ప్రోటోకాల్ చేత ప్రధానంగా నడిచే ఇంటర్న్ నెట్వర్కింగ్(internetworking)
తో ఒకరికొకరు కనెక్ట్(connect) అవ్వడానికి అనుమతిస్తుంది.
ఇలాంటి కొంపోనెంట్స్ (components) ని కలిగి ఉన్నాయి;
ఇప్పుడు వెబ్ సర్విస్( web services) లు లేదా వెబ్
సర్విస్ (web services)ల యొక్క పరిణామాల యొక్క ఈ
అభివృద్ధిని మేము సులభతరం చేశాము.
ఇప్పుడు డిస్ట్రిబ్యూటెడ్ కంప్యూటింగ్(distributed
computing) గురించి ఎక్కువగా చూడడంలేదు, ఎందుకంటే
మనము మన పూర్వ ఉపన్యాసాలలో విస్తారంగా నేర్చుకున్నాం.
డిస్ట్రిబూటింగ్ కంప్యూటింగ్ (distributed
computing) చేస్తున్నప్పుడల్లా ఇంటెరోపేరబిలిటీ
(interoperability) అనేది ప్రధాన సమస్యల్లో ఒకటి;
కనుక, వివిధ వెండార్స్(vendors) లు కమ్యూనికేట్(communicate)
అయ్యి డాటా(data), సాఫ్ట్వేర్(software) మొదలైన వాటిని వివిధ
ప్లాట్ఫాం(platforms) లతో షేర్ (share) చేసుకునే
సామర్ధ్యం అనేది చాలా ఆసక్తికరమైన
ఫెనొమిన (phenomena).
ఈ మొత్తం ప్రపంచ లేదా అనువర్తనం యొక్క
మొత్తం స్వరసప్తకం మీరు ఇతర వెండార్స్(vendors)
నుండి ప్లాట్ఫాం(platforms)లు డేటా(data), సాఫ్ట్వేర్(software)
కమ్యూనికేట్(communicate) చేస్తూ షేర్ (share) చేయడానికి
అనుమతిస్తుంది.
ఇంటెరోపేరబిలిటీ (interoperability) విషయంలో,
సంప్రదాయ యాజమాన్య డిస్ట్రిబ్యూటెడ్
కంప్యూటింగ్(distributed computing) టెక్నాలజీస్(technologies)
తక్కువ స్కోప్ (scope) ఉంటుంది.
పరిమిత స్కోప్ల సందర్భంలో, దీనిని విస్తరించాల్సిన
అవసరం ఉంది.
ఈ ప్రాంతంలో మరొక ప్రధాన అభివృద్ధి
అంటే EDI లేదా ఎలక్ట్రానిక్ డేటా ఇంటర్చేంజ్(electronic
data interchange), జాతీయంగా అంతర్జాతీయంగా గుర్తించబడిన
ప్రమాణాలను ఉపయోగించి కంపెనీ ల మధ్య బిజినెస్
డాటా(business data) మరియు డాక్యుమెంట్(documents)
లను ఒక కంప్యూటర్(computer) నుండి మరొక కంప్యూటర్(computer)
కి మార్పిడి చేయడం.
అంటే, ఇది ప్రధానంగా వ్యాపార డేటా(data) లేదా
ఫార్మాట్ల(formats)లో ఉంటుంది, కానీ ఫార్మాట్ల(formats)ను
రెండు పార్టీలు గుర్తించగలగాలి.
కాబట్టి, A వ్యవస్థ అర్థం చేసుకకుంటుంది;
ఏ రకమైన సందేశం సంస్థ B నుండి వస్తున్నది
అని మరియు తరువాత మార్పిడి జరుగుతుంది.
EDI లో ఉపయోగించే సమాచారం రెండు కంపెనీలు ఎక్స్ఛేంజ్(exchange)
పాల్గొనే ఒక నిర్దిష్ట ఫార్మాట్(format) ప్రకారం
నిర్వహించబడుతుంది.
కాబట్టి, ఫార్మాట్(format) లేదా డేటా(data) మార్పిడికి
ముందుగా ఫార్మాట్(format) లేదా స్కీమా ఎక్స్ఛేంజ్(schema
exchange) ఎలా మార్పిడి చేయాలో లేదా ఫార్మాట్(format)
ని కొంతవరకు ముందుగానే తెలుసుకుంటారు.
కాబట్టి, ఏ విధమైన డేటా(data) ఉండవచ్చు
అనేది పార్టీ(party)కి తెలుసు.
ఇందులో ఎక్కువ ప్రయోజనాలు ఉన్నాయి: అందులో
ఒకటి తక్కువ ఆపరేటింగ్ కోస్ట్ (operating cost).
డాటా(data) ఎప్పుడు ఎక్స్ఛేంజి(exchange) అవుతుందని పట్టించుకోనవసరం
లేదు. ఈ లావాదేవీలు చాలా తక్కువగా ఉండటం
వలన డేటా తక్కువగా ఉన్న డేటా మరింత
ఖచ్చితత్వాన్ని మార్చుతున్నప్పుడు
మీరు తక్కువ శ్రమ ఖర్చుతో కూడుకున్నందున
లాభాలు చాలా ఉన్నాయి.
కాబట్టి, డాటా ఎంట్రీ ఉండదు, తక్కువ మానవ
లోపం. కాబట్టి, నేరుగా ఇతర విషయాల నుండి
సమాచారాన్ని పొందడం వలన ప్రోడుక్తవిటి
(productivity) పెరుగుతుంది.
అనేక కంపెనీలు కలిసి పని చేస్తే ట్రేడింగ్
సైకల్ అనేది ఫాస్ట్ గా ఉంటుంది.
ఇప్పుడు మేము అన్ని విషయాలు కారణం వెబ్
సర్వీసెస్ గురించి చర్చించడానికి.
ఆబ్జెక్ట్ ఓరియంటెడ్ ప్రోగ్రామింగ్(object
oriented programming) ప్రయోజనాలను ఉపయోగిన్చి, ఒక మాడ్యులర్(modular)
విధానం లో, ముందే ఉన్న సాఫ్ట్వేర్(software)
నుండి కొత్త అప్లికేషన్(application) నిర్మించడానికి
డెవలపర్(developers) లను ఎనేబుల్(enable) చేస్తుంది.
కాబట్టి, డెవలపర్(developer), అప్లికేషన్(applications)
లను అభివృద్ధి చేయడానికి, లెగసీ సాఫ్ట్వేర్(legacy
software) లేదా ఇప్పటికే ఉన్న సాఫ్ట్వేర్
(software) నుండి సహాయపడుతుంది మరియు ఒక మాడ్యులర్(modular)
పద్ధతిలో వివిధ అంశాలను అభివృద్ధి చేయడానికి
వారికి వివిధ అంశాలకు సహాయపడుతుంది.
ఒక నెట్వర్క్(network) లేదా ఇంటర్నెట్(internet)
ని, డెవలపర్లకి (developers) అందుబాటులో ప్రోగ్రామటిక్(programmatic)
భాగాలతో కూడిన లైబ్రరీ(library)గా ట్రాన్స్ఫోర్మ్(transform)
చేస్తే, గణనీయమైన ఉత్పాదకత లాభాలు
కలిగవచ్చు.
కాబట్టి, మనము ఒకవేళ వేర్వేరు ప్రోగ్రామింగ్
భాగాల లైబ్రరీ అక్కడ ఉన్నట్లయితే, ఇప్పుడు
మీ అప్లికేషన్(application) ను నిర్మించుకోవచ్చు.
కాబట్టి, ఈ రకమైన ఉదాహరణ ఏమిటంటే మేము
ఈ సర్విస్ (services)లను ఎలా మార్పిడి చేస్తాం,
మనము ఈ ఆన్ లైన్ రిజర్వేషన్లు(online reservations) లేదా బుకింగ్(booking)
వ్యవస్థలు, నేను ఒక రైలును లేదా ఫ్లైట్(flight)
ను బుక్(book) చేస్తాను.
అందువల్ల, మేము యాక్సెస్(access) చేయడానికి ఒక ప్రత్యేక
అడ్రెస్ (address)ను లేదా URI ను ఉపయోగించినప్పుడు
ఆ ప్రత్యేకమైన ప్రయాణ పోర్టల్(portal) విమానాలను,
హోటేల్స్ (hotels)ను కలిగి ఉండకపోతే కనుక, ఇతర
వేర్వేరు ఎయిర్లైన్స్ సర్విస్ (services)లకు
వినియోగదారుని ఎంపికలను చూపించి, బుకింగ్
ప్రక్రియ కొనసాగిస్తే అది క్రెడిట్ కార్డు(credit
card) లేదా డెబిట్ కార్డు(debit card) లేదా నెట్ బ్యాంకింగ్(net
banking) ద్వారా ఇతర సర్విస్ (services)లకు వెళ్తుంది.
అంటారు.
కాబట్టి, మీరు చూసినట్లయితే, ఒక ఉద్యోగం అమలు
చేయడానికి సరైన కొరియోగ్రాఫిక్(choreographic) మార్గంలో అనేక సర్విస్
(services)లను సమ్మేళనం చెయ్యాలి.
కాబట్టి, నా బడ్జెట్(budget) మరియు నా సౌలభ్యం
ఆధారంగా ఉత్తమ విమాన సర్విస్ (service)ని ఎంచుకోవడం
నా పని , మరియు నేను ఆన్లైన్(online) లో సెలెక్ట్(select)
చేయాలనుకుంటున్నాను.
కనుక, నేను ఒక ట్రావెల్ పోర్టల్ (travel portal) కి
లేదా బ్రోకర్ (broker), ఎడైతే వివిధ ఎయిర్లైన్స్(airlines)
విషయాలను చూడడానికి అనుమతిస్తుందో దానిని
మనము ఉపయోగించుకుంటాము.
మరియు నేను నా క్రెడిట్ కార్డు(credit card), డెబిట్
కార్డు(debit card)మొదలైన వాటి ద్వారా చెల్లించి
నాకు అనుకూలమైన వాటిని ఎంచుకుంటాను.
తర్వాత నేను టికెట్(ticket) ను పొందుతాను.
కాబట్టి, ఈ ఎయిర్లైన్స్(airlines) సంస్థలు డైరెక్ట్
గా తెలియవు; నేను వాటిని నేరుగా దాచడం
లేదు, వారు మీ క్రెడిట్ కార్డు(credit card) లేదా
డెబిట్ కార్డు(debit card) సర్వీసు ప్రొవైడర్తో(service
provider) ఏ విధంగానూ కనెక్ట్(connect) చేయబడటం లేదు, మీరు
టికెట్(ticket) కొనుగోలు చేస్తున్నారన్నదాని
గురించి ఏవైనా క్లూ(clue) కలిగి ఉంటారు.
కాబట్టి, అది ఒక నిర్దిష్ట రూపంలో ఒక అభ్యర్థన
పొందినట్లయితే, అది దానిని గుర్తించి,
దానిని ఒక ప్రత్యేకమైన రూపం లో సమాధానం
ఇస్తుంది.
దీని అర్థం, ఇది ఒక విధమైన XML రకం సందేసం,
విషయాల మార్పిడి జరగబోతోంది.
కాబట్టి, ఇది వేరొక రకపు వేర్వేరు రకాలైన
సాఫ్ట్వేర్ కొంపోనెంట్స్(software components) లను లేదా వేర్వేరు
రకాలైన ఇతర అప్లికేషన్ల(applications)ను ఉపయోగించి వివిధ
రకాలైన మెగా అప్లికేషన్ల(applications)లను ఉత్పత్తి చేయటానికి
ఇది అనుమతిస్తుంది.
సో, నేను మిక్స్(mix) మరియు మ్యాచ్(match)
చేస్తూ మరియు అది వివిధ సర్విస్ ప్రొవైడర్(service
providers) ల యొక్క తక్కువ ప్రమేయంతో ఒక choreographic
మార్గం జాబితాలో వెళుతుంది.
కాబట్టి, ఓపెన్ కాని యాజమాన్య ప్రమాణాల
ద్వారా డిస్ట్రిబ్యూటెడ్ కంప్యూటింగ్(distributed
computing)లో ఇంటర్పోపెరాబిలిటి(interoperability) ని మెరుగుపరచడం మీరు
చూస్తే; ఇది సిద్ధాంతపరంగా ఏ రెండు లేదా అంతకంటే
ఎక్కువ సాఫ్ట్వేర్ భాగాలు 99కమ్యూనికేట్(communicate)
చేయడానికి వీలు కల్పిస్తుంది; కాబట్టి, ఇది XML మరియు
దాని విషయాల గురించి మనము చర్చిస్తున్నందున
అది ఓపెన్ స్టాండర్డ్(open standard) మరియు సులభతరం
ఇంటర్పోపెరాబిలిటీ(interoperability)ని ఉపయోగిస్తుంది.
కాబట్టి, డేటాను మార్పిడి చేయడం వంటి
EDI యొక్క సామర్ధ్యంను అందిస్తుంది, కానీ
ఇది సింపుల్ మరియు తక్కువ వ్యయంతో కూడుకుని
వుంటుంది.
డేటా ఫార్మాట్(data format) లో ముందే నిర్వచించబడిన
ఏ విధమైన ఒప్పందాన్ని కలిగి ఉండము.
అయితే విషయాలు ఎక్కడికి వెళ్తున్నాయో తెలుసుకుంటాను.
EDI వ్యవస్థలతో పనిచేయడానికి కాన్ఫిగర్(configure) చేయబడిన
సంస్థలు వెబ్(web) సాంకేతిక సేవలను స్వీకరించినప్పుడు
రెండు సాంకేతిక పరిజ్ఞానాలను ఉపయోగించడం లేదా
EDI ను దశలవారీగా ఉపయోగించడానికి అనుమతిస్తుంది.
సో, www లేదా వరల్డ్ వైడ్ వెబ్(world wide web)
విషువల్ కాంపొనెంట్ (visual components)ను నోన్ విషువల్
కాంపొనెంట్ (non visual components) ని సెపరేట్(separate)
చేసేస్తుంది.
కాబట్టి, ముఖ్యమైనది ఏమిటంటే నేను దృశ్యమానంగా
మరొకదానిని చూడడం నేపథ్యంలో ఏమి జరుగుతుందో.
కాబట్టి, ఈ రెండు విషయాలు మీరు XML రకాన్ని
XML రూపంలో చూస్తే వంటివి వేరు చేయబడతాయి,
XML ఒక డేటా ట్రాన్స్ఫర్మేషన్ లాంగ్వేజ్(data transformation
language).
కాబట్టి, అది ఒక డేటా విజువలైజేషన్(data
visualization) భాష కాదు; మనకు తెలిసిన html, డేటా విజువలైజేషన్
లాంగ్వేజ్ (data visualization language) లేదా అది సరైనదిగా
ప్రదర్శిస్తుంది.
కాబట్టి, ఇంటరాపెరాబిలిటీ(interoperability) రకం సమస్యలపై XML మరింత
పని చేస్తుంది మరియు ఎక్స్చేంజ్(exchange) ఎలా
చేయాలనెదని పై కూడా . డేటా(data) యొక్క XML ప్లస్
స్టైలింగ్(plus styling) యొక్క స్టైలింగ్(styling)
తో XML సమాచారాన్ని వీక్షించడానికి
లేదా ప్రదర్శించడానికి సహాయపడుతుంది.
కనుక, మా సాధారణ http ఆధారిత విషయాలు మాదిరి
కాకుండా అనగా ఇది డాటా ను ప్రదర్శిచడం.
XML అనేది అంతకంటే ఎక్కువ డేటా రెప్రెసెంటేషన్
(data representation) లేదా డేటా ట్రాన్స్ఫర్మేషన్(data
transformation) ఉంటుంది.
బ్రౌజర్(browser) ద్వారా లేదా డెస్క్టాప్
క్లయింట్(desktop client) ద్వారా పరస్పర చర్య, జావా
స్వింగ్(java swing), పైథాన్(python), Windows వంటివి ఉండవచ్చు,
మేము డెస్క్టాప్ క్లయింట్లు(desktop clients)ని
వేర్వేరు రకాలుగా వ్యవహరించవచ్చు
లేదా బ్రౌజర్తో అంతర్ముఖానికి సాధారణ ఇంటర్ఫేస్(interface)
ఉంటుంది.
ఇప్పుడు, వెబ్ సర్విస్(web services) ని చూస్తే, మూడు
ప్రధాన సమస్యలను కలిగి ఉంటుంది.
అందులో మొదటిది ఇంటెరోపేరబిలిటీ (interoperability), దిస్తృబుటెడ్
ఆబ్జెక్ట్ మెస్సేజింగ్(distributed object messaging) లో ఇంటెరోపేరబిలిటీ
(interoperability) స్టాండర్డ్ (standard) లేకపోవడం, ఈ ఇంటర్పోపెరాబిలిటీ(interoperability)
అనేది రెండు పార్టీ(parties) ల మధ్య లేదా రెండు
సాఫ్ట్వేర్(softwares) ల మధ్య ఉంటుంది.
రెండవది ఫైర్వాల్ ట్రావెర్సల్(firewall
traversal).
ఇప్పుడు, వెబ్ సేవ వంటి వివిధ ఇంటర్నెట్
లేదా TCP / IP ఆధారిత ప్రోటోకాల్, ప్రధానంగా http ప్రోటోకాల్
లో piggyback అవుతుంది.
సో, ఇది ప్రధానంగా ఫైర్వాల్(firewall) మీద
వెల్లుతు ఉండాలి , http పోర్ట్(port) నెంబర్
80 అనుమతితో.
సో, వెబ్ సర్విస్ (web service) ఇప్పటికీ పని
చేయవచ్చు.
అందువల్ల, CORBA మరియు DCOM అప్రమాణిక పోర్ట్సు
వెబ్ సేవలను ఎక్కువగా http ను ఉపయోగిస్తుంది.
కాబట్టి, http మాత్రమే కాకుండా ఇతర ప్రోటోకోల్స్(protocols)
ని కూడా ఉపయోగించుకోవచ్చు, కానీ ప్రధానంగా http
యొక్క చాలా ఫైర్వాల్స్(firewalls) పోర్ట్ (port) 80 ను అనుమతిస్థాయి,
ఇది కొన్ని ముఖ్యమైన కోణాలకి దారి తీస్తుంది
వెబ్ సర్విస్ (web service)లో సులభంగా డైనమిక్(dynamic)
సహకారానికి దారితీస్తుంది, చివరిది కాంప్లెక్సిటీ(complexity),
ఇది డెవలపర్(developer) స్నేహపూర్వక సేవా
వ్యవస్థ.
కాబట్టి, అభివృద్ధి చాలా సులభం.
ఓపెన్ టెక్స్ట్(open text) ఆధారిత స్టాండర్డ్(standard)ని
ఉపయోగిస్తుంది.
ఇందులో ఒకటి XML. వివిధ లాంగ్వేజ్ (language)లలో
కొంపోనెంట్స్ (components)ని వ్రాయడానికి మరియు
ప్లాట్ఫారమ్(platform)లో వాటిని కమ్యూనికేట్(communicate)
చేయడానికి అనుమతిస్తుంది.
కాబట్టి, ఇది ముఖ్యం.
ఇది ఇంక్రీమెంటల్ (incremental) గా అమలు చేయబడుతుంది
మరియు డెప్లోయ్మెంట్(deployment) చేయబడుతుంది, ఇతర
ఖర్చులను కూడా పెంచుకోవడమే కాక, ఖర్చులను తక్కువగా
చేస్తుంది మరియు సాంకేతికతలకు ఆకస్మిక
స్విచ్(switch) నుండి సంస్థాగత అంతరాయంను
తగ్గిస్తుంది.
కాబట్టి, ఈ బాహ్య ప్రపంచానికి సరైన
వెబ్ సర్వీసు(web service) ఇంటర్ఫేస్(interface) ఉంటే
ఇప్పటికీ లేగసి సాఫ్ట్వేర్ (legacy software) అండ్ టూల్స్
(tools)ని అమలు చేస్తుంది.
ఇది మరో ప్రధాన అంశం ఇప్పటికీ విభిన్న
అంశాలను కలిగి ఉంది.
కాబట్టి, మనము మళ్ళీ ఓపెన్ స్టాండర్డ్
ద్వారా ఈ సంభాషణ మొత్తాన్ని చూసినట్లైతే
, అది HTTP కావచ్చు, SMTP కావచ్చు లేదా ఏదైనా
ఇతర TCP / IP అప్లికేషన్ లేయర్ ప్రోటోకాల్(application
layer protocol) యొక్క ఏ రకం అయిన కావచ్చు.
రూపొందించిన XML సందేశాలను SOAP ఉపయోగించి ప్రాసెస్(process)
చెయ్యడం, SOAP అంటే ఏమిటో చూద్దాం.
ఇది ప్రాథమికంగా XML ఆధారిత సందేశ వ్యవస్థ
మరియు ప్రజాదరణ పొందిన వాటిలో ఒకటి.
XML వ్యూహాన్ని ఉపయోగించి దాని సందేశాలను వివరిస్తుంది,
ఎలా నా డేటా నిర్వహించబడుతోంది; నేను ప్రాథమికంగా
XML స్కీమ (schema)ను ఎలా ఉపయోగిస్తాను అనేది
వివరిస్తుంది.
WSDL ని ఉపయోగించి తుది వివరణను అందిస్తుంది.
వెబ్ సర్విస్ డిస్క్రిప్సన్ లాంగ్వేజ్ (web service description
language) గురించి తర్వాత తెలుసుకుందాం.
మన సర్విస్(service)ని ఎక్కడ లాంచ్ (launch) చేశారు
మరియు కాన్ఫిగర్(configure) ఎలా ప్రారంభించాలో,
నేను ఒక WSDL వద్ద చేయగలను.
UDDI ను ఉపయోగించి ప్రాథమికంగా పబ్లిష్ (publish) మరియు
డిస్కోవర్ (discover) చెయ్యొచ్చు.
కాబట్టి, నా వెబ్ సర్వీస్ డిస్క్రిప్సన్
(description) డిస్కవరీ (discovery) మరియు ఇంటెగ్రేషన్
(integration) UDDI ద్వారా సులభతరం.
దీనిని అమలు చేయడానికి ఒక మార్గం, మనము బేస్(base)
గా XML ను కలిగి ఉన్నాము.
మనము మూడు ప్రధాన భాగాలు SOAP, WSDL, UDDI కలిగి
ఉన్నాము.
కాబట్టి, ఇవన్నీ అన్ని W3C కొంపోనెంట్స్
(components) మరియు de facto XML ఆధారిత విషయాలు ఉపయోగిస్తాము,
ఇవన్నీ ఎలా వర్క్ (work) అవుతాయో పరిశీలిస్తాము.
ఒక ఉదాహరణ కొనుగోలు చేయడం.
పర్చేస్ ఆర్డర్ (purchase order) అప్పుడు క్రెడిట్
చెక్(credit check), రిజర్వ్ (reserve)జాబితా, క్రెడిట్
(credit)ప్రతిస్పందన, జాబితా ప్రతిస్పందన,
సంఘటిత ఫలితం మరియు ఇన్వాయిస్(invoice) ఉంటాయి.
కాబట్టి క్రెడిట్ సర్విస్ (credit service), ఇన్వెంటరీ
సర్విస్(inventory service), పి.ఒ. సర్వీసులు మొదలైనటువంటి
విభిన్న పార్టీలు ఉన్నాయి మరియు వాటికి
సేవలను అందించటానికి రూపకల్పన చేయబడతాయి.
ఇది ఒక రిసోర్సస్ (resources) నుండి తీసుకోబడింది,
కానీ అది ఏ విధంగా ప్రయత్నిస్తుంది,వివిధ
రకాలైన సర్వీసెస్(services) ను అందించగలదు, కంపోజ్
చేసి మరియు విభిన్న రకాల అప్లికేషన్(applications)
లను కలిపి ఒక పెద్ద అప్లికేషన్(application)
ని సృష్టించగలము.
ఈ అప్లికేషన్(application) ని ఇతర రకాల తో choreograph
లేదా విలీనం చేసినప్పుడు; కొన్ని ఇతర రకాల
సర్వీసెస్(services) ను అందిస్తుంది.
ఇప్పుడు ఈ మొత్తం విషయం చూస్తూ ఉంటే,
మనకు అర్థం అయ్యేది ఏమిటి అంటే ఇది అంతా
కూడా మరొక ఆర్కిటెక్చర్ (architecture) కు దారి తీసింది.
అదే వెబ్ సర్విస్ ఓరియెంటెడ్ ఆర్కిటెక్చర్
(web service oriented architecture) SOA. అందువల్ల, IBM లు వెబ్ సర్విస్
(web service) ఇంటెరాక్సన్(interaction) ను చూపించడానికి
ఒక నమూనాను రూపొందించాయి, ఇది మూడు సంస్థల
మధ్య సంబంధాన్ని కలిగి ఉన్న సర్విస్
ఓరియెంటెడ్ ఆర్కిటెక్చర్ (service oriented architecture)గా సూచిస్తారు.
కాబట్టి, ప్రాథమికంగా మనకు మూడు భాగాలున్నాయి;
ఒక సర్వీస్ ప్రొవైడర్(service provider), ఒక సర్విస్ రెక్వెస్టర్(service
requester) లేదా సర్విస్ కన్స్యూమర్(consumer) మరియు
సర్వీస్ బ్రోకర్(service broker).
ఇక్కడ కన్స్యూమర్(consumer) మరియు ప్రొవైడర్(provider),
రెక్వెస్టర్(requester) లేదా కన్స్యూమర్(consumer)
మరియు బ్రోకర్(broker) కి మధ్య ఇంటెరాక్సన్(interaction),అనగా
సేవలు ఎక్కడ లభిస్తాయో తెలుసుకోవడానికి
అనుమతించే ఒక విషయం ఉంది.
ఇక్కడ మనం చూస్తున్న చిత్రం చాలా ప్రజాదరణ
పొందింది, చాలా లిటరేచర్(literatures) లలో మనం చూడవచ్చు.
అందువల్ల, సర్వీస్ ప్రొవైడర్(service provider)
నుండి సర్విస్ (services)లను పొందాలనుకుంటున్న
సర్విస్ రెక్వెస్టర్ (service requester) లేదా కన్స్యూమర్
(consumer) ని కలిగి ఉన్నాము; కానీ ఇక్కడ సర్విస్
(services)లు ఎక్కడ ఉంటాయో సర్విస్ రెక్వెస్టర్
(service requester) ఎలా కనుగొంటాడు?
దీని కొరకు ఇక్కడ ఏ రకమైన సేవలు ఉన్నాయో
తెలుసుకోవడానికి రిజిస్ట్రీ(registry) ఉంది.ఇక్కడ
మనం ఏ రకమైన సర్విస్(services)లు ఉన్నాయి అనేది తెలుసుకోవచ్చు.
దీనికి సంభంధించిన ఒక అనాలోజీ (analogy) చూద్దాం,టెలిఫోన్
ఎక్స్ఛేంజి(telephone exchange) నుంచి వచ్చే టెలిఫోన్
డైరెక్టరీ(telephone directory) తీసుకుంటే.
యెల్లో పేజీ(yellow pages)లు, వైట్ పేజీ(white pages)లు
మొదైలనవి మొదట్లో ఉండేవి.
కాబట్టి, ఎక్కడ ఏది కనుగొంటారు?
కాకుండా డైరెక్టరీ(directory) కూడా ఒక నిర్దిష్ట
విషయం కోసం శోధించడం ఎలా అనేది చెప్పదు;
మీరు ప్లంబింగ్(plumbing) లేదా బేస్(base) లేదా
ఏదో కోసం చూస్తున్నారు అనుకుందాం.
డైరెక్టరీ సర్విస్ (service) లేదా రిజిస్ట్రీ
సర్విస్ (service)గా పనిచేస్తుంది.
కాబట్టి, ఆ రకమైన విషయాలు కూడా ఇక్కడే
రిజిస్ట్రీ సర్విస్ (service)ను కలిగి ఉంటాయి.
ఇక్కడ సర్విస్ డిస్క్రిప్సన్ (service description) ఉటుంది,
సర్విస్ రెక్వెస్ట్ (service request) లు QSDL మరియు
UDDI ఉపయోగించి రిజిస్ట్రీ సర్విస్ (registry service) నుండి
అవసరమైన సర్విస్ (service)ను కనుగొంటాయి
మరియు అది ప్రధానంగా ఒక సర్విస్ ప్రొవైడర్(service
provider) తో అనుసందనించబడి ఉంటుంది.
ఎక్కువ సర్విస్ ప్రొవైడర్(service provider) లను మనం గుర్తించవచ్చు.
సర్విస్ (service)ను నవీకరించినప్పుడు కొత్త సర్విస్ (service)
ప్రారంభించిన తర్వాత ఒక సర్విస్ ప్రొవైడర్(service
provider) ఆ సర్విస్ (service) ని రిజిస్ట్రీ(registry)లో
ప్రాథమికంగా పబ్లిష్ (publish) చేస్తారు, తద్వారా
కాబోయే కొనుగోలుదారు లేదా కాబోయే వినియోగదారు.
కస్టమర్ అభ్యర్థి ఈ సర్విస్ (service)ల రకాలు
ఎక్కడ ఉన్నాయో తెలుసుకోవచ్చు.
ఇది వివిధ కాంపొనెంట్ (components)లు పనిచేసే ఒక
త్రిభుజం అని మీరు కనుగొనవచ్చు మరియు
ఈ రకమైన అంశాల ఆధారంగా ఏదైనా ఉంటే అది ఒక
సర్విస్ (service) నడిపే లేదా సర్విస్ ఓరియెంటెడ్
ఆర్కిటెక్చర్(service oriented architecture) అని అంటాము.
ఈ వెబ్ సర్విస్ మోడల్స్(web service models) లో వెబ్ సర్విస్
ఆర్కిటెక్చర్ (web service architecture) రోల్స్ (roles)
ని మనం చూసినట్లైతే, మొదటగా సర్విస్ ప్రొవైడర్
(service provider): వీరు సర్విస్ (service) యొక్క యజమాని
గా ఉంటారు, ఇది సర్వీసెస్ (services) ను అందించే ఒక
ప్లాట్ఫారమ్(platform).
రెండవది సర్విస్ రెక్వెస్టర్ (service
requester) లేదా కొంసుమర్ (consumer): ఎవరైతే సర్వీసెస్
ని వినియోగించుకుంటారో వాళ్ళు.
మరియు చివరిది సర్విస్ రిజిస్ట్రీ (service registry):
సర్విస్ డిస్క్రిప్సన్ (service description) వెతకడం కోసం
ఉపయోగించే రిజిస్ట్రీ (registry), ఇందులో సర్విస్
ప్రొవైడర్ (service provider) వారి సర్విస్ (service)
వివరణను పబ్లిష్ (publish) చేస్తాడు.
ఈ వెబ్ సర్విస్ ఆర్కిటెక్చర్(web service architecture) లో మూడు
ప్రధాన కార్యకలాపాలు ఉంటాయి, అందులో మొదటిది
పబ్లిష్ (publish): ఇది సర్వీస్ ప్రొవైడర్
సర్విస్ (services)లను ప్రచురిస్తుంది.
రెండవది, ఫైండ్ (find): కస్టమర్(customer)కు అవసరమయ్యే
సర్విస్(services)లను కనుగొంటుంది.
చివరిది, బైండ్ (bind): ఇది ప్రొవైడర్(provider)
తో సర్వీస్ కన్స్యూమర్(consumer)ని కలుపుతుంది.
వెబ్ సర్విస్(web service) యొక్క కొంపోనెంట్స్(components)
లో ఒక ప్రముఖ కాంపొనెంట్ (components) XML, ఎక్స్టెంసిబుల్
మార్క్అప్ లాంగ్వేజ్ (extensible markup language).
నేను మీకు దీని గురించి తెలిసే ఉంటుంది అనుకుంటున్నాను,
ఒకవేళ తెలియకపోతే, ఒక ప్రామాణిక పుస్తకం
ద్వారా లేదా W3C ట్యుటోరియల్(tutorial) ద్వారా తెలుసుకోవచ్చు.
ఇది XML కి సంబంధించి ఒక మంచి ట్యుటోరియల్(tutorial).
రెండవ కాంపొనెంట్ (component) SOAP సింపుల్ ఆబ్జెక్ట్
ఓరియెంటెడ్ ప్రోటోకాల్(simple object oriented protocol), ఇది ఒకే
రకమైన డాటా రెప్రెసెంటేషన్ (data representation) ను మరియు
మార్పిడి విధానాలను అందిస్తుంది.
ఇది XML ను ఉపయోగించటానికి సమాచార మార్పిడికి
సరైన మార్గం.
మూడవది,WSDL వెబ్ సర్వీసెస్ డిస్క్రిప్షన్ లాంగ్వేజ్(web
service description language), ఇది XML ను ఉపయోగిస్తుంది
మరియు అందించబడిన సర్విస్ (services)ల గురించి
వివరించడానికి ఒక ప్రామాణిక మెటా లాంగ్వేజ్
(meta language).
చివరిది UDDI, యునివర్సల్ డిస్క్రిప్షన్ డిస్కవరీ
మరియు ఇంటిగ్రేషన్(universal description discovery and integration) స్పెసిఫికేషన్(specification),
ఇది రిజిస్ట్రీ సర్విస్ (registry service)ను నిర్మించడానికి
సహాయపడుతుంది, మరియు వెబ్ సర్విస్ అప్లికేషన్(applications)లను
రిజిస్టర్ (register) చేయడానికి మరియు గుర్తించడం
కోసం ఒక పద్దతిని అందిస్తుంది.
క్లయింట్, సర్విస్ (services)లను గుర్తించడానికి
రిజిస్ట్రీ(registry)కి క్వెరీ(query) పంపుతారు,
రిజిస్ట్రీ(registry) వివరణ ఉన్న WSDL డాక్యుమెంట్
(document)న్ని సూచిస్తుంది, క్లయింట్ ఈ WSDL డాక్యుమెంట్(document)
ని యాక్సెస్(access) చేస్తాడు.
ఇది వెబ్ సర్విస్ (services)లతో ఇంటెరాక్ట్(interact)
అవ్వడానికి కావలసిన డాటా(data)ను అందిస్తుంది.
క్లయింట్ను SOAP మెసేజ్ (message) రెక్వెస్ట్(request)ని
ప్రొవైడర్(provider) కి పంపుతారు.
మరియు వెబ్ సర్విస్ (web service) SOAP మెసేజ్ రెస్పోంస్
(response)ను తిరిగి పంపుతుంది.
ఇది ఒక కాంపొనెంట్(components)ల సమూహం మరియు ఇవ్వన్ని
కూడా అండర్లయింగ్(underlying) ఇంటర్ నెట్వర్కింగ్(internetworking)
లేదా ప్రామాణిక నెట్వర్క్ ప్రోటోకాల్(network protocol)
TCP/IP లేదా OSI పై పని చేస్తాయి.
కాబట్టి, UDDI వివరణను SOAP మెస్సజింగ్ (messaging)లో
ఒక వెన్నెముకగా చెప్పవచ్చు; UDDI అనేది ఒక స్టాటిక్
పబ్లికేషన్ (publication)గా ఉండవచ్చు లేదా అది
ఒక డైనమిక్ పబ్లికేషన్ (publication)గా అయినా ఉంటుంది
మరియు తరువాత WSFL అనగా ఫ్లో (flow)నిర్వహణ.
కాబట్టి, ఇతర రకాలైన అంశాలలో మరియు మూడు
ఇతర కాంపొనెంట్(components)లు ఉన్నాయి, ఇందులో
ఒకటి క్వాలిటి ఆఫ్ సర్విస్(quality of service):
ఏ విధమైన సర్విస్ (services)లు అందిస్తారు,
వారు QS మేనేజ్మెంట్ సమస్యలు అనగా మొత్తం
ఎలా నిర్వహించాలీ, ఆపై సెక్యూరిటి (security)
అంశాలు ఉంటాయి, భద్రతా ఉల్లంఘన ఎలా ఉందో
లేదో, భద్రతా విధానాలు ఏవి, ఎవరిని నమ్మాలి
మొదలైనవన్నీ ఉంటాయి.
XML, ఇక్కడ ఎక్కువగా చర్చించడం లేదు;
ఇది ఒక జెనరలైజేడ్ మార్కప్ లాంగ్వేజ్
(generalized markup language) యొక్క ప్రామాణిక సాధారణ
పద్ధతి నుండి ఉద్భవించింది.
ఇది ఎక్స్టెంశీబుల్ మార్కప్ లాంగ్వేజ్(extensible
markup language), ఇది ప్రాథమికంగా డేటాను వివరించడానికి
ఉపయోగించబడుతుంది మరియు ప్రెజెంటేషన్(presentation)
నుండి కంటెంట్(content)ను వేరుచేయడంలో ఇది
సహాయపడుతుంది.
XML డాక్యుమెంట్(document) DTD ద్వారా సూచించబడుతుంది,
DTD ద్వారా మరింత జనాదరణ పొందినది XSD, అనగా
XML స్కీమా డెఫినిషన్ లాంగ్వేజ్ (schema definition
language), ఇక్కడ మనము స్కీమ(schema)ను నిర్వచిస్తాము.
XML లో టాగ్(tags)లు ముందే నిర్వచించబడలేదు.
కాబట్టి, మీ స్వంత ట్యాగ్లను మీరు నిర్వచించవచ్చు.
అదే html లో అయితే నిర్వచించలేము అవి ప్రీ డెఫిన్ద్(predefined).
ఇది వెబ్ సర్విస్(services) ల్లో క్రాస్ ప్లాట్ఫామ్
కమ్యూనికేషన్ను(cross platform communication) ని అందిస్తుంది.
కాబట్టి, ఇది సాధారణంగా ఒక XML విషయం వివరిస్తుంది.
క్షమించాలి, ఇది ఒక html విషయం, ఇది ప్రాథమికంగా
ఒక వ్యక్తి అడ్రెస్(address)ని లేదా వ్యక్తిగత ఇమెయిల్
అడ్రెస్ (address) ని నిర్వచిస్తుంది.
ఇందులో జాన్ అనే వ్యక్తి యొక్క పరిచయం
నిర్వచించబడిందని తెలుపుతుంది.
ఈ html ను ఏ బ్రౌజరు(browser)లో అయినా మేము ఉపయోగిస్తే
పై విధంగా ఉంటుంది, దీనినే XML లో చూడాలనుకుంటే,
ఇది ఇలా కనిపిస్తుంది.
కాబట్టి, ఇది డేటా దేస్క్రిప్షన్(data
description) కంటే ఎక్కువ.
కాబట్టి, ఇది ఒక పేరు, ఇది అడ్రెస్ (address),
ఇది కంట్రి ఫోన్(country phone), ఇ-మెయిల్(e-mail) మరియు
ఇంకేదైనా కావచ్చు.
కాబట్టి, ఇది ఒక XML రకానికి చెందినది.
ప్రెసెంటేషన్(presentation) కాదు. కాబట్టి, రెప్రసెంట్
(represent) చెయ్యడం కోసం ఏదో ఒకటి అవసరం.
మూడు ప్రధాన అంశముల గురించి చర్చిస్తున్నాము,
అందులో ఒకటి SOAP, ఇది మెసేజ్ ప్రోటోకాల్(message
protocol) కంటే ఎక్కువ.
సింపుల్ ఆబ్జెక్ట్ యాక్సెస్ ప్రోటోకాల్(simple
object access protocol) ఫార్మాట్(format) వంటిది.
దీనిని ఇంటర్నెట్(internet)లో మెసేజ్(messages)లను పంపడానికి
ఉపయోగిస్తారు.
ఇది XML పై ఆధారపడి ఉంటుంది, W3C లో ఉంటుంది.
దీనికి స్టేట్ (state) ఉండదు మరియు ఇది
ఒన్ వే (one way) ప్రోటోకాల్(protocol).
ఇది ప్రధానంగా http ని ట్రాన్స్పోర్ట్
ప్రోటోకాల్(transport protocol) గా ఉపయోగిస్తుంది.
ఈ ట్రాన్స్పోర్ట్ ప్రోటోకాల్(transport protocol)
ని TCP / IP ట్రాన్స్పోర్ట్ ప్రోటోకాల్(transport protocol)
తో కలపకూడదు, ఇది ఈ వెబ్ సర్విస్(services)లను
ట్రాన్స్పోర్ట్ (transport) చేస్తుంది.
ఇక్కడ HTTP క్యారియర్ ప్రోటోకాల్(carrier protocol)
ని యాక్సెస్(access) చేస్తుంది.
కనుక, వివిధ బిల్డింగ్ బ్లాక్(building blocks)లు
ఉన్నాయి.
SOAP బిల్డింగ్ బ్లాక్స్(building blocks) గురించి తెలుసుకుందాం.
ట్రాన్స్పోర్ట్ ప్రోటోకాల్(transport protocol)
ఒక ఎన్వలప్(envelope)గా ఉంటుంది, దీనిలో
MIME హెడర్ (header) ఉంటుంది.
తర్వాత SOAP ఎన్వలప్(envelope), SOAP హెడర్ (header), SOAP బాడీ(body)
మరియు ఫాల్ట్ (fault) మరియు డెయిఫికేషన్
(deification) సందర్భాలు ఉన్నాయి, కానీ అన్ని
XML పై ఆధారపడి ఉంటాయి.
మెసేజ్ స్ట్రక్చర్ (message structure), ఇది ఒక SOAP
స్పెసిఫికేషన్(specification) ఎన్వలప్(envelope) ని డెఫినే
చేస్తుంది.
ట్రాన్స్పోర్ట్(transport) మీద పిగ్గీబ్యాక్(piggyback)
చేయబడుతుంది, ప్రధానంగా ఒక ఎన్వలప్(envelope) అవుతుంది
మరియు ఈ http లో ఈ ట్రాన్స్పోర్ట్ ప్రోటోకాల్(transport protocol)
కోసం పే లోడ్(pay load) అవుతుంది, ఇక్కడ
పునరావృతం చేసీన ట్రాన్స్పోర్ట్
ప్రోటోకాల్లను(transport protocol) TCP / IP లేదా OSI ప్రోటోకాల్స్(protocols)
తో కలపబడదు.
SOAP రెక్వెస్ట్ (request), ఇది http లో post మెసేజ్
(message) గా ఉంటుంది.
ఈ విషయంలో SOAP మెసేజ్ (message)కి ఒక పోస్ట్
మెసేజ్ (post message)ని మీరు చూస్తే అది ఒక నిర్దిష్ట
స్టాక్ ధర ను మరియు స్టాక్ నేమ్ (stock name)
కోసం ప్రత్యేకించి IBM మొదలైనవాటి కొరకు
ఉపయోగపడుతుంది.
మరియు తిరిగి రెస్పోంస్ (response) ఇస్తుంది.
మళ్ళీ మీరు ఆ http రెస్పోంస్ (response) చూసినట్లయితే,
దాని రెస్పోంస్ (response) ఒక వాల్యూ (value) గా ఉంటుంది.
డేటాను మార్పిడి చేసే స్ట్రక్చర్
వే(structured way) కంటే ఎక్కువగా ఉంటుంది, ఇది ప్రదర్శన
యూనిట్ కోసం ఒక విషయం యొక్క ఒక HTML రకాన్ని
కలిగి ఉండవచ్చని చెప్పడం లేదు.
ఎందుకు SOAP?
ఈ రకం అప్లికేషన్ చేయలేని ఇతర టెక్నాలజీస్(technologies)
ఉన్నాయి, SOAP ఒక ప్లాట్ఫాం (platform), తటస్థ ఎంపిక,
సాధారణ XML వైర్ ఫార్మాట్(wire format), మీరు మీ లెగసీ(legacy)
విషయాలను అమలు చేసే టెక్నాలజీ కి పరిమితులు
లేవు.
మూడు ప్రధాన లక్షణాలు ఉన్నాయి.
అవి ఎక్స్టెంశీబుల్ (extensible),న్యూట్రల్ (neutral)
మరియు ఇన్డిపెన్డంట్(independent).
కాబట్టి, ఇది డిస్ట్రిబ్యూటెడ్ అప్లికేషన్(distributed
applications) లకు ప్రతి ఇతర మరియు రకం విషయాల
కోసం సరిగ్గా సరిపోతుంది.
మరియు వేర్వేరు వాడుక నమూనాలు ఉన్నాయి,
ఒక మెసేజ్ మార్పిడి లేదా SOAP స్పెసిఫికేషన్(specification)
వంటివి RPC గా ఉండవచ్చు.
ఇతర సెక్యూరిటి(security) అంశాలు, వీటి గురించి
మనము తర్వాత తెలుసుకుంటాము.
మరొకటి WSDL, వెబ్ సర్విస్ డిస్క్రిప్షన్ లాంగ్వేజ్(web
service description language).
కాబట్టి, ఇది XML బేస్(base) W3C కంటెంట్(content), దీనిని
వివరించడానికి మళ్ళీ అనుమతిస్తుంది.
ఇది విభిన్న స్ట్రక్చర్(structure)ని కలిగి ఉంటుంది, వాటిలో
పోర్ట్ టైప్(port type) ఒకటి, ఎక్కడ ప్రత్యేకమైన
సర్విస్ (services)లు ఎనేబుల్(enable) చేయబడతాయో మరియు
ఒక వెబ్(web) విషయాలు ఎక్కడ ఉంటాయో తెలుస్తుంది;
మెసేజ్(message) మరియు టైప్స్ (types) మొదలగునవి
ఉంటాయి.
ప్రొవైడర్ (provider) కి మరియు కొంసుమర్ (consumer)
ల మధ్య బైండింగ్(binding) ప్రాసెస్ (process) జరుగుతుంది.
ఇది సాంపుల్(sample) WSDL మెసేజ్(message), ఇక్కడ
SOAP మెసేజ్(message) మరియు WSDLల మధ్య బైండింగ్(binding)
ఉంటుంది.
దీని అర్ధం, SOAP మెసేజ్(message) యొక్క డెస్క్రిప్షన్(description)
డేటా ఎలా ట్రాన్సఫర్(transfer) చేయబడుతుందో, సోర్స్
(source) మరియు దేస్టీనేషన్(destination) కి మధ్య లేదా రెక్వెస్టర్
(requester), రిజిస్ట్రీ(registry)కి మరియు కోన్స్యూమర్
(consumer) మధ్య బైండింగ్ (binding)ఎలా ఉంటుంది.
చివరగా UDDI, యునివర్సల్ డిస్క్రిప్షన్ డిస్కవరీ
అండ్ ఇంటెగ్రేషన్ (universal description discovery and integration).
ఇది ఒక రిజిస్ట్రీ సర్విస్(registry service).
XML ఆధారిత రిజిస్ట్రీ(registry))లను నిర్వచించడానికి
ఇది ఒక ఫ్రేమ్ వర్క్(frame work).
కాబట్టి, అన్నీ మెటాడేటా సమాచారాలు ఇక్కడ
ఉంటాయి.
కోన్స్యూమర్ (consumer) లేదా రెక్వెస్టర్
(requester) లు నిర్దిష్ట స్థావరాలకు మరియు
ఎలా ప్రత్యేక ప్రొవైడర్(provider) తో ముడిపడి ఉంటుంది.
మునుపటి స్లైడ్స్(slides)ను గుర్తుంచుకున్నట్లయితే
ఇది ఒక సర్వీస్ ప్రొవైడర్ రిజిస్ట్రీ(service provider
registry) మరియు రెక్వెస్టర్ (requester).
కాబట్టి, ఒరిఎన్టేషన్(orientation) భిన్నంగా ఉంటుంది.
రిజిస్ట్రీ(registries) లో సర్వీస్ ప్రొవైడర్(service
provider) దానిని పబ్లిష్(publish) చేస్తారు, రెక్వెస్టర్
(requester) దాన్ని కనుగొని, బైండ్ (bind) చేస్తారు.
కాబట్టి, మొత్తం వర్క్(work)ని కలిసి
పనిచేయడం కోసం అది చాలా ముఖ్యమైన పాత్ర
పోషిస్తుంది.
మీరు అదే విషయం అయితే, ఇది ప్రధానంగా కోన్స్యూమర్
(consumer) సర్చ్ (search) చేసే మరో విషయాన్ని పబ్లిష్(publish)
చేస్తుంది మరియు ప్రొవైడర్(provider) తో
బైండింగ్(binding) చేయాలి.
రిజిస్ట్రీ సర్విస్(registry service) డేటా(data)ను ప్రత్యేకమైన
ఫార్మాట్(format)లో ఉంచితే చాలా ప్రయోజనాలు
ఉన్నాయి.
సో, అక్కడ శోధన ఉంటుంది, ఇది సాధ్యం వ్యాపార
ఆన్లైన్ ప్రస్తుతం లక్షలాది నుండి కనుగొనడంలో
సాధ్యం.
సో, మీరు ఇష్టపడే వ్యాపార తో కనెక్టివిటీ(connectivity)ని
ఎనేబుల్(enable) ఎలా చేయవచ్చు మొదలగునవి ఉంటాయి.
ఈ సెక్యూరిటి (security) ఎలా పని చేస్తుంది
అనే వివరాల్లోకి ఇప్పుడు వెళ్ళడం
లేదు. సెక్యూరిటి (security) అనేది SOAP యొక్క
మరో ముఖ్యమైన అంశం, వెబ్ సర్విస్(web services)ల
యొక్క అంశం, మనము మునుపటి ఫిగర్ (figure)
లో చూసినట్లుగా ఇది వర్టికల్ లైన్(vertical
line) లో పని చేస్తోంది, ఇది వెబ్ సర్విస్
పాలసీ (web service policy), ట్రస్ట్(trust), ప్రైవసీ (privacy), సెక్యూర్
కాన్వర్సేషన్(secure conversation), ఫెడరేషన్ (federation)
మరియు ఆథరైజేషన్(authorization) వంటి విభిన్న భాగాలను
కలిగి ఉంది. కాబట్టి, నిర్వహణ మరియు QoS
లాంటి ఇతర విషయాలు కూడా ఉంటాయి.
కాబట్టి, ఈ ప్రత్యేక ఉపన్యాసంలో మనము
చూడాలనుకుంటున్నది ఏమిటంటే, ఈ వెబ్ సర్విస్(web
services)లు మరియు సర్విస్ ఓరియెంటెడ్ ఆర్కిటెక్చర్
(service oriented architecture), ఇది క్లౌడ్(cloud) ని ఏర్పాటు
చేయడానికి ముఖ్యమైన పాత్ర పోషిస్తుంది.
మొత్తం క్లౌడ్ ప్రాసెస్(cloud process) ని IaaS, PaaS లేదా SaaS
లేదా XaaS , ఎనీథింగ్ అస్ ఆ సర్విస్ (anything
as a service) అని చెప్పవచ్చు.
దీని ప్రాథమిక బిల్డింగ్ బ్లాక్(building block) అనేది
వెబ్ సర్విస్ (web services)లను పబ్లిష్(publish), ఫైండ్
(find) మరియు బైండ్ (bind) చేయడం వంటి అన్ని
విషయాలను సూచిస్తుంది, క్లౌడ్ సర్విస్ (cloud
services)లకు కూడా ఇదే వర్తిస్తుంది.
ఇక్కడ మనం ప్రాథమికంగా ఎవరు సర్వీస్ ప్రొవైడర్(service
provider) మరియు కోన్స్యూమర్ (consumer) , సర్విస్ (service)
ఏ రకానికి చెందింది,ఎక్కడ లాంచ్(launch) అయ్యింది
అనేది తెలుసుకోవలసిన అవసరం ఉంది. కాబట్టి,ఇది
క్లౌడ్ సర్విస్(cloud services) లను నిర్వహించడానికి
సరైన మార్గంగా విస్తరించింది.
కనుక, ఈ వెబ్ సర్విస్(web services)లు మరియు సర్విస్
ఓరియెంటెడ్ ఆర్కిటెక్చర్ (service oriented architecture) అభివృద్ధి,
ఈ క్లౌడ్ కంప్యూటింగ్(cloud computing) ని ఆచరనాత్మకంగా
చేయడం లో ముఖ్యమైన పాత్ర పోషించాయి.
ఈ రోజు ఇక్కడితో మన చర్చను ముగిస్తాము.
క్లౌడ్ కంప్యూటింగ్ యొక్క ఇతర అంశాలతో
మన భవిష్య ఉపన్యాసంలో కొనసాగుతాము.
ధన్యవాదాలు.
