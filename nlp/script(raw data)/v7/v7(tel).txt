లో మా తదుపరి ఉపన్యాసంకు స్వాగతం.
మేము త్వరగా వర్చువలైజేషన్ (virtualization) గురించి తెలుసుకుందాం.
మేము ఇప్పటికే మన మునుపటి ఉపన్యాసాలలో
ఈ అంశాలను కొన్ని చర్చించారు.
ఇక్కడ కోర్ (core) అంశాల పై మరికొన్ని స్లయిడ్(slide)లు
వున్నాయి, అది ప్రధాన భావనలలో ఒకటి. అందువల్ల,
ఈ క్లౌడ్ కంప్యూటింగ్(cloud cloud) యొక్క వర్చువలైజేషన్(virtualization)
అనేది ప్రధాన అంశాలలో ఒకటి. ఇది క్లౌడ్
కంప్యూటింగ్(cloud computing) ఉన్నప్పటి నుంచే
, వర్చువలైజేషన్ (virtualization) ఉంది. కనుక
ఇది కొత్త విషయం కాదు. మనలో చాలామంది
వర్చువలైజేషన్ (virtualization) ఉపయోగిస్తున్నారు.
LINUX సిస్టం(system) మీద, ఒక విండో సిస్టమ్పై(window
system) మనం వర్చువలైజేషన్ (virtualization) చేస్తాము.
కాబట్టి, నేను ఒక విధమైన వర్చువల్(virtual)
రియలైజేషన్(realization) కలిగి ఉన్నాను.
మరో వైపు చూస్తే, నెట్వర్కింగ్(networking),
మొదలైనటువంటి వివిధ ఇతర రెసోర్స్ (resources)
లను ఉపయోగిస్తారు.
కాబట్టి, మనము బాగా ప్రసిద్ది చెందిన
వర్చువల్ LAN లేదా VLAN ను కలిగి ఉంటాము,
అనగా వర్చువల్ ప్రైవేట్ నెట్వర్క్(virtual private
networks) మొదలగునవి కలిగి ఉంటాము.
వర్చ్యులైజేషన్(virtualization) ఉంది. మరియు ఈ క్లౌడ్
కంప్యూటింగ్(cloud computing) నిర్మాణ సాంకేతికత,
క్లౌడ్(cloud) యొక్క వివిధ సర్విస్(services)
లు అందించడం కోసం ఈ లక్షణాన్ని ఉపయోగిస్తుంది.
కాబట్టి, దీనిని IaaS లేదా ఇన్ఫ్రాస్ట్రక్చర్
అస్ ఆ సర్విస్ (infrastructure as a service) గా చూసాము.
సబ్స్క్రైబర్ (subscriber) దృష్టిలో, సబ్స్క్రైబర్
(subscriber) ఏమి పొందుతాడు.
అంటే, వర్చ్యువల్ కంప్యూటర్లు(virtual
computers), నెట్వర్కు యాక్సెస్(network access), వర్చ్యువల్ స్టోరేజ్(virtual
storage), ఫైర్వాల్(firewall), నెట్వర్క్ ఇన్ఫ్రాస్ట్రక్చర్(infrastructure)
లో ఒక భాగం అయిన ఫైర్ వాల్ (firewall) కాన్ఫిగరేషన్
(configuration) సర్వీసెస్ (services), మొదలైనవి.
నేను ఒక సబ్స్క్రైబర్ (subscriber) గా , వర్చువల్
మెషీన్ (virtual machine) లేదా మెషిన్ (machines) సమితిని
ఆక్సెస్ (access) చేయగలను.
ఆపై, నేను నిర్దిష్ట స్టోరేజ్ (storage) మరియు
ఇతర (configuration) తో ప్రత్యేక మెషిన్(machine) కోరుతాను.
కానీ aది ఎక్కడ ఉందో, ఎలా కాన్ఫిగర్ (configure)
అయ్యిందో తెలియదు.
కానీ నాకు ఈ ప్రత్యేకమైన ఇంటర్ఫేస్(interface) ద్వారా
ఉండే; మెషిన్(machines) ల రకం. మన దగ్గర ప్రత్యేకమైన
నెట్వర్క్(network) తో పాటు వర్చువల్ మెషీన్
(virtual machine) కలయికను కలిగి ఉండడం సాధ్యమే, మరియు
మన ప్రయోజనం కోసం, ఒక నెట్ వర్క్(network)
ను అవస్థాపన చేయడం కూడా సాధ్యమే.
కాబట్టి, ఇదే సబ్స్క్రైబర్(subscriber) మన దగ్గర నుంచి తీసుకుని
మరియు ఎలా చెల్లించాలి, ఎలా ఉపయోగించాలి
అనేది చూస్తాం.
ప్రధానంగా , సాధారణంగా, CPU గంటకు, స్టోరేజ్
డేటా(storage data)కి GB, ఒక గంట ఆధారంగా చెల్లించవచ్చు.
ఒక నిర్దిష్ట రేట్(rate) లో వినియోగించిన
నెట్వర్క్ బ్యాండ్విడ్త్(network bandwidth), నెట్వర్క్ ఇన్ఫ్రాస్ట్రక్చర్
(network infrastructure) ఉపయోగించబడుతుంది.
ఎంత IP అడ్రెస్, అనగా ఏ రౌటెర్స్(routers) మొదలైనవి
మరియు విలువ ఆధారిత సర్వీసెస్(services).
అనగా, ఆటోమేటిక్ స్కేలింగ్(automatic scaling)
పర్యవేక్షన మొదలైనవి విలువ ఆధారిత సేవలు.
ప్రొవైడర్లు(providers) సిద్ధాంతపరంగా వర్చ్యువల్
మిషన్ల(virtual machines) సమితిని కలిగి ఉంటారు; అంటే,
నేను ఒక క్లౌడ్ సర్వీస్ ప్రొవైడర్(cloud service
provider) ని, నా వద్ద ఈ రకమైన వర్చ్యువల్
మిషన్లు(virtual machines) లు ఉన్నాయి.
మీరు వర్చ్యువల్ మిషన్(virtual machine) యొక్క
సమితి కావాలనుకుంటే, అప్పుడు నేను దానిని
ప్రొవిజన్(provision) చేస్తాను.
సాధారణంగా ఇవి వివిధ రకాలు గా ఉంటాయి.
సిద్ధాంతపరంగా, నేను ఏ వర్చ్యువల్ మిషన్(virtual
machine) కాన్ఫిగర్ (configure) చెయ్యగలిగినా, కానీ
ఆచరణాత్మక అర్ధంలో ఇది నిర్దిష్ట కాన్ఫిగర్
(configure) మొదలైనవి కలిగి ఉంటుంది.
ఐ.ఐ.టి ఖరగ్పూర్, మెగామాలా(megamala) విషయంలో మాదిరిగా
చాలా తక్కువ సామర్ధ్యం ఉన్న VM కలిగి ఉంది.
ఇక్కడ 3 రకాల వర్చ్యువల్ మిషన్(virtual machines)లు ఉన్నాయి,
వాటిలో ఒకటి IIT KGP VM లు, ఇది 4 GB RAM, 20 GB హార్డ్
డిస్క్ స్పేస్(hard disk space) మరియు ఇతర ప్రాసెసింగ్(processing)
మొదలైనవి కలిగి ఉంది. రెండవది IIT KGP లార్జ్(large),
ఇది ఇప్పటివరకు ఒక 8GB RAM కలిగి ఉంది. చివరిది
IIT KGP ఎక్స్ట్రా లార్జ్ (extra large), ఇది 60 GB RAM ను
కలిగి ఉంది; ఇప్పుడు, రిసోర్స్ (resource) లభ్యత
ఆధారంగా, వివిధ రకాల VM ల కలయిక మాత్రమే
కాక, ఏ VM కావాలనే అభ్యర్థన రకం మీద కూడా ఆధారపడి
ఉంటుంది.
స్మాల్ (small) VM కు భారీ రెక్వెస్ట్(requests) లను
కలిగి ఉన్నట్లయితే, హైయర్ (higher) VM కంటే ఆ
స్మాల్ (small) VM ను కేటాయించాలని అనుకుంటాము.
ఈ పరిగణనలు ఉంటాయి.
కాబట్టి, ఈ సందర్భంలో క్లయింట్(client) A కు
VM1 నుంచి VM2 కు యాక్సెస్(access) ఉంది. అయితే, B కు VM3
కు యాక్సెస్(access) ఉంది, ఇక్కడ క్లయింట్ C
VM4 నుంచి VM6 కు యాక్సెస్(access) ఉంటుంది.
ప్రొవైడర్లు(providers) ఇతర వినియోగదారులకు
VM7 నుంచి VMn వరకు అందిస్తారు.
కాబట్టి, అది ఒక నమూనాగా ఉండవచ్చు మరియు ఆ
పనిని కొనసాగించవచ్చు మరియు ఇవి సాధారణంగా
అలాంటివి చేయబడతాయి.
మీరు IaaS కాంపొనెంట్ స్టాక్(component stack) మరియు
నియంత్రణ పరిధిని చూస్తే.
IaaS యొక్క భాగాలు హార్డ్వేర్(hardware), ఆపరేటింగ్ సిస్టమ్(operating
system), మిడిల్వేర్(middleware) మరియు అప్లికేషన్
లేయర్(application layer) లను కలిగి ఉంటాయి.
కనుక, ఇది విలక్షణమైన విషయం.
ఆపరేటింగ్ సిస్టం(operating system), 2 పొరలుగా నిర్మిచబడినది,
మొదటిది లోపలి ప్రివిలేజ్ లేయర్ (privilege layer).
కాబట్టి, ఆపరేటింగ్ సిస్టమ్(operating system) యొక్క
ఎక్కువ కోడ్(code) ను చూస్తే వర్చువల్
మెషీన్ మానిటర్ (virtual machine monitor) లేదా VMM చే ఆక్రమించబడతాయి,
దీనిని హైపర్విజర్ (hypervisor) అని కూడా పిలుస్తారు.
గెస్ట్ ఆపరేటింగ్ సిస్టం(guest operating system)
అని పిలువబడే VM లో నడుస్తున్న ఆపరేటింగ్
సిస్టం అధిక పొరను ఆక్రమించింది.
కాబట్టి, మేము ఈ సందర్భంలో మాదిరిగానే ఉన్నామని
చూసినట్లుగా, మధ్యలో మనం చూసినట్లైతే,
బేర్ మెటల్ హార్డ్వేర్(bare metal hardware) ఉంటుంది, ఇందులో
క్లౌడ్ ప్రొవైడర్లు(cloud providers) మొత్తం నియంత్రణను
కలిగి ఉంటారు; ఆచరణాత్మకంగా, క్లౌడ్ సబ్స్క్రైబర్(cloud
subscriber) కు తక్కువ నియంత్రణ ఉంది. దీని పై, మనం
ఒక హైపర్విజర్(hypervisor) లేదా VMM లేదా వర్చ్యువల్
మిషన్ మానిటర్(virtual machine monitor) ను కలిగి ఉంటుంది.
క్లౌడ్ ప్రొవైడర్ లేదా క్లౌడ్ సబ్స్క్రైబర్(cloud
subscriber) యొక్క నిర్వాహక నియంత్రణ , ఒక VM మొదలైన
వాటి కోసం ప్రధానంగా ఈ హైపర్విజర్ (hypervisor)
కు రెక్వెస్ట్ (request) పంపవచ్చు.
ఆపై Guest OS, మిడిల్వేర్(middle ware), java మొదలైనటువంటి
ఇతర పొరలు ఉంటాయి, మెయిల్(mail), CRM మరియు
ఇతర రకాలు వంటి అప్లికేషన్(applications) లు ఉంటాయి, ఒక Iaas విషయంలో
క్లౌడ్ సబ్స్క్రైబర్(cloud subscriber) మొత్తం నియంత్రణను
కలిగి ఉంటారు.
ప్రొవైడర్(provider) కు ఏ నియంత్రణ ఉండదు
లేదా ప్రొవైడర్(provider) దేనిని నియంత్రించదు.
కనుక, ఇక్కడ ఈ విధంగా జఅరుగుతుంది.
కాబట్టి, మనము చూస్తే బయటి పొరలలో నియంత్రణ
రకం క్లౌడ్ సబ్స్క్రైబర్(cloud subscriber) లకు తరలించబడుతుంది
మరియు లోపలి పొరలలో నియంత్రణ రకం ప్రొవైడర్(provider)
వైపుకు తరలించబడతాయి.
IaaS క్లౌడ్ (cloud) లో, ప్రొవైడర్(provider) కు ఫిజికల్ హార్డ్వేర్(physical
hardware) పై పూర్తి నియంత్రణ, మరియు హైపర్విజర్
(hypervisor) పొర మీద అడ్మిస్ట్రేటివ్(administrative) నియంత్రణ ఉంటుంది.
సబ్స్క్రయిబర్ (Subscriber), గెస్ట్(guest) OS, మిడిల్వేర్(middleware)
మరియు అప్లికేషన్ లేయర్ (application layers)లను
నియంత్రిస్తుంది.
ఇవి సబ్స్క్రయిబర్ (subscriber) పై ఉంటాయి.
సబ్స్క్రయిబర్ (Subscriber) అనునది ఏ సహాయ ఆపరేటింగ్
సిస్టమ్(operating system) లోడ్ చేయుటకు ప్రొవైడర్
యొక్క యుటిలిటీ(utility) నుండి ఉచితముగా ఉపయోగించును.
అందువల్ల, ప్రొవైడర్(provider) మద్దతునిచ్చినట్లయితే,
సబ్స్క్రయిబర్ (subscriber), గెస్ట్ (guest) OS ను లోడ్
చేయవచ్చు.
సబ్స్క్రయిబర్ (subscriber) సాధారణంగా ప్రతి
VM లో గెస్ట్ ఆపరేటింగ్ సిస్టమ్(guest operating system)
యొక్క ఆపరేషన్(operations) పై పూర్తి నియంత్రణను
నిర్వహిస్తుంది.
కాబట్టి, సబ్స్క్రయిబర్ (subscriber) దీన్ని లోడ్(load)
అయినప్పుడే అది గెస్ట్(guest) OS పై మొత్తం నియంత్రణను
కలిగి ఉంటుంది, అనగా క్లౌడ్ ప్రొవైడర్(cloud
provider) నాకు కొంత లైనక్సు(Linux) OS మరియు హైపర్విజర్(hyperviser)
అందించినప్పుడు, నాకు లైనక్స్(linux)
లేదా విండోస్(windows), మొదలైనవాటిని లోడ్(load)
చేయడానికి అనుమతిస్తుంది.
కాబట్టి, నేను లైనక్స్(linux) యొక్క కొన్ని రకాలను
లోడ్ చేస్తే, దాని పై నాకు పూర్తి నియంత్రణ
ఉంటుంది.
IaaS కాంపొనెంట్ స్టాక్(component stack) మరియు ఇతర విషయం,
హైపర్విజర్ (hypervisor) ఒకటి లేదా మరిన్ని
వర్చ్యువల్ మిషన్లు (virtual machines) లేదా VM ల సంశ్లేషణకు
హార్డువేరు (hardware) లను ఉపయోగిస్తుంది.
ప్రతి VM ఒక సమర్థవంతమైన ఐసోలేటెడ్(isolated) డూప్లికేట్(duplicate)
రియల్(real) మెషీన్(machine), సబ్స్క్రయిబర్ (subscriber),
VM యాక్సెస్(access) ని రెంట్ (rent) కి తీసుకుంటుంది
,ఈ VM సబ్స్క్రయిబర్ (subscriber) కి నిర్వహించే
వాస్తవ కంప్యూటర్ హార్డ్వేర్(computer hardware)
గా కనిపిస్తుంది, ఇది ఆఫ్(off) ఆన్(on) చేయబడుతుంది,
నెట్వర్క్(network) ద్వారా పంపే కమాండ్స్(commands)
ద్వారా పెరిఫెరల్స్(peripherals) కాన్ఫిగర్ (configure) చేస్తుంది,
ఎందుకంటే సబ్స్క్రయిబర్ (subscriber) గా ప్రొవైడర్(provider)
తో ఇంటర్ఫేస్(interface) అయ్యి కమ్యూనికేట్(communicate)
అవుతుంది.
మీరు ఒక సాధారణ ఆర్కిటెక్చర్ (architecture) ని చూస్తేప.
పైన ఉన్న అనేక భాగాలలో క్లౌడ్ మేనేజర్(cloud
manager) ఒకటి. విభిన్న క్లస్టర్ మేనేజర్(cluster
managers)లు ఉన్నారు, ఇవి రెండో స్థాయిలో ఉన్న
విషయాలు మరియు దానికి దిగువన కంప్యూటర్
మేనేజర్ లేదా CM ఉంటుంది.
ఇందులో CM ప్రధానంగా హైపర్విజర్స్(hypervisor)
మరియు విభిన్న రకాలైన వర్చువల్ మెషీన్
(virtual machine) అంశాలను కలిగి ఉంది. మనము క్లౌడ్
మేనేజర్(cloud manager) మరియు డేటా ఆబ్జెక్ట్ స్టోరేజ్(data
object storage) ను కలిగి ఉన్నాము, అనగా ఇది విషయాలను
పర్యవేక్షించే ముస్టర్ డేటా బేస్(muster data base).
ఇప్పుడు లోయర్ స్థాయి వద్ద వంటి పెర్సిస్టెంట్(persistent)
లోకల్ స్టోరేజ్(local storage)ని కలిగి ఉంటుంది;
అనగా, క్లౌడ్ ప్రొవైడర్ లేనప్పుడు కూడా స్టోరేజ్
(storage) అలానే ఉంటుంది.
ఎప్పుడంటే VM లు ఉపయోగించబడకపోయినా లేదా షట్డౌన్(shut down)
అయినప్పుడు.
ఆ 3 స్థాయిల హైరార్కీ (hierarchy)లను చూస్తే, 1.
టాప్ లెవెల్(top level), దీనికి క్లౌడ్ మేనేజర్
లాంటి సెంట్రల్ కంట్రోల్ (central control) బాధ్యత ఉంటుంది.
2
మిడిల్ లెవెల్(middle level),ఇది బహుశా పెద్ద
కంప్యూటర్ క్లస్టర్(computer cluster) యొక్క నిర్వహణకు
బాధ్యత వహిస్తుంది మరియు భౌగోళికంగా
ఒక దాని నుండి మరొక దానికి దూరం ఉంటుంది.
కాబట్టి, మీరు ఈ క్లస్టర్ మేనేజర్(cluster manager) ని
చూస్తే, ఈ భారీ క్లస్టర్(cluster) లను నిర్వహిస్తుంది,
ఇది భౌగోళికంగా వ్యాప్తి చెందుతుంది మరియు
మూడవది వర్చ్యువల్ మిషన్(virtual machines) లను
సృష్టించే హోస్ట్ కంప్యూటింగ్(host computing)
వ్యవస్థను నడుపుటకు బాధ్యత వహిస్తుంది.
కాబట్టి, ఈ హోస్ట్ కంప్యూటింగ్(host computing)
వ్యవస్థను నడుపుతున్నారు, ఇక్కడ VM లు సృష్టించబడతాయి.
ఇది సాధారణంగా 3 లేయర్(layers) ల నియంత్రణ, సబ్స్క్రైబర్(subscriber)సాధారణంగా
వ్యాఖ్యానిస్తుంది.
క్వెరీస్ (queries) కి ఆన్సర్ ఇచ్చేటపుడు
టాప్(top) నుంచి డౌన్(down) కి పొరల ద్వారా ముందుకు
పంపబడతాయి.
IaaS క్లౌడ్ ఆర్కిటెక్చర్(cloud architecture) లో క్లౌడ్ మేనేజర్(cloud
manager) భౌగోళికంగా పంపిణీ చేయవచ్చు.
క్లస్టర్ మేనేజర్ లోపల, కంప్యూటర్
మేనేజర్ అధిక వేగ నెట్వర్క్ ద్వారా
అనుసంధానించబడి ఉంటుంది.
క్లస్టర్(cluster) నిర్వాహకుడిని చూస్తే, ఇవన్నీ అధిక
వేగ నెట్వర్క్(network) ద్వారా కనెక్ట్(connect)
చేయబడతాయి.
ఇప్పుడు మీరు క్లౌడ్ మేనేజర్ (cloud manager) ఆపరేషన్(operation)
చూస్తే; టాప్ (top) లో క్లౌడ్ మేనేజర్(cloud
manager), తర్వాత క్లస్టర్ మేనేజర్(cluster manager), ఆ
తర్వాత వ్యక్తిగత విషయాలు నిర్వహించే
కంప్యూటర్ మేనేజర్ (computer manager) ఉంటాయి.
మీరు క్లౌడ్ మేనేజర్ విధి చూస్తే, ఇది
క్లౌడ్(cloud) యొక్క పబ్లిక్ యాక్సెస్
పాయింట్(public access point).
కాబట్టి, ఎవరైనా క్లౌడ్ (cloud) ను పబ్లిక్
(public)లో యాక్సెస్(access) చేసినప్పుడు, సబ్స్క్రైబర్(subscriber),
అక్కౌంట్(account) ని నిర్వహించడానికి, క్లౌడ్(cloud) నుండి
రెంట్(rent) కు తీసుకున్న రిసోర్సస్ (resources) ని
నిర్వహించదానికి సైన్ (sign) చేస్తారు.
క్లౌడ్ మేనేజర్(cloud manager) సబ్స్క్రైబర్(subscriber)
ని అతెంటికెట్ (authenticate) కొరకు కొన్ని పద్దతులు
ఉంటాయి.మొదటిది అతెంటికెట్ (authenticate) విధానాలు, VM
లతో కమ్యూనికేట్ (communicate) అయ్యేటపుడు
సబ్స్క్రైబర్(subscriber) ఉపయోగించే యాక్సెస్
క్రెడెన్షియల్(access credentials) ను రూపొందించడం
లేదా ధృవీకరించడం రెండవది.
ప్రధానంగా మొత్తం వ్యవస్థ యొక్క ఫ్రంటెండ్
అయినప్పుడు, మూడవది, ఉన్నత స్థాయి రిసోర్సస్(resources)
నిర్వహణ.
సబ్స్క్రైబర్(subscriber) అభ్యర్థన కోసం క్లౌడ్
మేనేజర్(cloud manager), క్లౌడ్(cloud)లో తగినంత ఉచిత రిసోర్సస్(resources)
ని గుర్తింస్తుంది.
కాబట్టి, క్లౌడ్ మేనేజర్ మెటాడేటా(meta
data) సమాచారాన్ని నిర్వహిస్తుంది.
కాబట్టి, ఒక నిర్దిష్ట VM లేదా క్లౌడ్(cloud)
లో అందుబాటులో లేని VM ల సెట్ (set) కోసం నేను
అభ్యర్థిస్తే, క్లౌడ్ మేనేజర్(cloud manager)కి
కాల్(call) చేయాల్సి వస్తుంది.
కనుక, అది సబ్స్క్రైబర్(subscriber) ల చేత నిర్వహించబడుతుంది.
డేటా ఆబ్జెక్ట్ స్టోరేజ్ (data object storage)లేదా DOS అని
పిలువబడే ఒక విషయం ఉంది. యూజర్ క్రెడిట్
ఆపరేటింగ్ సిస్టం(user credential operating system) మొదలైన
వాటి గురించి మాట్లాడుతున్నందున DOS సాధారణంగా చందాదారుల
మెటాడేటాను నిల్వ చేస్తుంది.
సాధారణంగా DOS సర్విస్ (service) క్లౌడ్ (cloud) కి
ఒకటే ఉంటుంది.
కాబట్టి, నిర్దిష్ట DOS సర్విస్ (service) అనేది
ఒక నిర్దిష్ట క్లౌడ్(cloud) కోసం అని చెబుతున్నాం.
కాబట్టి, ఇది మన మొత్తం రిజిస్ట్రీ(registry) లేదా
క్లౌడ్(cloud) జాబితా లేదా ఒక మెటాడేటా(meta
data) సర్విస్ ని నిర్వహిస్తుంది.
అందువల్ల, మొత్తం విషయం యొక్క బైండింగ్
బ్లాక్(block), ఉచిత రిసోర్సస్ (resources) అందుబాటులో
ఉన్నయా లేదా మొదలైన వాటిని అన్నింటిని
అప్డేడ్ (update) చేయడం.
ఈ మిడిల్ లవేల్ (middle level) క్లస్టర్ మేనేజర్(cluster
manager)ని చూస్తే.
హై స్పీడ్(high speed) లోకల్ ఏరియా నెట్వర్క్(local
area network) ద్వారా అనుసంధానించబడిన కంప్యూటర్లు(computers)
సేకరణకు ఇది బాధ్యత వహిస్తుంది.
కాబట్టి, ఇది లో లెవెల్ (low level) కంప్యూటర్లను(computers)
నిర్వహిస్తుంది, క్లస్టర్ మేనేజర్(cluster
manager) ఎగువన ఉన్న క్లౌడ్ మేనేజర్(cloud manager) నుండి
రిసోర్స్(resource) కేటాయింపు ఆదేశాలు మరియు ప్రశ్నలను
పొందుతుంది.
క్లస్టర్ (cluster) లోని కంప్యూటర్ల(computers)
యొక్క రిసోర్సస్(resources) ను ఉపయోగించి కమాండ్ను
యొక్క పార్ట్ (part) లేదా మొత్తాన్ని
సంతృప్తిపరచవచ్చో లెక్కిస్తుంది.
అనగా, క్లస్టర్ మేనేజర్((cluster manager) కి రెక్వెస్ట్
(request) అందినప్పుడు, క్లస్టర్ లో రెసోర్స్(resource)వుందో,
లేదో తనిఖీ చేస్తుంది; ఇది విషయాలను సంతృప్తి
చేయగలదా మరియు అనుగుణంగా అది విషయాలకు తగిన
సిగ్నల్ను(signal) చెబుతుంది.
అలాగైతే, అది ఆమోదించవచ్చు లేదా ఆమోదించకపోవచ్చు
మొదలైనవి వుంటాయి.
క్లస్టర్ మేనేజర్(cluster manager) రెసోర్స్ (resource)లభ్యతను
గుర్తించడానికి క్లస్టర్లో(cluster)ని
కంప్యూటర్ల(computers) కోసం కంప్యూటర్ మేనేజర్(computer
manager) ని ప్రశ్నిస్తాడు, క్లౌడ్ మేనేజర్(cloud
manager) కి సందేశాలను పంపుతాడు.
అనగా, అది కంప్యూటర్ మేనేజర్(computer manager), క్లస్టర్
మేనేజర్(cluster manager) మరియు క్లౌడ్ మేనేజర్(cloud
manager) కి మధ్య మిడిల్ వేర్(middle ware) లేదా ఏజెంట్(agent)
గా పనిచేస్తుంది.
మీరు ఆపరేషన్ను(operation) చూస్తే, అక్కడ క్లౌడ్
మేనేజర్(cloud manager) కోసం దిశను నిర్దేశిస్తుంది.
మరియు ఆపై రెసోర్స్(resource) కేటాయింపు, రీ కాన్ఫిగరేషన్
(reconfiguration), రెసోర్స్(resource) డి అల్లోకేషన్(de-allocation)
మరియు ఇతర విషయాలను నిర్వహించడానికి
కంప్యూటర్ మేనేజర్ల(computer manager) ను నిర్దేశిస్తుంది.
క్లస్టర్ మేనేజర్(cluster manager) నిరంతర స్థానిక
స్టోరేజ్ (storage)కు అనుసంధానిస్తారు; క్లస్టర్ మేనేజర్(cluster
manager) పెర్సిస్టంట్ స్టోరేజ్(persistent storage)కి
అనుసంధానించబడి ఉంటుంది.
అనగా ఇది కోట్(coat) లేదా uncoated నోన్ వొలటైల్
స్టోరేజ్(non volatile storage).
నిర్దిష్ట వర్చ్యువల్ మిషన్(virtual machine), షట్డౌన్(shut
down) అయినప్పుడు, లేమి లేదా కొన్ని సమస్యలు
వస్తాయి.
సో, అది విషయాలు లోకి స్థానిక నిల్వ కలిగి.
కాబట్టి, ఈ PLS వర్చ్యువల్ మిషన్(virtual machine) కి స్టోరేజ్
(storage) వంటి పెర్సిస్టంట్ (persistent) డిస్కు(disk)ను
అందిస్తుంది.
కాబట్టి, అదే నిరంతర డిస్క్ ఉన్నట్లయితే.
కాబట్టి, మీరు తర్వాతి సమయం లాగిన్ (login) చేసినప్పుడు
డేటా(data) అందుబాటులో ఉంటుంది.
మేము క్లౌడ్ మేనేజర్(cloud manager) ఆపరేషన్(operation)
చూస్తే.
సోపానక్రమంలో అత్యల్ప స్థాయిలో, ప్రతి
కంప్యూటర్ సిస్టమ్లో రన్ (run)అయ్యే క్లౌడ్
మేనేజర్(cloud manager), సబ్స్క్రైబర్ (subscriber)కి వర్చువల్
మెషీన్ను(virtual machine) అందించడానికి, వర్చువలైజేషన్
(virtualization) ని ఉపయోగిస్తుంది.
కాబట్టి, క్లౌడ్ మేనేజర్(cloud manager) ప్రాథమికంగా
VM లను అందిస్తుంది.
ఇది బాధ్యత వహించే VM లను అందించే సబ్స్క్రైబర్
(subscriber)కి, కంప్యూటర్ మేనేజర్(computer manager) ఎన్ని
వర్చ్యువల్ మిషన్లు(virtual machines) నడుపుతున్నారో
లాంటి స్థితి సమాచారాన్ని మొదలైనవి నిర్వహిస్తుంది.
కాబట్టి, అది ఎన్ని విర్జిషియల్ మెషీన్లు(virtual
machines) నడుపుతున్నాయనేదాని స్థితి సమాచారమును
నిర్వహిస్తుంది.
దీని తో పాటు క్లౌడ్ మేనేజర్(cloud manager) వర్చ్యువల్
మిషన్ల(virtual machines) ను ప్రారంభించడానికి,
సస్పెండ్(suspend) మరియు పునఃనిర్మించటానికి
హైపర్విజర్(hypervisor) కు కమాండ్ ఇంటర్ఫేస్(interface)
ను ఉపయోగిస్తుంది.
కంప్యూటర్ మేనేజర్(computer manager) అవసరం ఉంటే అది
కూడా ఒకటే. ఇక్కడంత మనం చూసేది, వర్చువలైజేషన్
(virtualization) యొక్క ముఖ్యమైన పాత్ర.
ఎలా ఈ వర్చువలైజేషన్ (virtualization) తయారుచేస్తాం
మరియు దాని అంశాలు మొదలైనవి: వీటన్నిటి
గురించి తదుపరి స్లయిడ్లలో త్వరగా చూడటానికి
ప్రయత్నిస్తాం.
కాబట్టి, వర్చ్యులైజేషన్ (virtualization) ఒక విస్తృత
పదం, ఇది ఒక వర్చ్యువల్ మెమొరీ(virtual memory) కావచ్చు,
వర్చ్యువల్ నెట్వర్కు(virtual network) కావచ్చు, వర్చ్యువల్
స్టోరేజ్(virtual storage), మొదలైనవి కావచ్చు.
దేన్నైనా మనం వర్చ్యులైజ్ (virtualize) చేయగలిగితే
దాన్ని వర్చ్యులైజేషన్ (virtualization) అంశం అంటాం.
మా ప్రాధమికంగా వర్చ్యులైజేషన్ (virtualization) వేదిక కోసం
దృష్టి పెడుతున్నాం.
వర్చ్యులైజేషన్(virtualization) ప్రాథమికంగా, ఒక
కంప్యూటర్(computer), ఒకే హార్డ్వేర్ (hardware)
రిసోర్స్ (resources) లను ఎక్కువ ఎన్విరాన్మెంట్
(environment) లో పంచి, బహుళ కంప్యూటర్ల(computers)
యొక్క పనిని చేయడానికి అనుమతిస్తుంది.
కాబట్టి, ఇది ముఖ్యమైనది; దీని అర్ధం, నాకు
ఒక బేర్ మెటల్(bare metal) ఉంది, నేను విభిన్న
మెషిన్(machines) లను లేదా వర్చ్యువల్ మిషన్ల(virtual
machines)ను సృష్టించగలము.
కానీ బాక్ ఎండ్ (backend)లో, అదే బేర్ మెటల్(bare
metal) రన్(run) అవుతుంది.
ఇప్పుడు ఇది చాలా గమ్మత్తైనది.
మీరు ప్రత్యేక ఎన్విరాన్మెంట్ (environment) లో, మీ బేర్
మెటల్(bare metal) ను కలిగి ఉన్నాం అనుకుందాం
మరియు మీరు Windows లో ఒక మెషిన్ (machine) రన్
(run) చేస్తున్నాం, Linux లో ఒక మిషన్(machine) Guest
OS, లేదా ఇతర విషయాలు మొదలైనవి ఉపయోగించవచ్చు.
ఈ గెస్ట్ OS యొక్క ఇంస్ట్రక్షన్ సెట్
(instruction set), హార్డ్వేర్లో(hardware)ఎలా అమలవుతుందనే సమస్య
ఉంది. కాబట్టి, ఆ సమస్యలనేవి ఉన్నాయి, అప్లికేషన్
(application) సిజింగ్ (sizing) సమయాలు ఉన్నాయి.
VM కు ఎక్కువ రిసోర్సస్ (resources) అవసరం అయినప్పుడు
లేదా ఇతర రిసోర్సస్ (resources) ని విడుదల చేసినపుడు,
ఎలా నిర్వహించాలో మరియు అలా ఎలా కొనసాగించాలో
వాటికి సంబంధించి కొన్ని సమస్యలు ఉన్నాయి.
కాబట్టి, మనము హార్డువేర్(hardware) చూద్దాం.
కాబట్టి, ఇది ఒక వర్చ్యులైజేషన్(virtualization) లేకపోతే, ఒకే OS అన్ని
హార్డువేరు రిసోర్స్ (resources) లను నియంత్రిస్తుంది.
ఇది ఒక వర్చ్యులైజేషన్(virtualization) ఒకే ఫిజికల్ ప్లాట్ఫాం
(physical platform) పై బహుళ వర్చ్యువల్ కంటైనర్ల(virtual containers)ను
నడపడం సాధ్యపడుతుంది.
కాబట్టి, మనము బహుళ వర్చువల్ కంటైనర్ల(virtual
containers)ను కలిగి ఉంటాము, అవి ఒకే ఫిజికల్
ప్లాట్ఫాం (physical platform) పై అమలు చేయవచ్చు
లేదా ప్లగ్ చేయబడతాయి.
ఈ వర్చ్యులైజేషన్(virtualization)తో మనకు కొంతవరకు అనుభవము
ఉంది. అందువల్ల, వర్చ్యులైజేషన్(virtualization) ఒకే హార్డువేరు(hardware)
నందు బహుళ ఆపరేటింగ్ సిస్టమ్(operating systems) లను
మరియు యూజర్ అప్లికేషన్(user application) నడుపుటకు ఒక
మార్గం.
కాబట్టి, ఇది వర్చ్యులైజ్ (virtualize) చేయబడుతుంది
. కాబట్టి, నేను ఒకేసారి మెషిన్ పై 2 విభిన్న
ఆపరేటింగ్ సిస్టమ్ను(operating systems) కలిగి ఉండగలను.
అనగా, దీనిలో ఒక OS ని వర్చ్యులైజ్(virtualize)
చేస్తాను, కాబట్టి, విండోస్(windows) మరియు
లైనక్స్(linux) రెండింటినీ ఇంకొక వైపు అమలు
చేస్తాము.
డబుల్ బూట్(double boot) కోసం ఇది ఎలా విభిన్నంగా
ఉంటుంది?
ఒకసారి విండోస్(windows) లో చేయడం మొదలైనవి.
ఇక్కడ వర్చువలైజేషన్(virtualization) విషయంలో, ఈ వేర్వేరు
OS లేదా అన్ని OSలు ఒకేసారి లేదా ఒకే సమయంలో
కలిసి రన్(run) అవుతాయి.
OS లు ఒక దాని నుండి మరొకటి పూర్తిగా
వేరుచేయబడతాయి.
నిజమైన వర్చువలైజేషన్ (virtualization) విషయంలో ఒకదానితో
ఒకటి పూర్తిగా వేరుచేయబడతాయి.
ఇందులోకి మరో ముఖ్యమైన అంశం వర్చ్యువల్
మిషన్ మానిటర్(virtual machine monitor) లేదా హైపర్విజర్(hypervisor).
కాబట్టి, ఒక హైపర్విజర్(hyper visor) లేదా వర్చువల్
మెషీన్ మానిటర్(virtual machine monitor), గెస్ట్ OS(guest
OS)ను CPU పై నేరుగా నడుపుతుంది.
అందువల్ల నేను ఒక అతిథి OS ను కలిగి
ఉన్నాను మరియు దానిని నా అక్కౌంట్ (account)లో
చోటు చేసుకున్న లేదా సబ్స్క్రైబర్ (subscriber)
ద్వారా ఇంస్టాల్ (install) చేయబడుతుంది
లేదా అమలు చేయబడుతుంది లేదా క్లయింట్ యొక్క
అప్లికేషన్ (application)లో ఉంటుంది.
ఆపై హైపర్విజర్(hypervisor), దీన్ని అమలు చేయడానికి
లేదా ఈ గెస్ట్ OS(guest OS) ను నేరుగా హార్డ్వేర్లో(hardware),
బాక్ ఎండ్(backend) లో అమలు చేయబడుతుంది.
కాబట్టి, Guest OS, హోస్ట్ OS ఒకే ఇంస్ట్రక్షన్
సెట్(instruction set) ఉపయోగిస్తే పనిచేస్తుంది.
ఇది విభిన్న ఇంస్ట్రక్షన్ సెట్(instruction set) ఉంటే,
అప్పుడు ఒక ఇంస్ట్రక్షన్ ట్రాన్స్లేషన్ (instruction
translation) ఉపయోగిస్తాము.
పోప్ కె(popek) మరియు గోల్డ్బెర్గ్(Goldberg)
వర్ణించిన అనేక సమస్యలు ఉన్నాయి.
వర్చ్యువల్ మిషన్ ఆర్కిటెక్చర్(virtual
machine architecture) యొక్క 3 గోల్స్(goals) ఉన్నాయి: 1.
ఇక్వివలెన్స్ (equivalence), అంతర్లీన హార్డ్వేర్(hardware)
నుండి VM లను వేరు చేయరాదు.
కనుక, వర్చ్యువల్ మిషన్(virtual machine), హార్డువేరు(hardware)
మీద నడుస్తుంటే.
దానిని మనము ఇక్వివలెన్స్ (equivalence) అంటాము.2, రెసోర్స్
కొంట్రోల్ (resource control), VM కి వర్చ్యులైజ్డ్(virtualized)
రెసోర్స్ (resource) పై అసంపూర్తి నియంత్రణ
ఉండాలి.
కాబట్టి, మీరు నాకు 4 GB మెషిన్(machine), 30 GB లేదా
60 GB హార్డ్ డిస్క్(hard disk) ఇస్తే, సబ్స్క్రైబర్
(subscriber)గా వాటి పై పూర్తి నియంత్రణ ఉంటుంది.
మరియు 3.
ఎఫిషియెన్సీ (efficiency), అధిక VM ఇంస్ట్రక్షన్(instructions)లు
హైపర్విజర్(hypervisor)తో సంబంధం లేకుండా అంతర్లీన
CPU పైన నేరుగా అమలు చేయాలి.
కాబట్టి, అది మరొక విషయం.
వర్చువల్ మెషీన్(virtual machine) బోధన యొక్క అధికభాగం,
ఈ ఇతర ప్రమేయం హైపర్విజర్(hypervisor) యొక్క జోక్యం లేకుండా
నేరుగా CPU పై అమలు చేయగలగడం వలన సామర్థ్యం
పెరుగుతుంది.
అందువల్ల, మనము VM లను అనుకరించటానికి
అనుమతించే ప్రదేశంలో వర్చ్యువల్ మిషన్
మానిటర్(virtual machine monitor) లేదా హైపర్విజర్(hypervisor)
వున్నప్పుడు, వీటిని పరిశీలించవలసిన
అంశాలు.
అదే వర్క్ (work)లో ఈ పొపెక్(popek) మరియు
గోల్డ్బెర్గ్(Goldberg) ను వివరించారు మరియు
ఈ లక్షణాలను జరిగేలా అనుమతించే CPU ల ఇంస్ట్రక్షన్(instructions)ల
యొక్క అవసరాన్ని అందించిన ఒక అధికారిక
రుజువుని కూడా ఇస్తారు.
నిజంగా వర్చువలైజేషన్(virtualization) IaaS స్థాయిలో జరిగేలా
చేయాలంటే, ప్రధానంగా , ఈ ఇంస్ట్రక్షన్(instructions)
3 విభిన్న విషయాలగా వర్గీకరిస్తుంది.
అందులో ఒకటి ప్రివిలైజ్ద(privileged) ఇంస్ట్రక్షన్ (instruction),
ఇది యూసర్(user) మోడ్ (mode)లో ఎక్జిక్యూట్
(execute) చేసినప్పుడు, ట్రాప్ (trap) జరగవచ్చు.
ఇక్కడ సెన్సిటివ్ ఇన్స్ట్రక్షన్(sensitive
instruction) ఉంది, ఇది అంతర్లీన రెసోర్స్ (resources)ను
మారుస్తుంది, అది IO చేస్తోంది లేదా
గెస్ట్ (guest) OS, బార్ (bare metal) లో నడపబడుతున్న
వాస్తవాన్ని మారుస్తుంది; మొదటిది IO లేదా పేజ్
టేబుల్స్(page tables) లను మార్చడం లేదా ప్రస్తుత
అధికార స్థాయిపై సమాచార సూచనలను గమనించడం.
మీరు మీ ప్రాథమిక ఆర్కిటెక్చర్ (architecture)
అంశాలను గుర్థిన్చినట్లైతే.
మనము వివిధ స్థాయి లో ఆపరేషన్ (operations)
ను కలిగి ఉన్నాము, అవి లెవెల్(level) 0,లెవెల్
(level) 1 మొదలైన వేర్వేరు స్థాయి కార్యకలాపాలు.
మరింత తక్కువ లెవెల్ (level) వెళ్ళేకొద్ది,
బేర్ మెటల్(tare metal)కి మరింత దగ్గరగా వెళ్తాము.
ఇది అన్నిటిని నిర్వహించే వర్చువలైజేషన్(virtualization)
పై ఆధారపడి ఉంటుంది.
మరింత పై లెవెల్ (level) వెళ్ళేకొద్ది
మరింత లాటెన్సి (latency) వస్తుంది, మరియు
మరింత అనువాదం అవసరం అవుతుంది.
కాబట్టి, మనము ఏ లెవెల్ (level) ఆపరేషన్ (operations)లు
చేయాలనే విషయాన్ని పరిశీలిద్దాం; ప్రత్యేకంగా
మనము IaaS సంభందిత ఆపరేషన్ (operations) లు చేస్తున్నప్పుడు.
సెన్సిటివ్ (sensitive) ఇంస్ట్రక్షన్(instructions)
ల యొక్క మొదటి క్లాస్ (class) ని కంట్రోల్ సెన్సిటివ్
(control sensitive) అని మరియు తర్వాతి క్లాస్ (class)
ని బెహెవీర్(behavior) సెన్సిటివ్ (sensitive)
అని అంటాము.
Popek మరియు గోల్డ్బెర్గ్(Goldberg) ఏమి చెబుతుందంటే,
ఈ 3 ఉపయోగపడే ప్రాపర్టీస్(properties) ల తో విర్చువల్ మెషిన్
(virtual machine) రన్(run) చేస్తే సెన్సిటివ్ ఇంస్ట్రక్షన్
(sensitive instructions)లు , ప్రివిలైజ్ద(privileged) ఇంస్ట్రక్షన్ (instructions)
లకు సుబ్సెట్ (subset) గా ఉంటాయి.
వారి పనిలో వీటన్నిటిని చూపిస్థాయి, ఈ రకమైన
విషయాలు నిజమైనవి మరియు నిజమైన విర్చువల్
మెషిన్ (virtual machine) ని గుర్తించగలము.
ఇదే విషయం లేదా మనం చర్చించే ఏవైనా.
ఈ వర్చువల్ మెషిన్ మానిటర్ల (virtual machine
monitors )పై ఈ VM లు మరియు ఈ హార్డువేరు(hardware)
రన్(run) అవుతుంటాయి.
మరియు ఈ వేర్వేరు VM లను అనుకరించటానికి
ఇది అనుమతిస్తుంది.
కాబట్టి, ఇది మీదే కావచ్చు.
కొన్ని చోట్ల ఏదైనా గెస్ట్(guest) OS, VM పై రన్
(run) అవుతుంటుంది.
కన్వర్ట్ (convert) చేయవలసిన ఇంస్ట్రక్షన్ (instruction)ల
సమితి ఈ హార్డ్వేర్కు (hardware) అర్ధం చేసుకోగలగాలి.
కాబట్టి, అది మన బాటమ్ లైన్(bottom line).
మొత్తం VMM మొత్తం అబ్స్త్రాక్సన్
(abstraction) ను కలిగివుందా లేదా ఏదో ఒక విధమైన
ఒవెర్లప్పింగ్(overlapping) ఉందా లేదా అనేది
దానిపై ఇంప్లిమెంటేషన్(implementation) పై ఆధారపడి ఉంటుంది.
కాబట్టి, వర్చువలైజేషన్(virtualization) సాధారణ విధానాలకు
సమీపంలోని విధానాలను పరిశీలిస్తే.
మీరు ఈ వర్చువలైజేషన్(virtualization) యొక్క పరిణామమును
చూసినట్లయితే, మనము మొదటిది ఫస్ట్ జెనెరేషన్(first
generation) లేదా ఫుల్ వర్చువలైజేషన్(full virtualization), దీనినే బైనరీ
రీరైటింగ్(binary rewriting) అంటాము.
కాబట్టి, ఇది సాఫ్ట్వేర్(software) ఆధారిత అంశం, VMware మరియు
మైక్రోసాఫ్ట్(Microsoft) దీనికి మద్దతిస్తుంది.
ఏ వర్చ్యువల్ మిషన్లు(virtual machines), డైనమిక్ ట్రాన్స్లేటర్ను
(dynamic translator) సృష్టించినా, అండర్ లైనింగ్ హార్డువేరుకు
రీరైట్(rewrite) చేస్తాయి.
సెకండ్ జెనెరేషన్(second generation) లో: వర్చువలైజేషన్(virtualization)
లేదా పరా వర్చురైజేషన్(para virtualization), కొ ఓపెరటివ్
(cooperative) వర్చువలైజేషన్(virtualization).
ఇది అతిథి(guest) OS లేదా మోడిఫెడ్ గెస్ట్(modified
guest),VMware మరియు xen ల కొ ఓపెరటివ్ (cooperative) వర్చువలైజేషన్(virtualization).
కాబట్టి, మీరు ఇక్కడ చూస్తే ప్రాథమికంగా
ఇది VM లోకి కొంచెం చొచ్చుకొచ్చింది;
అంటే, అంశాలపై సవరించబడింది.
ఒక మూడవ జనరేషన్(generation) లేదా సిలికాన్ ఆధారిత
అంశం, హార్డ్వేర్(hardware) సహాయంతో వర్చువలైజేషన్(virtualization)
వర్చ్యులైజేషన్(virtualization) అవగాహన హార్డ్వేర్
ప్లాట్ఫారమ్లో(hardware platform) లో, ఆన్ మోడిఫీడ్
గెస్ట్ (un modified guest), VMware మరియు xen ఉంటాయి, ఇప్పుడు
మీ హార్డ్వేర్ ప్లాట్ఫారమ్(hardware platform)కు వర్చువలైజేషన్(virtualization)
తెలుసు.
కాబట్టి, ఇది హార్డ్వేర్(hardware) అస్సిస్టెడ్ (assisted)
వర్చువలైజేషన్(virtualization).
ఈ సందర్భాలలో ఈ హార్డ్వేర్ ప్లాట్ఫారమ్లో(hardware
platform) లకు ఈ వర్చువలైజేషన్(virtualization) గురించి తెలియదు.
ఈ మీ హైపర్విజర్(hypervisor) చేత ఏమి జరిగినా?
ఫుల్ వర్చువలైజేషన్(full virtualization) లో వివిధ అంశాలు
ఉన్నాయి, ఫస్ట్ జెనెరేషన్(first generation) ఫస్ట్ జెనెరేషన్(first
generation) x86/x64 సర్వర్ ఫుల్ వర్చువలైజేషన్(full
virtualization)ను అందిస్తుంది.
సోర్స్ కోడ్(source code) యొక్క డైనమిక్ బైనరీ
ట్రాన్స్లేషన్(dynamic binary translation), మనము చూసినట్లుగా
అన్ని హార్డ్వేర్(hard wares) లు CPU తో సహా ఎమ్యులేటెడ్(emulated)
అయ్యి ఉంటాయి.
2 ప్రముఖ ఓపెన్ సోర్స్(open source) ఎమెల్యూటర్లు
(emulators) ఉన్నాయి, వాటిలో ఒకటి చాలామందికి
తెలిసిన QEMU మరియు రెండవది Bochs . ఇవి రెండు
ఓపెన్ సోర్స్(open source) ను మార్చే ప్రముఖ
ఎమెల్యూటర్లు (emulators).
పూర్తి వర్చువలైజేషన్(virtualization), ఎమ్యులేషన్ లేయర్
(emulation layer) యొక్క ప్రయోజనాలు ఉన్నాయి.
మొత్తం VM పోర్టబిలిటీ(portability), నేను VM ను ఒకదాని
నుండి మరొకదానిలో ఉంచగలము.
కాబట్టి, మొత్తం పోర్టబిలిటీని(portability)
ఉపయోగిస్తాము, ఎందుకంటే VMM మాత్రమే, మనకు అర్థం
అవుతుంది.
ఈ హార్డ్వేర్ ఎమ్యులేషన్స్ పర్ఫార్మన్స్ (hardware
emulation performance) ధరతో పాటు వస్తుంది.
ఇది ఇందులోని ఒక లోపం.
మీరు ట్రడిషనల్(traditional) x86 ఆర్కిటెక్చర్(architecture)
లో హార్డువేర్ పర్ఫార్మన్స్(hardware performance) ధరను అనుకరించాలనుకున్నప్పుడు,
OS కెర్నెల్(kernel) లు ప్రత్యేక హక్కు ప్రివిలేజ్
రింగ్(privilege ring)0 లో రన్(run) అవుతుందని అనుకుంటున్నాం.
ఇప్పుడు మీరు వాటిని అధిక లెవెల్ (level) లో
అమలు చేయాలనుకుంటే, ఎక్కువ లాటెన్సి(latency)
ఉండాలి మరియు ఇతర విషయాలను కూడా పరిశీలించాలి.
కాబట్టి, మనం దాని కోసం పే (pay) చెయ్యాల్సిన
అవసరం ఉంది లేదా పర్ఫార్మన్స్ (performance)
ధర మనకు అవసరం.
పారా వర్చురైజేషన్(para virtualization) విషయంలో, గెస్ట్(guest)
OS సవరించబడింది మరియు రింగ్(ring) 1 లేదా రింగ్(ring)
3 వద్ద కెర్నల్(kernel) లెవెల్ (level) ఆపరేటింగ్
సిస్టమ్(operating system) ను అమలు చేస్తుంది.
ఇది అధిక లెవెల్ (level) గెస్ట్(guest) గా ఉంటుంది,
ఇది ప్రివిలేజ్ ఇంస్ట్రక్షన్ (privilege instruction) ను ఎలా ప్రాసెస్(process)
చేయాలో తెలుసుకోగలదు.
VMM కు అనువదించబడిన ప్రివిలేజ్ (privilege)
ఇంస్ట్రక్షన్ (instruction) ఇకపై అవసరం లేదు.
గెస్ట్(guest) నిర్వహణ వ్యవస్థలు ప్రత్యేక
API ను VMM తో కమ్యూనికేట్(communicate) అవడానికి ఉపయోగిస్తాయి.
కాబట్టి, ఇది పారా; దీని అర్థం, మీ VMM,
కొన్ని రకాలైన VM లను ఉపయోగించడానికి
చొచ్చుకుపోతుంది.
కనుక, ఇప్పుడు అది పూర్తి అనువాదం కాదు,
కానీ ఒక పారా వర్చురైజేషన్(para virtualization) పర్ఫార్మన్స్
(performance) పెరుగుతుంది మరియు ఈ విషయం బాగా
ప్రజాదరణ పొందుతోంది.
పారా వర్చురైజేషన్(para virtualization) విషయంలో, OS
కెర్నెల్(kernel)ను రి కంపైల్(recompile) చేయాల్సిన
అవసరము ఉంది, దీనిని ఉపయోగించాలంటే, పారా
వర్చ్యులైజ్డ్(para virtualized) డ్రైవర్(drivers)ల
యొక్క ఇన్స్టలేషన్ (installation) అవసరం.
ఇది, గెస్ట్(guest) OS లెవేల్(level) లో జాగ్రత్తలు తీసుకుంటుంది.
మూడవది, హార్డ్వేర్ అస్సిస్టెడ్ వర్చురైజేషన్(hardware
assisted virtualization), గెస్ట్(guest) OS రింగ్(ring) 0 లో రన్
(run) అవుతుంది.
VMM, ఇంటెల్ VT లేదా AMD V లలో ఉన్నట్లుగా
ప్రాసెసర్ ఎక్స్టెంషన్స్ (processor extensions) లను ఉపయోగిస్తుంది
మరియు గెస్ట్ (guest) లో ఉన్న ప్రివిలైజెడ్
(privileged) ఆపరేషన్ (operations) లను ఇన్ర్సెప్ట్
(intercept) చేస్తుంది.
హార్డువేర్(hardware) సహాయంతో వర్చువలైజేషన్(virtualization)
అనేది, ఒక VMM ను వ్రాసేటప్పుడు జరిగే అనేక సమస్యలను
తొలగిస్తుంది, అది ఒక పెద్ద సవాలు.
ఇది హార్డ్వేర్ అసిస్టెంట్(hardware assistant); అనగా, మీరు నేరుగా
పొందగలిగితే అది పూర్తిగా కంపైల్
(compile) అయి ఉంటుంది.
ఇలా చేయడం వల్ల, మీరు VM ల యొక్క పోర్టబిలిటి(portability)ని
కోల్పోతారు, ఇది గమ్మత్తైన సమస్యగా
మారుతుంది, ఎందుకంటే హార్డ్వేర్(hardware)ని
అర్థం చేసుకునే మెషిన్ (machine)కి మీరు మైగ్రేట్(migrate)
అవ్వాలి.ఉపయోగం, అది అన్మోడిఫైడ్(unmodified)
OS ని రన్(run) చేయడానికి అనుమతిస్తుంది, మీరు
OS లు మార్చల్సిన అవసరం లేదు; లోపం, స్పీడ్
(speed) మరియు ఫ్లెక్సిబిలిటీ (flexibility) ల సమస్య ఉంది.
మైగ్రేషన్(migration) జరిగినప్పుడు మీరు ఫ్లెక్సిబిలిటీ
(flexibility) కోల్పోతారు మరియు స్పీడ్ (speed),
మైగ్రేషన్(migration) పై ఆధారపడి ఉంటుంది.
మనం నెట్ వర్క్ వర్చువలైజేషన్(virtualization) యొక్క కొన్ని అంశాలపై
మనము చర్చించుకుందాం.
ఇప్పటి వరకు మనము హార్డువేర్(hardware) లెవెల్
(level) లో చూసాము, ఇప్పుడు మనం నెట్వర్కు(network)
లెవెల్ (level) లో చూద్దాం; అంటే, ఇచ్చిన నెట్వర్క్(network)లోని
ఒక వర్చ్యువల్ నెట్ వర్క్(virtual network) పై నెట్
వర్క్(network) ను అనుకరించాల్సిన అవసరం ఉంది.
నెట్వర్క్ టెక్నాలజీ(network technology)లో మనం చూసే విలక్షణ
విధానాలు అంటే ఐపి బేస్(IP base) లేదా ఎటిఎమ్
బేస్(ATM base) లేయర్ (layer).
వర్చ్యులైజేషన్(virtualization) యొక్క ఏ లేయర్(layer)
లో ఆర్చిటెక్చురల్ డొమైన్(architectural domain) ఉంటుంది,దీనిలో
నెట్వర్క్(network) వనరుల యాజమాన్యాలు, స్పానింగ్
(spawning) నెట్వర్క్(network)లు ఉంటాయి, వర్చ్యులైజేషన్
లెవెల్ (virtualization level) లో, నోడ్ లెవెల్ (node
level) లేదా ఫుల్ వర్చ్యులైజేషన్(full virtualization) వంటివి ఉన్నాయి.
మనం ఈ నెట్వర్క్ కలిగి ఉన్నాం అనుకుందాం.
అప్పుడు మనం ఇలాంటి నెట్వర్క్(network) ను
ఎమ్యులెట్(emulate)చేస్తాం, కనుక, ఇది నా బేస్
నెట్వర్క్(base network).
మనము 2 రకాల వర్చ్యువల్ నెట్వర్కు(virtual networks)
లను దీని పైన కలిగివున్నాము.
ఒక వర్చువల్ నెట్వర్కు(virtual network)ను మనము ఎమ్యులెట్(emulate)
చేశాము, వాస్తవంగా ఎందుకు మనము విర్చువలైజ్
(virtualize) కి వెళ్ళాలి అంటే మన స్వంత నెట్వర్కింగ్
పారాడిగ్మ్లో(networking paradigm) ఇంటర్నెట్ స్తంభించడం
మాత్రమే కాకుండా, స్పేస్ (space) ఎక్కువ
ఉండదు.
ఒన్ సైజ్ ఫిట్స్ అల్ (one-size-fits-all) ఆర్కిటెక్చర్
(architecture) ని తీసుకుని రావడం చాలా కష్టం.
మనము నెట్వర్క్ కాన్ఫిగరేషన్(network configuration) ని కలిగి ఉంటాము
మరియు ప్రతిఒక్కరికీ సరిపోతుంది.
ఎందుకు మనం వివిధ సినారియో (scenarios) లకు
అన్నీ క్రియేట్ (create) చేయడానికి బదులుగా
అన్నిటికి సరిపోయేవిధంగా ఒకే రకం క్రియేట్
(create) చేయకూడదు.
ఇదే మనం చేయాలనుకుంటున్నాం.
కాబట్టి, భవిష్యత్ నెట్వర్క్ ఆర్కిటెక్చర్ల(network
architectures) మరియు ప్రోటోకాల్లు(protocols) కోసం టెస్ట్ బెడ్
(test bed)లు ఉన్నాయి.
కనుక, మనము ఒక విధమైన వర్చ్యులైజ్ నెట్వర్క్(virtualize
network) కలిగి ఉంటాము.
మరియు ఇది అకస్మాత్తుగా ఇందులోకి రాలేదు,
ఇది ఇప్పటికే ఒక వర్చువల్ ప్రైవేట్
నెట్వర్క్(virtual private network) , ప్రోగ్రామబుల్
నెట్వర్క్(programmable networks), మరియు ఓవర్లే నెట్వర్క్లు(overlay
networks) మొదలైనవి ఇప్పటికే చాలా ఉన్నాయి.
ఇది వాటిపై ఎమ్యులేట్ చేయబడుతోంది.
మనము ఇక్కడ చూసినట్లైతే, వివిధ అంశాలు,అనగా
బిజినెస్ మాడెల్ (business model),బిజినెస్
ఆర్కిటెక్చర్ (business architecture), డిజైన్ ప్రిన్సిపుల్స్(design
principles) మరియు డిజైన్ గోల్స్ (design goals) ఉన్నాయి.
మరియు ఇన్ఫ్రాస్ట్రక్చర్ ప్రొవైడర్స్(infrastructure
providers), సర్వీస్ ప్రొవైడర్(service providers), ఎండ్ యుసెర్స్
(end users), మరియు బ్రోకర్లు(brokers) వంటి వివిధ అంశాలు
ఉన్నాయి.
ఇవి వేర్వేరు ప్లాయెర్స్ (players) మరియు వారి మధ్య
చాలా క్లిష్టమైన సంబంధం ఉంటుంది.
మరియు బిజినెస్ మాడెల్ (business model), ఈ నెట్వర్క్
వర్చువలైజేషన్(network virtualization) కు మాత్రమే
సరిపోదు, అది వర్చువలైజేషన్(virtualization) యొక్క ఇతర అంశాలకి
కూడా సరిపోతుంది .
కాబట్టి, నేను ఆ ఇన్ఫ్రాస్ట్రక్చర్ ప్రొవైడర్(infrastructure
provider)ని కలిగి ఉంటే, అప్పుడు నేను ఒక
సర్వీస్ ప్రొవైడర్(service provider) 1 ను కలిగి ఉండి,
ఒక విధమైన వర్చ్యులైజ్ నెట్వర్క్(virtualize network)
ను కలిగి ఉంటాను.
దీని నుండి ఎమ్యులెట్(emulate) చేసినవి, కొన్ని
నెట్వర్క్(network)లను ఆక్టివేట్(activate) చెయ్యడం
మదలైనవి.
మనము ఇతర రకాలైన సర్వీస్ ప్రొవైడర్(service
provider) 2, SP2 ఇతర రకాలైన నెట్వర్క్లు(networks)లను
కూడా ఎమ్యులెట్(emulate) చేయడం, కనుక, నేను
ఒక ప్రాథమిక అంతర్లీన నెట్వర్క్(network) లో
వివిధ రకాల నెట్వర్క్(networks) లను ఎమ్యులెట్(emulate)
చేస్తుంది.
కాబట్టి, మనము వివిధ రకాల నెట్వర్క్లు(networks)లను
ఏర్పరచవచ్చు.
కాబట్టి, ఇవి చాలా ప్రజాదరణ పొందాయి.
సర్వర్లు(servers) మాత్రమే కలిగి వుండకుండా
భౌగోళిక స్పేస్(space) అంతటా ఒక నిర్దిష్ట
పరీక్ష నిర్వహించాలని అనుకుంటాను.
కాబట్టి, నేను ఈ సర్వర్లను తీసుకురావడం మాత్రమే
కాకుండా నేను ఒక నిర్దిష్ట నెట్వర్క్
ఇన్ఫ్రాస్ట్రక్చర్(network infrastructure) కావాలి అనుకుంటాను.
ఇలా చెయ్యాలి అంటే అప్పుడు IASS స్థాయి
లేదా సర్వర్ స్థాయి వర్చువలైజేషన్ మాత్రమే
ఉంటే సరిపోదు, నెట్వర్క్ లెవెల్ వర్చువలైజేషన్(
virtualization) కూడా కావాలి మరియు ఈ మొత్తాన్ని
నేను ఒక వాస్తవిక ఐపి ఇన్ఫ్రాస్ట్రక్చర్
స్థానంగా పొందగలగాలి.
కాబట్టి, మా చర్చలు మా తదుపరి ఉపన్యాసాలలో
మేము కొనసాగిస్తాము.
ధన్యవాదాలు.
