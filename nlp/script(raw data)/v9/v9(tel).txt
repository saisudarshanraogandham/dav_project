కొనసాగిస్తాము.
కాబట్టి, చివరి ఉపన్యాసంను మీరు గుర్తుపెట్టినట్లయితే,
మనము XML బేసిక్స్(basics) గురించి మాట్లాడుతున్నాము,
మనము ఏమినేర్చుకున్నాం అంటే, ఈ XML డిస్ట్రిబ్యూటెడ్
సిస్టమ్(distributed system) లోని వివిధ ఇంటెరోపేరేట్(interoperate)
సిస్టమ్ (systems)లు లేదా కొ ఓపెరటివ్ (cooperative)
సిస్టమ్(systems) ల మధ్య ఇంటెరోపేరట్ (interoperate)
చేయటానికి ఎలా అనుమతిస్తుంది అని. మరియు ఇది క్లౌడ్
కంప్యూటింగ్(cloud computing)ని ప్రత్యేకించి SaaS
క్లౌడ్(cloud)ని లేదా సాఫ్ట్వేర్ అస్ ఆ
సర్విస్(software as a service) రకమైన క్లౌడ్(cloud)
కు ఎలా ప్రధాన వెన్నెముక లా ఉంటుంది.
మనము ఇంకా DTD మరియు XML స్కీమ(schema) XSD గురించి
చర్చించాము.
నేడు మనము XML యొక్క ఈ ప్రాథమిక అంశాలపై
చర్చను కొనసాగిస్తాము.
మనము XML స్కీమా(schema) గురించి ఏమి చర్చించామో
గుర్తుచేసుకున్నట్లైతే.
ఇది ప్రధానంగా XML యొక్క నిర్మాణాన్ని
నిర్వచిస్తుంది.
IIT Kharagpur లో ఒక నిర్దిష్ట బ్యాచ్ (batch)లోని ఒక
స్టూడెంట్ డేటా(student data) ని XML లో ఉంచడం, ఇది
భారీ పరిమాణం లో ఉంటుంది.
ఇది మా ప్లేస్మెంట్(placement) విభాగంలో లేదా మా
బ్యాంక్ అక్కౌంట్ (bank account) విభాగంలో ఉంటుంది.
వారు ఈ డేటాలో కొంత భాగాన్ని ఎక్ష్టెర్నల్
ఏజెన్సీ(external agency)లతో భాగస్వామ్యం చేయాలనుకుంటారు.
దదీనికి ఒక పరిష్కారం స్కీమా(schema)లో కొన్ని
భాగాలను పంచడం.
మరియు బాహ్య ఏజన్సీ(agency)లతో ఉన్న అంశాలలో భాగమని
చెప్పే ఒక మార్గం, లేదా వేరొక విధంగా
మీ సంస్థలోని డాటా (data) ని ఇతర సంస్థ తో
పంచాలనుకోవడం.
అందువల్ల, ముందుగా అక్కడ ఉన్న డాటా
కి ఏ స్కీమా(schema) అవసరం ఉంటుందో గుర్తుంచాలి.
కాబట్టి, వివిధ రిపోజిటరీ(repository)ల మధ్య ఇంటెరోపేరబిలిటీ(interoperability)
లో సహాయపడే సమాచార మార్పిడికి XML స్కీమా(schema)
కీలక పాత్ర పోషిస్తుంది.
కొత్త వివరణ, స్కీమ(schema) అనేది XML యొక్క వ్యాలిడేషన్
రూల్(validation rule) ను పేర్కొనడానికి 2001 లో వచ్చిన క్రొత్త
వివరణ.
మనం చూడగలిగినవి ఏ XML పార్సర్(parser)ని
మొదట ఇది సింటాక్తీకల్లి(syntactically) సరియైనదో లేదో, లేదా
వెల్ ఫోర్మ్ద్(well formed) ఆ కాదా పరిశీలించాలీ.
రెండవది, స్కీమా(schema) విషయంలో డాటా(data) వాలీడ్(valid)
అవుతుందా అని చెప్పుకోవాలంటే అది స్కీమ(schema)తో తనిఖీ
చేస్తుంది.
కాబట్టి, దీనిని మనం వాలీడ్(valid) అయ్యే
XML డాక్యుమెంట్(document) అంటాము.
మీరు చూడవచ్చు కొన్ని స్పెక్(spec) మరియు ఉత్తమ
ఆచరణలో W3 వంటివి ఉన్నాయి.ఇది ప్యూర్(pure) XML, ఇలా ఉండాలంటే
XML స్కీమా(schema) ని XML లో రాయాలి.
ఈ స్కీమాస్(schemas) మరింత శక్తివంతమైనవి మరియు
DTD లు ఇంటీజీర్ (integer) రకం, తేదీ, రియల్ (real)
రకం మొదలైనవి మరియు ఇతర పరామేటెర్స్(parameters)
ను వాటిని పేర్కొంటాయి.
వారు తరచూ టైప్ వాలిడేషన్ (type validation) కోసం లేదా
XML బేస్(base) నమూనాలను డేటా బేస్ స్కీమాస్(database
schemas)కు సంబంధించిన అన్ని రకాలుగా ఉపయోగిస్తున్నారు.
మనకు స్కీమా(schema) తెలిస్తే డేటాబేస్(database) ను
క్రియేట్(create) చెయ్యొచ్చు మరియు ఆ తర్వాత ఈ
XML డేటా(data)ను ఈ డేటాబేస్(database) కు లేదా ఇతర మార్గానికి
పంపుతాము, అయితే, మనము ఎనిటీటీస్ (entities)
ని డిక్లేర్ (declare) చేయలేము; ఇవి DTD లో
మాత్రమే చేయవచ్చు.
కాబట్టి, ఎంటిటీ(entities)లలో దీనిని నిర్వచించలేము.
మన డిటిడి(DTD) లు ఆ స్కీమా(schema) ఎలా సమానం
అవుతాయో ఈ స్లయిడ్ (slide) చూపిస్తుంది.
మీరు మొదటి తరగతి అంటే XML బేసిక్స్(basics)
లో గుర్తు పెట్టుకున్నట్లయితే చివరగా మనం చూసిన
డిటిడి(DTD) మాదిరిగానే ఉంటుంది.
అదే విషయం ఇప్పుడు ఒక స్కీమా(schema)గా సూచించబడుతుంది.
కాబట్టి, మనము XML డాక్యుమెంట్(document) లో ఇంకా ఏమి చేస్తున్నామో
చూద్దాం.
మనము ఈ స్కీమా(schema)ను నిర్వహించగలము అదే
విధంగా XML డేటా(data)ని సరిగా నిర్వహించగలము.
XML యొక్క మరో ముఖ్యమైన అంశం XML నేమ్ స్పేస్
(name space); XM యూసర్ డిఫైన్డ్ డాటా (user defined data)ను అనుమతిస్తుంది
ఇది చాలా ముఖ్యమైన అంశం. కాబట్టి, మనం
ఏ విధమైన నిర్వచనం ఉందో మరియు ఏం నేమ్
స్పేస్(name space) కావాలి అనేది జాగ్రత్తగా
చూసుకోవాలి.
మీకు చివరి చర్చ గుర్తు ఉంటే మేము
ఒక ఎంటిటీ కాల్ టేబల్ (entity call table) లేదా ఎలిమెంట్
కాల్ టేబుల్(element call element) డెఫినే (define) చేస్తే,
ఇది టేబల్ (table) , ఏ రకమైన టేబల్ (table) అనేది పేర్కొనాలి.
మనము ఒక టేబుల్(table) ను కలిగి ఉన్నట్లుగా
మనం చెప్పుకున్నాం, ఆ ఫర్నిచర్(furniture) లేదా
టేబుల్(table) అనేది ఒక వర్డ్ ప్రాసెసర్(word
processor) లేదా స్ప్రెడ్ షీట్ (spread sheet) నుండి
కావచ్చు, దీని ఎలా చెప్పొచ్చు
అంటే, ఫర్నిచర్(furniture) రకానికి చెందిన ఒక
టేబల్(table) మరియు దాని డెఫినిషన్ (definition) ఒక
విధం గా ఉంటుంది, వర్డ్ ప్రాసెసింగ్(word
processing) రకానికి చెందిన టేబల్ (table) మరియు దాని
డెఫినిషన్ (definition) మరొక విధంగా ఉంటుంది.
దీని అర్థం, నేను దీనిని ఎక్కడ నిర్వచించాను,
నేమ్ స్పేస్(namespace) లో నిర్వచించాలి.
నేమ్ స్పేస్(namespace) ఏ ఎలిమెంట్ (element) ఉంది
, ఏ విధమైన డీలింగ్ (dealings) లు, మోడైలన వాటి
గురిచి చెబుతుంది.
XML పేర్ల కోసం వేర్వేరు స్పేస్ (spaces) లను గుర్తించడం,
అనగా ఎలిమెంట్స్ (elements) మరియు వాటి నేమ్(names)
లు, కోసం ఇది ఒక పద్ధతి.
ఇది వేర్వేరు భాషా మాండలికాలను గుర్తించే
ఒక మార్గం, నిర్దిష్ట సెమాంటిక్స్(semantics)
మరియు ప్రాసెసింగ్(processing) అర్ధాలను కలిగి ఉన్న
పేర్లను కలిగి ఉంటుంది.
కీ(key) అనేది ఒక లాంగ్వేజ్(language), ఒక నిర్దిష్ట సెక్యూరిటి
కీ(security key) లాంటిది, మనము టేబల్ (table) గురించి
మాట్లాడుతున్నప్పుడు, మరొక లాంగ్వేజ్(language)
లో బహుశా ఒక డేటాబేస్ కీ (database key) అంటారు.
కాబట్టి, కీ(key) అనేది బహుశా ఒక విధమైన
సెక్యూరిటి కీ(security key) మరియు మరికొన్ని
విషయాల్లో మనము వెతుకుతున్న కీ(key) డేటాబేస్(database)
సంబంధిత కీ(key) అయి ఉండవచ్చు.
ఈ రెండు కీ(keys)లు డేటాబేస్ స్కీమ(database schema) నుండి
ఒక డేటాబేస్ నేమ్ స్పేస్(database name space) మరియు
మరొకటి ఈ సెక్యూరిటి నేమ్ (security name) కోసం
స్పేస్(space), నిర్వచించాల్సిన అవసరం ఉంది. కాబట్టి,
ఇది ఒక ప్రత్యేక XMLNS ఉపయోగిస్తుంది,
XML నేమ్ (name) అంటే ఈ నేమ్ స్పేస్ (name space)ని నిర్వచించడానికి
కావలసిన XML నేమ్ స్పేస్ అట్రిబ్యూత్(attribute).
నేమ్ స్పేస్(namespace) ఒక URL స్ట్రింగ్(string)
లాగా ఇవ్వబడుతుంది, కానీ URL దేన్ని రిఫర్
(refer) చేయదు, ఏదైనా ఉండవచ్చు.
కాబట్టి, ఇది దేన్ని సూచించలేదు.
కాబట్టి, నేమ్ స్పేస్ (namespace) , లాంగ్వేజ్
(language) డైలాగ్ల(dialogues) యొక్క మిశ్రమం.
ఈ విధంగా ఉంటే, నేమ్ స్పేస్ (namespace) ఇంతకంటే
సులభతరం చేయగలదా, నాకు రెండు కీ(keys)లు
కావాలి.
డేటాబేస్ కీ(database keys)ల నుండి నేను డేటాబేస్(database)
అన్లాక్(unlock) చేయడానికి సీక్రెట్ కీ(secret key)ని
ఉపయోగిస్తాను, ఆపై యూజర్ డేటాబేస్ కీ(user
database key) ని ఆక్సెస్ (access) చేయడానికి ఉపయోగిస్తాము.
మనము రెండూ కీ (keys)లను ఎక్కడో ఒకచోట ఉపయోగిస్తాము.
మరియు రెండూ XML లో ఉన్నాయి, ఈ XML నేమ్
స్పేస్(namespace) డాటాబేస్కీ (database key) లేదా సెక్యూరిటి
కీ(security key) లేదా కొన్ని ఇతర కీ(key) అనుమతిస్తుంది.
ఇక్కడ ప్రధానంగా కీ(key) రకం పేర్కొనబడిఉంది.
అంటే, ఇక్కడ మీరు చూస్తే ఈ నేమ్ స్పేస్
(namespace) డిఫాల్ట్ నేమ్ స్పేస్(default name space).
ఇది W3C చేత నిర్వచించబడింది, అయితే, ఈ నేమ్ స్పేస్(namespace)
ఖాళీ అనేది ఒక గణిత సంబంధిత నేమ్స్పేస్(namespace).
ఇది కూడా ప్రీ డిఫైన్డ్(predefined), కానీ ఖాళీగా ఉన్న
ఒక గణిత సంబంధిత నేమ్పేస్(namespace) అని
నేను చెపుతాను.
ఇప్పుడు నేను ఈ ప్రత్యేక మ్యాత్ రేలాటెడ్
(math related)తో ఏదైనా చేస్తే అప్పుడు నేను ఖాళీ
డబుల్ కోలన్(double colon) mathml మరియు టైటిల్
మొదలగునవి చెప్తాను.
నేను ఈ గణిత నేంస్పేస్(namespace) ను రిఫర్ (refer) చేస్తాను.
కాబట్టి, ఈ ఎంప్టీ ప్రేఫిక్స్ (empty prefix)
mathml, డిఫరెంట్ లాంగ్వేజ్ (different language) ఒక అనే స్పేస్
(space) ని సూచిస్తుంది.
ఇది పూర్తిగా విభిన్నమైన భాష మరియు నా డాక్యుమెంట్లో(document)
ఆ ప్రత్యేక నేమ్పేస్(namespace) యొక్క ఆ అంశాలకు
నేను ప్రాథమికంగా ఉపయోగించగలగాలి.
ఈ విధంగా, మనము చూస్తున్నట్లుగా నేమ్ స్పేస్(namespace)
ఒక ముఖ్యమైన పాత్ర పోషిస్తుంది మరియు
మీరు జాగ్రత్తగా ఉండాలి, మరియు నేమ్
స్పేస్(namespace) నిర్వచనాలు అక్కడ ఉండాలి.
కాబట్టి, ఇతర మాటల్లో చెప్పాలంటే, మనం
చూస్తున్నప్పుడు మనమిప్పుడు ఏమి చేస్తున్నామో
చూద్దాం, ఆ ప్రత్యేక నేమ్పేస్(namespace) చూసి
అది ఎలా ఉపయోగించాలో మొదలైన విషయాలను
తెలుసుకుంటాం.
ఇంతకుముందు మరో ముఖ్యమైన అంశాలను మేము చర్చించాము
వాటిలో కొన్ని XML సాఫ్ట్వేర్(software).
కాబట్టి, XML డాక్యుమెంట్ (document) టెక్స్టువల్
(textual) మోడ్(textual mode) లో ఉంటుంది.
నేను దానిని ప్రాసెస్ చెయ్యాలి.
దీనిలో మొదటగా, ఇది వెల్ ఫోర్మ్ద్ (well
formed) లేదా సింటాక్తీకల్లి(syntactically) కరెక్ట్ (correct) గా ఉందా
లేదా అని వాలిడేట్(validate)చెయ్యాలి.
రెండవది, వేర్వేరు అప్లికేషన్ల(applications)కు
ప్రాసెస్(process) చేయవలసిన అవసరం ఉంది. కాబట్టి,
ఈ XML సాఫ్ట్వేర్(software) ఒక ముఖ్యమైన పాత్ర
పోషిస్తుంది.
కాబట్టి, XML పార్సర్ (parser), XML డేటా (data) ను రీడ్
(read) చేసుకుని DTD మరియు స్కీమా(schema) కన్స్త్రైంట్స్
(constraints) తో సింటాక్స్(syntax) చెక్ (check) చేస్తుంది
మరియు ఈ మొత్తం డేటా(data)ను ఒక అప్లికేషన్ (application)
కి అందుబాటులో ఉంచుతుంది.
మూడు సాధారణ XML API లు లేదా పార్సర్(parser)
API లు ఉన్నాయి.
అందులో ఒకటి, XML SAX పార్సర్(parser), ఇది ఒక సాధారణ XML ఈవెంట్
బేస్డ్(event based) API, ఇది చాలా ప్రజాదరణ పొందిన
విస్తృత పార్సర్(parser) గా మరియు ఎక్కువగా
అన్ని ప్లాట్ఫారమ్(platforms) లలో అందుబాటులో ఉంటుంది.
రెండవది DOM పార్సర్(parser), డాక్యుమెంట్ ఆబ్జెక్ట్
మోడల్(document object model) లేదా ఆబ్జెక్ట్ ట్రీ (object
tree) ఆధారిత పార్సర్(parser).
చివరిది, JDOM పార్సర్(parser) లేదా java DOM పార్సర్(parser).
ఈ XML పార్సర్(parser) మరియు ఇంటర్ఫేస్ సాఫ్ట్వేర్(interface
softwares) లు అధికముగా వివిధ ఆపరేటింగ్
సిస్టమ్స్(operating systems)లో అందుబాటులో ఉంటాయి.
SAX ఆధారిత పార్సర్లు (parsers) మనము తరచుగా
పంపే డేటా స్ట్రీమ్ (data stream) వేగంగా లాగే
ఉంటాయి మరియు ఇవి చాలా తక్కువ కపాసిటీ
(capacity) ఉన్న పార్సెర్(parser) మరియు ఇవి చాలా ఎక్కువ
వేగంతో పనిచేసినా కూడా తక్కువ ఫంక్షనాలిటీలను
(functionalities) కలిగి ఉంటాయి.
DOM చూసినట్లైతే, ఇది స్లోయర్ (slower) పార్సర్
(parser), అధిక మెమరీ ఇంటెన్సివ్ (memory intensive), మొత్తం డాక్యుమెంట్
(document) యొక్క మెమొరీ వర్షన్ (memory verson) ని
క్రియేట్ (create) చేస్తుంది.
వాలిడేటింగ్ పార్సర్(validating parser) అనేది నోన్ వాలిడేటింగ్
పార్సర్(validating parser) కంటే చాలా నిదానముగా ఉంటుంది,
ఎందుకంటే వాలిడేటింగ్ పార్సర్(validating parser),
ప్రొసెసింగ్ (processing) కి వెళ్ళే ముందు
స్కీమా (schema) కు అది అనుకూలంగా ఉందో లేదో
వాలిడేట్ (validate) చేస్తుంది.
వేర్వేరు పార్సర్స్(parsers) గురుంచి చూశాం అందులో
SAX పార్సర్ అందుబాటులో ఉన్నట్లయితే, ఇది
ఈవెంట్(event) ఆధారిత ఇంటర్ఫేస్(interface), పార్సర్(parser),
టాగ్ అట్రిబ్యూట్ (tag attribute) /టెక్స్ట్
నోడ్ (text node)/ పరిష్కరించనిఎ క్ష్టెర్నల్(external)
ఏంటీటి(entity) లు మొదలైనవి చూసినప్పుడల్లా
ఈవెంట్స్(events)ని రిపోర్టు (report) చేస్తుంది.
ప్రోగ్రామర్లు(programmers) ఈవెంట్స్ని(events) నిర్వహించడానికి
ఈవెంట్ హ్యాండ్లర్ల(event handlers)ను అటాచ్(attach) చేస్తారు.
ప్రయోజనాలు.
ఇది ఉపయోగించడానికి చాలా సులభం, చాలా
వేగంగా ఉంటుంది.
మరియు టెక్స్ట్(text), డేటా(data) పొందుటకు
ముందు ఎక్కువగా కష్టపడనవసరం లేదు. కాబట్టి, ఇది
చాలా ఫాస్ట్ (fast), తక్కువ మెమరీ(memory).
కాబట్టి, ఇది తక్కువ పేలోడ్(payload) ని కలిగి
ఉంటుంది.
ప్రతికూలతలు, ఎక్కువ ప్రాసెసింగ్ (processing)
చేయవు.
కాబట్టి, మీరు మీ దగ్గర కొన్ని ప్రాసెసింగ్(processing)లను
చేయవలసి ఉంటుంది.
మీరు డైనమిక్(dynamic) గా సవరించే డాక్యుమెంట్
వరల్డ్ సిరీస్(document world series) మీ మెమొరీ(memory)
లో ఉన్నట్లైతే ఇది అంత ఉపయోగకరం కాదు.
కనుక, మీ డైనమిక్ డాక్యుమెంట్(documents)
లు సవరించడానికి అది ఉపయోగకరంగా లేదు.
ఎందుకంటే ఇది మెమొరీ (memory), దానికి జ్ఞాపకశక్తి
ఉంటుంది, మీ మొత్తం ప్రొసెసింగ్ (processing)
చేసి మెమొరీ(memory) లో పెట్టుకోవచ్చు.
కనుక, ఇది ఒక వనిల్లా(vanilla) రకం XM ప్రాసెసింగ్(processing)
అవసరాన్ని కలిగి ఉన్నప్పుడు ఇది ఉపయోగకరంగా
ఉంటుంది మరియు తక్కువ మెమరీ(memory) తో, ఫాస్ట్(fast)
గా మరియు ఉపయోగించడానికి సులభం గా ఉంటుంది.
డాక్యుమెంట్ ఆబ్జెక్ట్ మోడల్ లేదా DOM పార్సర్(parser)
అయినప్పటికీ అది ఒక ఆబ్జెక్ట్ (object)
ఆధారిత ఇంటర్ఫేస్(interface).
పార్సర్(parser), XML డాక్యుమెంట్(document) కు అనుగుణంగా మెమరీ
ట్రీ(memory tree)లో లేదా మెమరీ(memory) XML ట్రీ(tree)
లో ఉత్పత్తి చేస్తుంది.
DOM ఇంటర్ఫేస్ (interface) అనేది ట్రీ(tree) ని
యాక్సెస్(access) మరియు సవరించడానికి ఒక
పద్ధతిని గుర్తిస్తుంది.
కాబట్టి, ట్రీ(tree) ని డైనమిక్(dynamic) గా
సవరణ మరియు యాక్సెస్(access) చేయడానికి ఇది ఉపయోగకరంగా
ఉంటుంది.
ట్రీ(tree) కి డైనమిక్(dynamic) సవరణ యాక్సెస్(access)
ఉంటే, అది చాలా ఉపయోగకరంగా ఉంటుంది, డేటా(data)
కోసం చూస్తున్న ప్రశ్నకు ఉపయోగకరమైనది, అది
ట్రీ(tree) నిర్మాణం మీద ఆధారపడి ఉంటుంది.
కాబట్టి, క్వెర్రియింగ్(querrying) ఎందుకంటే ఇది ఒక
ట్రీ (tree) నిర్మాణంగా ఉంటే అది ఉపయోగకరంగా
ఉంటుంది.
ఇది అనేక ప్రోగ్రామింగ్ లాంగ్వేజ్(programming languages)
అయిన C++, JAVA కి అదే ఇంటర్ఫేస్(interface).
నష్టం తక్కువగా గా ఉంటుంది.
ట్రీ(tree) ని ప్రొడ్యూస్ (produce) చెయ్యడం మరియు
ఎక్కువ మెమరీ(memory) అవసరం అవుతుంది.
DOM ప్రోగ్రామింగ్ ఇంటర్ఫేస్(programming interface)
ఇక ఆ స్టేట్ (state) కి రాలేదు.
కాబట్టి, ఇది కొంచెం సంక్లిష్టంగా ఉండి
మరియు డేటాను ప్రొఫెషనల్ హ్యాండ్లింగ్(professional
handling) , ఈ ప్రోగ్రామింగ్(programming) ను నిర్వహించాల్సిన
అవసరం ఉంది.
ఒక DOM పార్సర్(parser) విషయంలో ఈ పార్సర్(parser) ఇంటర్ఫేస్(interface)
లో ట్రీ(tree) యొక్క ఈ నిర్మాణంకి వెళుతుంది.
JDOM లేదా java DOM అనేది java ఆధారిత ఆబ్జెక్ట్
ఓరియెంటెడ్ (object oriented).
ఇది DOM తో సమానంగా ఉంటుంది; ఇది java నుండి
వచ్చింది.
పార్సర్(parser) డాక్యుమెంట్ (document) అనుగుణంగా మెమొరీ(memory
tree) ని ప్రొడ్యూస్(produce) చేస్తుంది.
JDOM ఇంటర్ఫేస్ (interface) ట్రీ(tree) ని ఆక్సెస్
(access) చేయడానికి మరియు సవరించడానికి, పద్ధతులను
కలిగి ఉంది. అందువల్ల, ట్రీ(tree) ని యాక్సెస్(access)
చేయడం మరియు సవరించడం జరుగుతుంది,ప్రయోజనాలు.ఇది
ఎంతో ఉపయోగకరం.
ట్రీ(tree) యొక్క డైనమిక్ సవరణ ట్రీ(tree) నిర్మాణ
ఆధారిత క్వార్ర్యింగ్ (querying) కి ఉపయోగపడుతుంది.
కాబట్టి, మీ క్వెర్రి (query), ట్రీ(tree) నిర్మాణంపై
ఆధారపడి ఉంటే అది చాలా వేగంగా మరియు
ఉపయోగకరమైనది.
DOM కంటే చాలా బాగా ఉండే ఆబ్జెక్ట్ ఓరియంటెడ్
ప్రోగ్రామింగ్ ఇంటర్ఫేస్(object oriented programming interface) ను కలిగి
ఉంటుంది.
కనుక, దీనికి చాలా ప్రోగ్రామింగ్ ఇంటర్ఫేస్(programming
interface) ఉందని అర్థం ఉంది. ప్రతికూలతలు
తక్కువ, కొత్త కొత్త అంశాలు ఉంటాయి ఈ
రోజుల్లో కొత్త విశయాల పై పనిచేయడానికి
మీరు కకొంత నైపుణ్యం అవసరం మరియు అది
JAVA పై పని చేస్తుంది, అది బహుశా ప్రతికూలంగా
ఉంటుంది లేదా మీరు పని చేయటానికి JAVA
గురించి తెలుసుకోవచ్చని మేము అనుకోవచ్చు
. ఒక పెద్ద సమస్య.
ఇక్కడ DOM4J లాంటి ఇంకా కొన్ని ఉన్నాయి,
నావిగేషన్(navigation), రాయడం, చదవడం మరియు XML సరిదిద్దడం
కోసం ఇది ఒక java ఫ్రేమ్వర్క్(framework).
SAX, DOM, JDOM ఇంటర్ఫేస్(interface) మరియు XSLT లాంటి ఇతర
రకాలైన ఇంటర్ఫేస్(interface) వంటి ఇతర XML సంస్థలకు
ఆక్సెస్ (access)ని అందిస్తుంది, మిశ్రమ SAX, DOM పార్సింగ్(parsing)
చేయవచ్చు.
ఇందులో కొన్ని ప్రయోజనాలు ఉన్నాయి, అన్నిటికి
ఇది చాలా బాగా ఉపయోగపడుతుంది.
అన్ని JAVA ప్యాకేజీ(package)లో ఒక కలెక్షన్(collection)
గా ఉంటాయి.
SAX మరియు DOM పార్సర్(parser) అపాచీ(apache) ఓపెన్ సోర్స్
లైసెన్స్(open source license) చేయవచ్చు, ఉచితంగా
ఉపయోగించవచ్చు.
ప్రతికూలతలు ఇక్కడ కూడా java నే ఉపయోగిస్తాము
మరియు కొన్ని విషయాల యొక్క ఓపెన్ సోర్స్(open
source)అయితే ఇది మంచిది కాదు.
Xerces మరియు XML టూల్కిట్(toolkit), C కొరకు XML మొదలైనటువంటి
XML పార్సర్(parsers) లు ఉన్నాయి.
క్లౌడ్ (cloud) వంటి కొన్ని దిస్తృబుటెడ్ సిస్టమ్
(distributed systems) లో పరస్పరం అనుసంధానించినప్పుడు
మా సంవిధానంలో మరింత సంక్లిష్టమైన కార్యకలాపాలను
చేయటానికి కూడా బాగా రూపొందించినవే కాకుండా
ధృవీకరించినవిగా కూడా ఎక్కువ సంఖ్యలో
XML పార్సర్ (parsers)లు ఉన్నాయి.
పార్సర్ ఎలా ఉంటుందో వంటి బెంచ్మార్క్(benchmarks)లు
కొన్ని ఉన్నాయి, స్పీడ్ మెమరీ(speed memory)
మరియు స్ట్రీమ్ ప్రాసెసింగ్(stream processing) గురించి, కొన్ని
ఉన్నాయి.
XML ప్రాసెసింగ్(processing) లో మరో ముఖ్యమైన
అంశం XSLT. ఇది ఎక్ష్టెన్సిబుల్ స్టయిల్ షీట్ లాంగ్వేజ్
(eXtensible Stylesheet Language).
XML ఎలా రెప్రసెంట్(represent) చేస్తుందో ఈ స్టయిల్
షీట్(style sheet) ద్వారా ఇవ్వబడుతుంది.
మరో అర్థంలో, మనం స్టైలింగ్(styling)తో
పాటు XML దానిని రెప్రసెంట్ (represent) లేదా డిస్ప్లే
(display) చేయడానికి అనుమతిస్తుంది.
కొన్నిసార్లు కారెక్టర్(character) పరమ్ గా XML ప్లస్ XSLT
అనేది HTML రకంకి సమానమైనది.
కాబట్టి XSLT ఎక్స్టెన్సిబుల్ స్టైల్ షీట్ లాంగ్వేజ్
ప్రధానంగా ట్రాన్స్ఫోర్మేషన్ (transformation) కోసం ఉపయోగిస్తారు.
లేదా అది పరివర్తన రకాన్ని మరింతగా
కలిగి ఉంది.
XML డేటాను ప్రాసెస్(process) చేయడానికి XML లాంగ్వేజ్
(language), XML మరియు XSLT స్టైల్ షీట్(style sheet) ని ఇన్పుట్(input)
గా తీసుకుని ట్రీ (tree) ట్రాన్స్ఫోర్మేషన్
(transformation) చేస్తుంది.
విభిన్న నిర్మాణం మరియు విషయాల రకంతో
ఒక కొత్త XML డాక్యుమెంట్(document) ని ఉత్పత్తి చేస్తుంది.
కాబట్టి, ఇది XSLT గా ఉంటుంది.
మనం సాధారణం గా XSLT లో ఒక విధమైన ఫిల్టర్
ఆపరేషన్ (filter operations) లు చేయవచ్చు.
కాబట్టి, ఇది XML డేటాను తీసుకుంటుంది, దాన్ని
ప్రాసెస్(process) చేస్తుంది మరియు మరోవైపు వేరొక
XML డేటా(data)ను జనరేట్ (generate) చేస్తుంది మరియు
ఒక కొత్త XML డాక్యుమెంట్(document)ని వేర్వేరు నిర్మాణంతో
చేస్తుంది.
ప్రయోజనాలు, ట్రీ (tree) ట్రాన్స్ఫోర్మేషన్
(transformation) లకు చాలా ఉపయోగకరంగా ఉంటాయి; కాబట్టి,
నేను ట్రీ(tree) ని ట్రాన్స్ఫోర్మ్ (transform) చెయ్యాలనుకుంటున్నాను,
మరియు నా అప్లికేషన్ (application) కోసం నేను దాని
యొక్క సబ్ ట్రీ (sub tree)ని ఉపయోగించడానికి
కావాలి.
ఇది నేను ఎలా చేయగలను?
కాబట్టి, ఈ XSLT ను ఉపయోగించి ఫిల్టేరింగ్ (filtering)
చేస్తాను, ఆపై ఇతర భాగాలకు ఫిల్టర్
చేయగలను.
కనుక, ప్రతికూలతలు, లార్జ్ డాక్యుమెంట్స్
(large documents)లకు లేదా స్టయిల్ షీట్ (style sheets) లకు ఇది
శ్లో (slow) గా ఉంటుంది, స్టైల్ షీట్ డీ బగ్
(debug) చేయడం కష్టం, ఎర్రర్ డిటెక్షన్ (error detection),
మొదలైనవి శ్లో (slow) గా ఉంటాయి.
ఎర్రర్ డెటెక్షన్ (error detection)లో ఇది అంతా
వర్సటైల్ (versatile) కాదు. కాబట్టి ఇప్పుడు,
మీరు పై చిత్రాన్ని చూస్తే.
XML డేటా(data) వస్తోంది.
ఇప్పుడు మనము ఒక స్టయిల్ షీట్(style sheet)
కలిగివుంటే అది మరొక XML పార్సర్(parser) ని కలిగి
ఉంటుంది.
మరియు అది ఈ ప్రాసెసర్(processor), ప్రాసెసింగ్(processing)
యూనిట్(unit)కి వెళుతుంది.
ఈ వేరొక ట్రీ(tree) ని కలిగి ఉంటాము.
కాబట్టి, నేను ఇక్కడ ట్రీ (tree) ని మరియు
ఆక్కడ ట్రీ (tree) యొక్క ఒక పార్ట్(part) ని కలిగి
ఉన్నాను, వీటిని ఇన్పుట్గా(input) తీసుకుంటే
ఔట్ పుట్ డాటా(data) అనేది XML, XSLT ఆధారంగా
ఫిల్టర్ (filter) చేయబడి కొత్త XML డాటా (data) ని
ఉత్పత్తి చేస్తుంది.
XML మెసేజింగ్(messaging), వ్యవస్థల మధ్య సందేశాలను
పంపడానికి ఫార్మాట్గా(format) XML ను ఉపయోగిస్తుంది.
ప్రయోజనాలు, ఒకే రకమైన సింటాక్స్
(syntax), సెల్ఫ్ దిస్క్రైబింగ్ (self describing) సులభంగా వివరించే
HTTP etc వంటివి XML డేటాను తరలించడానికి ఎక్షిస్టింగ్
(existing)లో ఉన్న సాధారణ ట్రాన్స్పోర్ట్(transport)
విధానంను ఉపయోగించవచ్చు.
డేటా(data)ను బదిలీ చేయడానికి XML కి క్యారియర్ ప్రోటోకాల్(carrier
protocol) అవసరం.
అందువల్ల, మనము ఏదైనా డాటా ట్రాన్స్పోర్ట్(data
transport) పద్దతిని ఉపయోగించాలి.
ఇది మరి ఏ ఈతర ట్రాన్స్పోర్ట్ లేయర్ (transport layer) ప్రోటోకాల్ల(protocol)
తో కలసి ఉండకూడదు.
కనుక, అది ఒక ట్రాన్స్పోర్ట్ (transport) విధానం అంటే
నెట్వర్క్(network) క్రింద ఉంటుంది మరియు మనము
http, https, SMTP మొదలగునవి ఉపయోగించవచ్చు.
ఈ విధమైన XML మెసేజింగ్(messaging) యొక్క కొన్ని అవసరాలు
మరియు అప్రయోజనాలు ఉన్నాయి.
మరియు సాధారణ సందేశ నమూనాలు ఉన్నాయి.
కాబట్టి, XML సందేశాలు కోసం ప్రోటోకాల్కు
HTTP ను ఉపయోగించడం, XML లో ఈ XML సందేశాలు
మీరు చూసినట్లయితే ఈ అంశాన్ని ఈ భాగం
ఒక ప్రామాణిక ప్రోటోకాల్, http ప్రోటోకాల్ యాంత్రికాలు
అని పేర్కొన్నట్లయితే.
అయితే, ఇది XML సందేశం లేదా XML పత్రం విషయాలు
లోకి పొందుపర్చబడింది.
సో, అది ఒక కవరు అని ఇది HTTP ప్రోటోకాల్
మరియు తరువాత అది stuff లోకి ఎంబెడెడ్.
XML-RPC వంటి మెసేజ్ ఫార్మాట్(message format)కి కొన్ని ప్రమాణాలు
ఉన్నాయి.
కాబట్టి, ఎన్కోడింగ్ ఫంక్షన్(encoding function) పద్ధతి
యొక్క చాలా సరళమైన మార్గం నేమ్ (name) ను
కాల్ చేసి దాన్నిని మరొక చోటికి పాస్
(pass) చేయడం వంటివి.
సమాచార ఫార్మాట్ల(formats)లో ఒకటి, సోప్(soap), సింపుల్
ఆబ్జెక్ట్ ఓరియెంటెడ్ ఆక్సెస్ ప్రోటోకాల్
(simple object oriented access protocol) ఇది ప్రధానంగా వెబ్(web)
సేవల్లాంటి సేవ ఆధారిత నిర్మాణంలో ఉపయోగించబడుతుంది.
కాబట్టి, ఇది మరింత సంక్లిష్టమైన రేపర్(wrapper)
మీరు ఇంటర్ఫేస్ కోసం మరింత క్లిష్టమైన
నియమాలను నిర్వహించడానికి మరియు ప్రాక్సీ(froxy)
సందేశాలను మరియు ఇంతకు ముందుగా స్కీమా(schema)లను
పేర్కొనడానికి అనుమతిస్తుంది.
దీనిని soap సందేశం ఫార్మాట్ ద్వారా
చేయవచ్చు.
మీరు మరలా చూస్తే XML సందేశము ప్లస్
ప్రాసెసింగ్(processing), XML అనేది డేటా ఎక్స్ఛేంజ్(data
exchange) కోసం యునివర్సల్ ఫార్మాట్(universal format).
నేను soap API తో ఈ అప్లికేషన్(application) ను కలిగి ఉంటాను,
మరియు ఇక్కడ ప్రధానంగా రెండు వేర్వేరు రకాల
సరఫరాదారులు ఉంటారు.
అందువల్ల, వివిధ రకాల సరఫరాదారులతో
ఇంటెరక్ట్ (interact) అవుతుంది, ఇది మొత్తంగా ఒకే
అప్లికేషన్, హెచ్‌టి‌టి‌పి (http) ద్వారా ఇతర అప్లికేషన్(applications)
లతో ఇంటెరక్ట్ (interact) అవుతుంది.
కాబట్టి, ఇది soap సందేశం, http లో పిగ్గీబ్యాక్(piggyback)
అవుతుంది.
మరియు ఈ http యొక్క పేలోడ్ లాగా తీసుకెళ్ళి,
విషయాలను పంపిణీ చేస్తుంది, ఇతర ఏంటీటీఎస్
(entities), డాటా (data) రన్(run) అవుతున్న ఈ ప్రత్యేక
అప్లికేషన్ (application) కు ఎక్స్ట్రాక్ట్(extract)
చేసి డెలివేరి (delivery) చేస్తాయి.
కాబట్టి, మేము XML యొక్క ఈ కుటుంబం చూస్తే.
మధ్య భాగంలో మనకు XML, XSLT, XSL, X పాత్, X పాయింటర్
మరియు ఇతర అంశాలు ఉన్నాయి.
ఇవ్వన్ని చర్చించడానికి మొదటగా మనకు అంత
సమయం లేదు. మరియు రెండోది, మనము ఈ లక్షణం
ఎలా లేదా XML యొక్క విలక్షణమైన లక్షణాలు
ఏవి.
XML నేర్చుకోవాలని ఆసక్తి ఉన్నవారు
W3C స్కూల్ (school) లేదా ఏదైనా ప్రామాణిక
పుస్తకంను అనుసరించవచ్చు, మరియు కొన్ని చిన్న
ప్రాజెక్టులను చేయదానికి ప్రయత్నించండి.
అయితే; ఈ విధమైన API లు విభిన్న స్టైలింగ్(styling)
లో ఉన్నాయి, వీటిలో వేర్వేరు ప్రోటోకాల్(protocol),
XML ఉన్న వెబ్ సర్వీసెస్ (web services) లు ఉన్నాయి.
ఇక్కడ వేరే ఇతర రకాలు ఉండవచ్చు.
ఈ XML యొక్క వర్సటైల్ (versatile) స్వభావం చూపించడానికి
ప్రయత్నిస్తుంది మరియు ఇది ఒక కొంపనీయన్
(companion) టెక్నాలజి (technology).
ఈ XML మరియు దాని కమ్యూనిటీ(community) దిస్తృబుటెడ్ సిస్టమ్(distributed
systems) లో దాని నిర్మాణాన్ని గుర్తించడంలో కీలక
పాత్ర పోషిస్తుంది.
సో, నేను దిస్తృబుటెడ్ సిస్టమ్(distributed systems)
ను ఇంటెరక్ట్ (interact) అవ్వడానికి కలిగి
ఉన్నాను మరియు soap మెసేజ్ (message) ని ఉపయోగించి
కొమ్మునికేట్ (communicate) అవుతాను, దీనితో
పాటుగా WSDL మెసేజింగ్(messaging), WSDL UDTI మొదలైనవన్నీ
ప్రధానంగా XML పై ఆధారపడి ఉంటాయి.
మనము mathml వంటి ఇతర నేమ్ స్పేస్(namespace)
లు కూడా ఉన్నాయి మరియు గ్రాఫిక్స్(graphics)
సంభందిత విషయాలను ఉత్పత్తి చేయడానికి
SVG ఉంది. కాబట్టి, ఈ XML డేటా ట్రాన్స్ఫోర్మేషన్
(data transformation) అనుమతించడంలో సహజంగానే వర్సటైల్
(versatile)గా ఉంటుంది.
మరియు నేను ఈ డేటా ను రెప్రెసెంట్ (represent)
చెయ్యాలి అనుకుంటే అప్పుడు నేను XSLT లేదా
కొన్ని XLD ద్వారా కొన్ని స్టైలింగ్(styling)
లు అవసరం అవుతాయి.
కొన్ని స్టయిల్ షీట్లు(style sheets) కూడా డేటా ను రెప్రెసెంట్
(represent) చెయ్యడానికి ఉపయోగపడతాయి; నేను
ఒక HTML ఫైల్(file), మరొక వైపు డాటా ను చూడడానికి
రూపొందించవచ్చు.
మనం ప్రాథమికంగా చాలా ప్రాథమిక పరిచయ
విషయాలు లేదా XML యొక్క ప్రధాన భాగాల గురించి,
మరియు ఇంటెరోపేరబిలిటీ (interoperability) ని రూపొందిచడంలో
ఈ కొంపోనెంట్స్(components) ఎలా తోడ్పడతాయి అనేవి
తెలుసుకున్నాం.
మీరు కొన్ని రకాల ఇంటర్ఫేస్లు(interfaces)
ఇంటరాక్ట్(interact) అవ్వడం లేదా ఇంటర్పోపెరాబిలిటీ(interoperability)
అవసరము ఉన్న క్లౌడ్(cloud) లేదా దిస్తృబుటెడ్
సిస్టమ్(distributed systems)ను చూస్తే అక్కడ XML గుర్తించదగ్గ
de facto లాంగ్వేజ్ (language).
కాబట్టి, మనమిప్పుడు XML యొక్క ఈ బేసిక్స్(basics)గురించిన
చర్చను ఈరోజుతో ముగిస్తున్నామ్.
ధన్యవాదాలు.
