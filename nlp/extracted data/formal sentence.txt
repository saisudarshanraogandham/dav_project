curriculum-2005 computing నిర్వచనం
చూసినట్లైతే వారు computingని
సాధారణ పద్ధతిలో నిర్వచించినట్లుగా
,ఇధి లక్ష్య ఆధారిత చర్యను పరీక్షించడానికి
ఉపయోగపడుతుందని అర్ధమవుతుంది .
అంటే hardware,Software systemండి విస్తృతమైన
ప్రయోజనాలకోసం ప్రారంభించి ,మేధో సంభాషణలను
ఉపయోగించడం ,నిర్ధిస్ట ప్రయోజనాలకు సంభంధించి
సమాచారాన్ని సేకరించడం మొదలైనవి . computingలో
ఏదో ఒక విధమైన అవసరం ఉందని మనం గమనిస్తే
అది computing model క్రిందకు వస్తుంది.
వనరుల పరంగా మాత్రమే కాకుండా నిభంధనల
పరంగా వాడుకునే వ్యక్తుల స్థాయిని చూపెడుతుంది
.ఒక ఉన్నత స్థాయి పరిశోధకులు లేదా
professional నుండి ఒక విధ్యార్ధి,ఒక
గృహిణి,సాధారణ పౌరుల వరకు వారి ప్రయోజనాలకు
తగినట్టుగా ఇది ఉపయోగపడుతుంది.
అది ఎలా ఉపయోగించడం అనేది నేర్చుకుందాం.
cloud computingవివరణ లోకి వెళ్ళేముందు,
మరొక్కసారి మనం నేర్చుకోబోయే అంశాలను పునరీక్షించుకుందాం.cloud
computing పరిచయంలో NIST model ఏమి
చెప్పింది,సాధారణ లక్షణాలు ఏమిటి,
లక్షణాలు, ప్రయోజనాలు మరియు లోపాలు, open
standards పాత్ర గురించి
చెబుతుంది.
కనుక, మనము ముందుగా ఈ cloud computing
 కి standard  ఉందా , లేదా చూస్కోవాలి.
ఉంటే cloud computing నిర్మాణం గురుంచి
మనం ఎక్కువ తెలుసుకోవాలి.
అనగా, cloud computing stack
ఎలా serviceా ఆధారిత నిర్మాణం గా పని చేస్తుంది.
cloud computing లో ఏవిదమైన service
modelలు అందుబాటులో ఉంటాయి అంటే infrastructure
as ఎ service , platform
as service లేదా Software
as service లేదా దేన్నైనా
 Service  గా అందించడం.
మనము ఈ దేన్నైనా service గా ఎలా అందిస్తారో
తర్వాత చూద్దాం.
ఒకే cloud లో వివిద రకాలైన విస్తరణ
 model  లు ఉన్నాయి . ఇది వాస్తవమా
కాదా మరియు వాటిని ఎలా ఉపయోగిస్తాము,
ఎప్పుడు,ఎక్కడ, ఏవిధంగా deploy చెయ్యాలి
, ఎన్ని రకాల విస్తరణ  modelలు 
వున్నాయి అనేవీ తెలుసుకుంటాము .
cloud యొక్క మరొక ప్రధాన అంశం service
నిర్వహణ .
consumerలు ఏదైనా ఒక serviceను  purchase
చేయాలనుకున్న లేదా మనము ఏదైనా Service
రిజర్వ్ చేసుకున్నప్పుడు Service నిర్వహణ
అవసరం.
consumerడిగా నేను Service provider
నుంచి నేను ఏమి haami (Not an English word but included for context) ఉంటుంది వాళ్ళు అందించే
Service కి అని చూసుకుంటాను .
cloud provider లేదా CSP, వచ్చే లాభాలకు
లేదా ఇచ్చిన haami (Not an English word but included for context)లను ,computerస్
లో services ఉపయోగించడానికి కావలసిన ఇతర వనరుల
గురించి సమాచారం ఇస్తుంది.
కేవలంcloud servicesలో నే కాకుండా
, ఏ service రంగం అయినా provider మరియు
consumerడు ఉంటారు.
అలాగే , మన రోజువారి జీవితంలో ఏ serviceకైనా
provider కి మరియు కన్స్యూమర్
కి మధ్య serviceా పరమైన ఒప్పందం ఉంటుంది.
ఏవిధంగా అంటే, నేను 100% లేదా 100% కి దగ్గరగా
services ప్రొవైడ్ చేస్తాను అని provider
haami (Not an English word but included for context) ఇస్తారు.
కానీ నేను ఒక consumerడిగా ఆ Service ని ఉపయోగిస్తున్నప్పుడు
అవసరాన్ని బట్టి దాని లభ్యత
90% కి తగ్గిపోవచ్చు.
లభ్యత ఆధారంగా వనరులను నిర్వహిస్తారు
లేదా సరఫరా చేస్తారు.
వివిధ రకాల వనరులను మరియు వాటి లభ్యత
ను బట్టి provider Tierను నిర్ణయిస్తాడు.
దీనితో బాటుగా ఇందులోని problemలు అనగా down
time కి సంభందించిన problemలు, serviceా నాణ్యతకు
సంభందిన problemలు,ఇంకా ఎన్నో services కి సంభందించిన
problemలు,వీటన్నింటినీ మనము serviceా సంభందిత
ఒప్పందాలలో చర్చించుకుంటాం.
cloud computing లో మరొక ప్రధాన
అంశం cloud ఆర్థిక వ్యవస్థ .
cloud computing ఎప్పుడూ ఉపయోగించడం
మంచిది అని చెప్పను కానీ, చాలా సందర్భాల్లో,
ఉదాహరణకు, మీరు ఇంటి నుంచి office కి రోజూ
220kms ప్రయాణం చెయ్యాలి అనుకోండి,ఆ సందర్భం
లో ఒక కార్ purchase చేస్తే ఆర్థికంగా
మంచిది.
అయితే మరి కొన్ని సందర్భాల్లో అంటే
మీరు నెలకు ఒకసారి 50కి.మీ లేదా 100కి.మీ
ఎక్కడికైనా వెళ్ళాలి అనుకుంటే appపుడు
కార్ ను purchase చేయడం ఆర్థికంగా
మంచిది కాదు కదా. ఇలాంటి సమయంలో కార్
ను అద్దె కు తీస్కోవడం మనకు ఆర్థికంగా మంచిది.ఇదేవిధంగా
ఎప్పుడు నేను వనరులని నియమించుకోవాలి
లేదా ఎప్పుడు purchase చెయ్యాలి అనేదానికి
ఒక policy ఉంటుంది.
దీన్నంతని సమర్ధించే ఒక ఆర్థిక model
వుంటుందా లేదా అని తెలుసుకోవాలి.
ఒక institution గా నేను వనరులను 
కొనడం కంటే నియమించుకుంటే  ఆర్థికంగా బాగుంటుంది
అంటాను.
మనము ఒక institutionను మొదలు పెట్టేటపుడు
వనరులను purchase చెయ్యడ మంచిదా లేక
నియమించుకోవడం మంచిదా మరియు ఏ ఆర్థిక model
మంచిది అని నిర్ణయించుకోవాలి.
కనుక,cloud ఆర్థిక వ్యవస్థ గురించి
ఇప్పుడు చూద్దాం.
cloud computing లో మరొక ప్రధాన
అంశం వనరుల నిర్వహణ .
ఇది completely cloud provider లేదా CSP
బాధ్యత ,అంటే వనరుల నిల్వ ఏవిధంగా సరైన
దిశలో నిర్వహించాలి.
ఒక provider గా నను అందరికీ serviceలు
అందించేలా చెయ్యాలంకుంటున్నాను.
కనుక,నేను ఏ విధమైన వనరులను  నిర్వహించాలి
వివిధ అవసరాలకు తగినట్లుగా.
ఇది దేనికైనా వర్తిస్తుంది , ఉదాహరణకు, నాకు ఒక
స్టేషనరీ షాప్ ఉందనుకుందాం.
ఈ shop లో స్టేషనరీ కి సంభందించిన వస్తువులు
అంటే చదువుకు కావల్సినవి పుస్తకాలు ,పెన్నులు
మొదలైనవి ఉంటాయి.
కనుక,నేను ఎన్ని వస్తువులు నిల్వ
చేసుకోవాలి లేదా నేను ఎంతవరకు ప్రాజెక్టు
చెయ్యాలి ఇలాంటివన్నీ కూడా ఆలోచించాలి.
నేను ఎప్పుడూ నా షాప్ లో వేచివుండే
పరిస్థితి లేదా షాప్ఫుల్ గా వుంది ,కాబట్టి
నేను కొన్ని వస్తువులను షాప్ బయట పెట్టుకుంటాను
అని చెప్pay పరిస్తితి రాకూడదు.
limitedికి మించి వనరులని తీసుకోకూడదు.
కనుక, వనరుల నిర్వహణ సరైనదిగా ఉండాలి.
computing ని ఒక వనరు గా తీస్కోవడం
అనేది చాలా క్లిస్తమైనది మరియు గమ్మత్తైనది.computing
ని resourceగా అందిస్తున్నప్పుడు
చాలా వనరులను పరిగణలోకి తీసుకుని నిర్వహించాల్సి
వుంటుంది.
సాదారణంగా, cloud కాకుండా ఏదైనా computing
వ్యవస్థలో మనం చూసినట్లైతే ఏ అంశాలను మనము పరిగణలోనికి
తీసుకుంటాము అంటే Processor కావచ్చు
లేదా సి‌.పి‌.యూ,మనము ఉపయోగించే మెమొరీ
లేదా ర్యామ్ లేదా Hard Disk మరియు network connection ఇంకా అవసరమైన
వనరులు కావచ్చు.
కనుక,ఎన్ని వనరులని మనము నిల్వ మరియు
నిర్వహించాలి.ప్రతి resource కి
దాని అంతర్లీన ఖరీదు ఉంటుంది.
నేను వినియోగం లేకుండా భారీ మొత్తం లో వనరులను
నిర్వహించాల్సిన అవ్సరామ్ వస్తే,
appపుడు నేను అధిక మొత్తం లో అంటే నిర్వహణ
Tier కంటే ఎక్కువ Tierను చెల్లించాల్సి వస్తుంది.
కనుక, here సరైన లేదా సముచితమైన వనరుల
నిర్వహణ అనేది ఒక సవాలు  గా మారింది.దీని
కొరకు ఈ కోర్స్ లో మనం cloud computing లో వివిధ రకాల వనరుల నిర్వహణ అంశాలను
తెలుసుకుంటాం.
cloud computing లో మరో అంశం,
data నిర్వహణ :Data ) అనేది
చాలా ముఖ్యమైన, గమ్మతైన విషయం ఇందులో మనం
ని ఎలా నిల్వ  చేస్తాం,Data వ్యాప్తి
 మరియు cloudలోData serviceలు ,
data బేసెస్,data storeలుbases,
data stores) అన్నీ ఉంటాయి.
కనుక, cloudData) అవసరాలను
నేర్చుకోవడం ప్రత్యేక అభ్యాసం.ఎక్కువ మొత్తంలో
ప్రక్రియ జరిగితే , నిర్వహణ ఎలా వుంటుందో
చూద్దాం.
సాదారణ పద్దతిలో లేదాData base నిర్వహణ
వ్యవస్థData బేస్ మెనేజ్మెంట్ System cloud computing
లోData ఉపయోగం మరియు ఏ విధాయలను
వేర్వేరు ఉపయోగించాలి అనేది నేర్చుకోబోతున్నాం.మన
రోజువారీ జీవితంలో వివిద రకాల storage ని
ఒక service గా ఎలా ఉపయోగిస్తాం మరియు ప్రజాTierణ పొందిన
data storage లలో డ్రాప్ బాక్స్ అనేది
ఒకటి. కనుక, background లో విషయాలను
ఎలా నిర్వహించాలి అనేది తెలుసుకోవాలి,
అంటేData services ని నిర్మించడం వంటివి
కాదు. కనీసం మనంData model  అందులోని
problemలను  తెలుసుకోవడాని ప్రయత్నించాలి.
మరొక అంశం ఏమిటంటే,Data బధ్రత,అంటే
మీData ఇతర ప్రదేశాలలో ఉందనుకోండి.
మీరు computing వేరొక domain
లో చేస్తున్నారు ఇలాంటప్పుడు security
కోణాలు ఎలా ఉంటాయి.
అందువల్ల,మౌలిక సదుపాయాల security ,Data మరియు
storage security ముఖ్యమైన అంశాలు.
చాలా మంది ఏం చెబుతారంటే, మనము application
ని పునరుత్పత్తి లేదా పునఃస్థాపన
చేసుకోవచ్చు.
కానీ,Data ని పునరుత్పత్తి లేదా పునఃస్థాపన
చేయలేము.
ఒక System లో 10 లేదా 100 payజీల నివేదిక
తయారుచేస్తున్నప్పుడు System చెడిపోయింది
అనుకోండి ,application తో పాటుగాData
కూడా నాశనం  అవుతుంది.appపుడు మనము OS ఆపరేటింగ్
Systemని , word processing ని తిరిగి
పొందవచ్చు.
కానీ,Dataని తిరిగి పొందడం సాధ్యం కాదు,
ఏదైనా పునరుద్Tierణ వ్యవస్థ వుంటే
తప్ప. నేను ఎప్పుడైనా నా దగ్గర వున్న డెస్క్tap
System కానీ ,laptop కానీ ఉపయోగిస్తుంటే
అందులోData ని backup తీస్కోవాల్సిన
భాధ్యత నాదే ఎలాగంటే ఒకే రకమైనData
కు సంభంధించిన ఎక్కువ కాపీలను పెట్టుకోవడం.
నేను నా Systemలో కాకుండా వేరొక చోట
dataని store చెయ్యాలనుకున్నప్పుడు, ఏదైనా loss లేదా ఇంకేదైనా
ప్రమాదం జరిగినప్పుడుData ఎలా బధ్ర
పరచబడుతుంది.
మరొక problem ఏమిటంటే నాData ని ఎవరైనా
తీసుకోవడం లేదా దొంగలించడం జరగవచ్చు.
కనుక, మనకుData security గురించి ఒక
అవగాహన ఉండాలి.
here మరొక ముఖ్యమైన అంశం ఐడెంటిటీ
మరియు ఎక్సెసింగ్ నిర్వహణకి సంబందించిన
విషయం.
ప్రత్యేకించి సహకార partyల మధ్య వీటి
ఆవశ్యకత ఎక్కువగా ఉంటుంది.
ఎక్సెస్ నియంత్రణ , నమ్మకం  మరియు
కీర్తి  కి సంభందించిన problemలు కూడా ఉన్నాయి.
ఈ ఎక్సెస్ నియంత్రణ ఎలా జరుగుతుంది,standard
అక్సెస్ నియంత్రణ పద్దతా లేదా పాత్ర
ఆధారిత పద్ధతా .
ఇప్పుడు securityమీద పని చేద్దాం, ఎలాగంటే
,ఒక service providerని ఎంత నమ్ముతున్నాం
లేదా నేను service provider2 కంటే
service provider 1ని ఎక్కువగా నమ్మలా?
CSPని ఎలా భేరీజు వెయ్యాలి?
రేపుటేషన్కి సంభందించిన అంశాలను
కూడా చూడబోతున్నాం.
data, application మరియు consumerలు
loss అయినప్పుడు పడే రిస్క్కి సంభందించిన
అంశాలను కూడా చూడబోతున్నాం.
consumerలు అంటే ఎవరికోసం అయితే మనం
cloud ని purchase చేస్తున్నాము .మనము
వీటిని భధ్రపరచవచ్చు .కనుక ఈ ట్రస్ట్,
రెపుటేషన్ మరియు రిస్క్ని ఒక త్రిభుజంలో
మూడు భాగాలుగా చెప్పవచ్చు .అంటే ఈ మూడు ఒకధానికి
ఒకటి అంతర్లీన సంభంధం కలిగి వుంటాయి .దీని
వలన పూర్తి వ్యవస్థ పని తీరూ ఎక్కువగా
ప్రభావితం అవుతుంది.వీటి అన్నింటిని cloud
computing రూపావలిలో ఏ విధంగా
haami (Not an English word but included for context) యిస్తారు అనేధి చూద్ధాము .
తదుపరి మనము కొన్ని సంధార్భాలను పరిశీలన
చేద్దాం .కొన్ని వివరణ పూరిత open
source మరియు cloud సిములేటర్ గురించి తెలుసుకుందాం.బజారులో చాలా వాణిజ్య పరమయిన
clouds అంధుబాటులో ఉన్నాయి .కనుక మనం
వాటి property ని మరియు పనితీరును తెలుసుకోవడానికి
ప్రయత్నిద్ధాము.తరువాత open source cloud గురించి తెలుసుకుందాము.సమయం ఉంటే వివిధ రకాల
ఇంస్టాలేషన్ open source cloud లు మరియు సిములేటర్లు
ఉన్నాయి అనేధి కూడా చూద్ధాము .ఈ విధ్యా
ప్రపంచంలో మన ముఖ్య ఉద్ధేశం వీటిని భవిష్యత్
లోకి తీసుకెళ్ళడం .మరి మనం భవిష్యత్
లో మరికొంత చూడబోతున్నాం .కాభట్టి ప్రస్తుత
cloud computing ధోరణిని చూడడానికి
ప్రయత్నిద్ధాము . ఎవరితే పరిశీలనలో
ఆసక్తి చూపుతారో వారు pg లేదా ug స్థాయిలో
వారు cloud computing యొక్క విభిన్న అంశాలు
ఏవి అని ఒక ఆసక్తి కలిగి ఉండవచ్చు .fog
computing మరియు వివిధ టెక్నాలజీ
గురించి మాట్లాడుకునేవారు ఉండవొచ్చు.
కాభట్టి ఆ విషయాల యోయిక్క వివిధ అంశాలు
ఏమిటి అని చూడాలనుకుంటున్నాము .కాభట్టి ఈ కోర్సు
లో కోర్సు నిర్మాణం ,ప్రాముఖ్యతను భట్టి
సరైన వివరణ అందించడానికి మేము ప్రయత్నిస్తాము
.మరిన్ని వివరాలు మీకు ఆ Lectureస్
ధ్వార మీకు అందిస్తాము .
దీనిని బట్టి మనకో సంక్షిప్త సమాచారం
త్వరితగతిన వస్తుంధి.వాస్తవానికి ఈ cloud computing
లో చేసిన వివిధ computing
ధోరణులు ఏమిటి ?దీనిని బట్టి ఇది ఒక్కరోజులో
వచ్చింది కాదు. ఇంకేదో వుంది .కాబట్టి మేము
చెప్payది ఏమిటంటే అన్నీ ఆవిష్కరణల
లేదా developmentకి ప్రాధమికంగా ఉన్న
అవసరాలతో లేదా సైంటిఫిక్ community
చెప్pay అవసరాలతో ,లేదా సాధారణ ప్రజల
అవసరాలతో ముందుకు సాగుతున్నాము . అయితే
మనము ఈ విషయాల గురించి ఎక్కువుగా శోధిస్తూ
ఉన్నాం .ఈ computing అనేది చాలా వరకు
ముందు నుంచే ప్రాచుర్యం లో ఉంది .ఇప్పటికి
ప్రాచుర్యంలో ఉంది. ఇది completely కొత్త
విషయమా లేక సమ్మేళనమా లేక విషయాల పరిణామమా
. వివిధ రకాల లిటరేచర్లలో
లేక cloud computingలో ఏం చూశాం .ఇది ఏమి
కొత్త విషయం కాదు .ఇది ఇప్పటికే ఆచరణలో
ఉంది,మరియు దీని development వేరొక
రూపం లో కలిగి ఉంది. మనం వివిధ రకాల computing
రూపావళిని గమనించినట్లైతే అవి ఎక్కువ కాలం
ఉపయోగించ బడుతున్నాయి.
కనుక మనం వివిధ రకాల computing
పద్ధతులను చూసినట్లైతే ,మొట్ట మొదటి computing
,distributed computing.
అన్నీ computing దీనిని నుండి పుట్టుకొచ్చాయి
.దీనితో పాటు grid computing
,cluster computing,utility computing
మరియు cloud computing గురుంచి మాట్లాడుకుంటాం.
ఇప్పుడు ఎక్కడైనా వివిధ అవసరాలకు తగిన
developmentని చూసినట్లైతే ,ప్రతి ఒక్కరికి
కొన్ని ప్రయూజనాలు ఉంటాయి మరి కొన్ని
నష్టాలు ఉంటాయి .కొన్ని అంశాలను సులభ పద్ధతిలో
పరిష్కరించడానికి computing
ఎలా సహాయ పడుతుందో నేర్చుకుందాం .ఎందుకంటే
కొన్ని మనకు తెలిసినవే లిటరేచర్లో
ఉన్న విధంగా computing అనేది నిర్వచించబడింది
.
distributed computing ని చూసినట్లైతే,పూర్వ కాలంలో కెంద్రీకృత
వ్యవస్థ ఉండేది .దీనికి వివిద రకాల
టర్మినల్లు ఉన్న మెయిన్ ఫ్రేమ్ని
ఉపయోగించేవారు .here జాబ్స్ main framesకి
అందించి పూర్తి చేసుకొని వాటి ఫలితాలను అమ్ముకుంటారు.
కాబట్టి ,ప్రధానంగా దీనిలో తార్కికంగా
ఒకేprocessing ఉంటుంది అందువల్ల
దీనిని యూనిప్రొసెసర్ computing
లేదా సెంట్రల్ computing రకంగా చెబుతాము .ఇప్పుడు
వివిధ ప్రదేశాల్లో ఉంది .అంతే కాదు ఇది
ఇప్పటికీ వాడుకలో ఉంది. కాబట్టి దీనిని
మనం వదిలి వేయలేము.దీని అవసరం ఎక్కడో ఒక
చోట ఉండే ఉండొచ్చు .మరొక development
చెందిన computing, distributed
computing,ఇది ఒక భౌgoళిక స్థలంలో
పంపిణీ చేసిన వివిధ రకాల Systems.దీనిలో
ఒక lab సన్నివేశంలో మరియు ఒక పెద్ధ
భౌgoళిక సరిహద్ధులు కలిగిన సన్నివేసంలో
వెత్యాసం ఉంటుంది.ఇది అక్కడ ఉన్న వివిధ
రకాల రిసోర్సెస్  పై ఆధారపడి ఉంటుంది
.here మరొక ముఖ్య problem కోలాబొరేటివ్
Systems మధ్య నెట్వర్క connection.
*కాబట్టి ఇది computer science రంగంలో పంపిణీ
వ్యవస్థల అధ్యాయానికి ఉపయోగ పడుతుంది .పంపిణీ
system ఘనన ప్రక్రియను పరిష్కరించడానికి
ఉపయోగిస్తాం .
ఇంకా ఇతర అర్ధాలు ఉన్నాయి.
మీరు internetలో శోధించినట్లైతే
అవి తెలుస్తాయి . అక్కడ వివిధ Independent కంప్యుటేషనల్
 institutionలకు స్థానిక memory ఉన్నాయని చెబుతుంది
. కాబట్టి , Independent computing
institutionలకు వారి సొంత స్టాటిక్ మెమొరీ కలిగి ఉంటుంది .
ఒక బ్యాక్ బోన్ Communication network పై సందేశం ద్వారా , ఒకదానితో ఒకటి సమాచారాన్నికమ్మ్యూనికేట్
 చేస్తుంది . కాబట్టి O.S
యొక్క ప్రాధమిక భావనను చూస్తే ప్రాససెర్
వివిధ సంభాషణల రేఖల ద్వారా ప్రతి ప్రాససెర్
ఉన్న విషయాలను స్థానిక మెమొరీకి ఒకదానితో
ఒకటి అధిక వేగం కలిగిన బస్సుల ద్వారా
చెబుతుంది .
distributed computingలో మనము వివిధ రకాలైన ఉదాహరణలను
చెప్పుకోవచ్చు.
అందులో ఇంటర్networking మొదలుకొని ఏ.టి.ఎం,బ్యాంక్
యంత్రాలు లేదా వివిధ బ్యాంక్ శాఖలు లేదా
వివిధ సహకారinstitutionలు మరియు వివిధ రకాల
పనులను ఎక్సిక్యూటింగ్ చేయు వరకు ఉన్నాయి.
అలాగే ఇంధులో intraనెట్ /work గ్రూప్స్
 కూడా ఉన్నాయి.
త్వరలో, computing వ్యవస్థ సంపూర్ణంగా
సర్వవ్యాప్త network అనుసంధానించబడిన
పరికరాలను కలిగి ఉండవచ్చు,లేదా మనము
ఈ సర్వవ్యాప్త అనుసంధానీచబడిన పరికరాలను ముంధే
కలిగిఉన్నాము.లేదా దీనిని మనము తాత్కాలిక
స్థాపన అని చెప్పవచ్చు .
ఈ రోజులలో మనము గమనించినట్లైతే, తాత్కాలిక networkస్
కలిగిన వివిధ రకముల networkస్
ఉన్నాయి.అందులో ఉదాహరణకు వెహిక్యులర్ అడ్-హక్ networkస్,అనగా స్మార్ట్ వాహనాలు
కలిసివస్తునప్పుడు వాటి యొక్క on బోర్డ్
unitస్ సమాచార వ్యవస్థ ద్వారా తాత్కాలిక
networkస్ ని ఏర్పరుస్తాయి
మరియు వివిద రకాలైన securityకు సంబంధించిన
విధులు, వినోదబరితమైనవి లేదా t.v కార్యక్రమాలను
నిర్వహిస్తుంది.
distributedSystemస్లో
విస్తృతమైన కంప్యుటేర్స్ని చూసినట్లైతే వాటిలో
ప్రథమంగా work స్టేషన్స్, server Systems మరియు పర్సనల్ ఆసిస్టన్స్ డివైసెస్ ఉన్నాయి.
work స్టేషన్ అనేది వినియాగదారుని
వద్ద computing కొరకు ఉపయోగించేవి.server
Systems అనేవి వనరులను మరియు
serviceలను అందించే కంప్యుటేర్స్.
పర్సనల్ ఆసిస్టన్స్ డివైసెస్ వైర్ లెస్  సమాచార వ్యవస్థ ద్వారా
System కి అనుసందానించబడిన హ్యాండ్ హెల్డ్
కంప్యుటేర్స్ మరియు ఎటువంటి సమాచార
వ్యవస్థలో అయినా ఉపయోగిస్తారు.
కనుక సాధారణంగా పైన payర్కొనబడినవన్నీdistributed
సిస్టెంస్ లో ఉంటాయి.
ఇంకా ఇంకో రకమైన అధిక network
సామర్ధ్యము మరియు ప్రొసెసింగ్Nodeస్ ఉంటాయి.
మనమిప్పుడు distributed computing యొక్క సాదారణ లక్షణాలు,ఉపయోగాలు
చూసినట్లైతే, వీటిలో ఒకటైన fault టోలరెన్స్ అంటే ఒకటి లేదా కొన్ని Systems
పనిచేస్తున్నప్పుడు, కొన్నిnodeస్
విఫలమైతే కొంచెం తక్కువ performance
తో మొత్తం System బాగానే పని చేస్తుంది
కానీ సెంట్రలైజేడ్ System
లాగా మొత్తం System విఫలమవ్వదు.దీనిని
fault టోలరెంట్గా చేయడానికి
చాలా విభిన్న పద్దతులు ఉన్నావా.
ప్రతిNode పాక్షిక పాత్ర పోషిస్తుంది:
ప్రతి computerకి పూర్తి System
గురించి limited,అసంపూర్ణమైన వీక్షణ ఉంటుంధి.ప్రతి
computer inపుట్ యొక్క ఒక్క భాగము
మాత్రమే తెలిసి ఉంటుంది.
ప్రతి consumerడు System లో ఉన్న
computing power మరియు storage
వనరులని మరియొక consumerలతో పంచుకోవచ్చు.
ప్రతిNodeకి చాలా పనులను కేటాయించడం
ద్వారా మొత్తం Systemకి load షేరింగ్
చేయడంలో సహాయ పడుతుంది.దీనిలోNodeస్ని చేర్చేటప్పుడు
కొంచుమ్ సమయము తీసుకుంటుంది.లేకుంటే అసలు సమయము తీసుకోకపోవచ్చు.ప్యార్లల్
computing అనేది distributed
computingలో ఒక భాగం
distributed Systems
యొక్క మరియొక అంశం ఏమిటంటే, application
స్వభావము ను బట్టి , వివిధ రకాల పనితీరును
బట్టి అంటే computing మరియుData తీవ్రతలను
బట్టి ఇది మనకు అవసరం అవుతుంది.
మరికొన్ని సంధార్భాల్లో, మనము ఏ వైఫల్యం లేనటువంటి
దృఢత్వం కలిగిన System కావాలనుకుంటాము.
చాలా సందర్భాలలో, మన ప్రాథమిక అవసరాలను
తీర్చుకోవాలనే ముఖ్య ఉద్దేశంతో ఈ distributed
Systems ని రూపొందించారు.
ఇప్పటికీ ఇంతటితో ముగిస్తూ, మన ఈ చర్చను
తదుపరి Lectureస్ లో కొనసాగిస్తాం.
ధన్యవాదములు.
వివరణ మరియు దాని పరిణామ క్రమం పై
చర్చను కొనసాగిస్తాము.
మనము మొదటి Lecture  చివరిలో distributed
 Systems  గురించి చర్చించుకున్నాం.
కాబట్టి, మనం ఈ Slideలో ఉన్నామని విశ్వసిస్తున్నా,
ముందుగా,ఈ distributed System 
అవసరం ఏమిటి?
అనేది చూద్దాం, మనం చర్చిస్తున్నట్లుగా;
దీనికి మూల కారకాలలో లో ఒకటి application
యొక్క స్వభావం మరియు performance
అంటే ,కొన్ని applicationలు computing
సంభందించినవి కావచ్చు లేదా మరికొన్నిData
కి సంభందించినవి కావచ్చు.
కాబట్టి, distributed computing అవసరం ఎంతో ఉంది. మరొక అంశం ఏమిటంటే
రోబస్ట్నెస్ , ముందు మనం చర్చించుకున్నట్లుగా
ఏ ఒక్కNode పనిచేయక పోయినా, మొత్తం System
 వైఫల్యం చెందకూడదు.
నా application  కి ఒక్క నోడే  వైఫల్యం
ఉండకూడదు.
ఎల్లప్పుడు System  పనిచేస్తూనే
ఉండాలి.
performance  తక్కువ స్థాయిలోఉన్నప్పుడు
కూడా, అది ఒక వైఫల్యం కాదు. వ్యవస్థ విఫలమైతే
కేంద్రీకృత Systems విషయంలో,ఏ ఒక్క
నోడే  పనిచేయకపోయినా మొత్తం System 
విఫలం అవుతుంది.
అయితే ఈ డిస్ట్రిబూటింగ్ computing  పని చేస్తూనే ఉంటుంది.
విఫలం అయినNodeస్  యొక్క పనిని మరొక
ఇతరNodeలు చేయవచ్చు.
అంటే, ఏదైనాNode  విఫలమైతే, దాని
విధిని ఇతరNode ద్వారా load చేయవచ్చని
లేదా భాగస్వామ్యం చేయగల వ్యవస్థగా
development చేస్తాం.
కాబట్టి, ఈ రకమైన టెక్నాలజీ, ఆల్goరిథంలు
distributed స్య్తెమ్ లో
development చెందుతాయి లేదా ఉపయోగించబడుతున్నాయి.
కాబట్టి, అనేక ఇతర distributed
 applicationలు కూడా ఉన్నాయి.
distributed  application
 అంటే, ఒక సాధారణ problemకు సంబంధించిన
ప్రోసెస్  సమితిని network ద్వారా
అనుసంధానించబడిన machineస్  కి
పంపిణీ చేసి దానిని పరిష్కరించడానికి
సమిష్టిగా కలిసి పనిచేయడం; మరొక అర్థంలో,
ఒక నిర్దిష్ట problem పరిష్కారానికి అన్నీ
application లు ఒకదాని తో ఒకటి సమన్వయం
చేసుకోవడం.
కాబట్టి, దీనిని మనం ఇలా కూడా చెప్పవచ్చు
; ఒక నిర్దిష్ట problemను పరిష్కరించడానికి
పనిచేస్తున్న వ్యక్తుల సమూహం అని . ఇది ప్రధానంగా
ఉన్నత శ్రేణి applicationలు development లేదా ఉన్నత
శ్రేణి కార్యాచరణ అవసరానికి ఉపయోగపడుతుంది,
అంటే, ఎక్కడైతే వేర్వేరు operationలు మీకు భిన్నమైన
serviceలను అందిస్తాయి, అక్కడ చివరిగా ఒక
ప్రత్యేకమైన , సంపూర్ణమైన ప్రక్రియను గుర్తించాము.
కాబట్టి, ఒక్క computing అంశమే కాకుండా , అనేకమైన
ఇతర విషయాలను, అంటే ఎవరెవరు దీని తో
పని చేస్తారు మరియు దీనిని ఉపయోగిస్తారు
అనేవి కూడా పరిగణలోకి తీసుకుంటాము.
కాబట్టి, వివిధ కోణాలు ఉన్నాయి, కానీ distributed
computing అనేది ఈ రకమైన
ప్రధాన అనువర్తనాల్లో ఒకటి. అనేక రకాలైన
applicationలు  ఇప్పటికీ client
 server  రకానికి చెందినవే , వీటి రీsource
 నిర్వహణ server  భాద్యత.
కాబట్టి, మనము దీనిని ఒక distributed
 వ్యవస్థగా చేయాలనుకుంటున్నాము.
here పీర్-టూ-పీర్ computing  అనేది నిజమైన distributed
computing  మార్పునకు ఒక
model.
కనుక , ఈ distributed computing  వైపు ఇతర ప్రేరేపిత అంశాలు లేదా ప్రేరణలు
ఉన్నాయి.
కాబట్టి, ఇది సాధారణంగా consumerలకు
ఉపయోగపడే వ్యక్తిగత serverలను వినియోగిస్తుంది
; client తనకు నిర్ధేశించిన serverని
ఉపయోగిస్తాడు.
కనుక, ఉపయోగించడం మరియు ఫలితాలు కొరకు,
ఒక server మరొక server కి ఒక client
గా పని చేస్తుంది, here, Systems
అన్నీ కూడా స్వంతంగా client-server
 model లాగే పని చేస్తాయి అయితే
అవన్నీ కూడా ఒక నిర్ధిస్టమైన application 
కొరకు పని చేస్తాయి.
మనం, పీర్ ప్రోసెస్  ఆధారిత ఒక సాధారణ
distributed applicationని కలిగి ఉంటాం.
కనుక, here వివిధ రకాల పీర్స్, మరియు
వాటిలో నడుస్తున్న వివిధ applicationలు
ఉన్నాయి; ఒక నిర్ధిష్టమైన ప్రక్రియ కొరకు ఈ
applicationలు ఒకదానితో ఒకటి సహకరించుకుంటాయి.
ఈ పీర్ ప్రక్రియల ఆధారంగా application
ఉన్నాయి.
కాబట్టి, ఇవి వేర్వేరు distributed
computing modelగా ఉన్నాయి,
మరొక ప్రజాదరణ పొందిన computing
రూపావళి grid computing.
grid computing యొక్క విభిన్న నిర్వచనములు
చాలా ఉన్నాయి.
వాటిలో కొన్నింటిని చూద్దాం.
ఇది ఒక సాంప్రదాయిక network, అనగా
ఎదైతే Systems  మద్యన Communication
 కి మాత్రమే ఉపయోగపడుతుందో, ఇది
దానిలా కాకుండా , Independent వ్యవస్థలకు సంబంధించిన
ఒక problemను పరిష్కరించడానికి ,ఆ network 
లోని అన్నీ computerస్ యొక్క ఉపయోగించని
రీsourceCycle  ని కూడా ఉపయోగిస్తుంది,
అంటే దీని అర్థం మనము ఒక నిర్ధిస్టమయిన
problemను పరిష్కరించడానికి కావలసిన ధృడమైనSystemలతో
 రూపొందించిన network  ని
కలిగి ఉన్నాము.
మనము , దీని యొక్క మరొక వివరణను చూసినట్లైతే
, grid computing  అనేది distributed
computing  యొక్క విర్చువలైజేషన్
 ని బల పరుస్తుంది మరియు ఒక System
ఇమేజ్  ని సృష్టించడానికి కావలసిన data 
resources  అయినటువంటి ప్రొసెసింగ్ network
, బాండ్విడ్త్  storage కపాసిటీ
 ని consumerనికి మంజూరు చేస్తుంది.
విస్తారమైన IT  applicationలని
 access  చేసుకోవచ్చు.
మరొక ముఖ్యమైన మార్గంలో మనం దీన్ని చూసినట్లైతే
; అనగా, ఇప్పుడు distributed computing modelను కలిగి ఉన్నాము , తర్వాత
మనం ఈ విషయాలపై మరొక system గ్రహించడం
లేదా వాస్తవీకరించడం అనేది ఈ cloud computing
model యొక్క ప్రధానమైన వాటిలో ఒకటి. మనము
నెట్ work లో అనేక వ్యవస్థలు కలిగి
ఉన్నాము , వాటికి వివిధ ప్రాసెస్ 
ఉన్నాయి, మనము మన అవసరాలకు తగినట్లుగా
వివరించుకున్న resources  ని కలిగిన ఒకటి
లేదా అంతకంటే ఎక్కువ Virtual machineస్
 ఉన్న ఒక System  కావాలనుకుంటున్నాం.
కనుక , ఇవి వేర్వేరు కారకాలను కలిగి ఉన్నాయి
మరియు grid computing అనేది computing
infrastructure  , ఇది విశ్వసనీయ,
స్థిరమైన, పరివ్యాప్త, computing
సామర్థ్యాన్ని అందిస్తుంది.
ఇతర అర్థంలో మనకు networkలో
లభించే resources  ఉన్నాయి.
మన రోజువారి జీవితంలో ఉపయోగిస్తువున్న
విద్యుత్ grid తో పోల్చుకుందాం,
విద్యుత్ gridలు నడుపుతున్నాము మరియు
మనము అనగా institutionలు లేదా గృహోపకరణలకు
లేదా విద్యుత్ పంపిణీ వ్యవస్థలు విద్యుథ్చ్చక్తిని
grid నుండి పొందడం.
ఈ power అనేది ఎక్కడో అందుబాటులో ఉంటుంది.
కాబట్టి, ఒక సందర్భంలో computing సారూప్యాలు
ఉంటాయి ఏవిదంగా అంటే ; consumerలు
లేదా client applicationల resource 
స్థావరాల యొక్క కొంత పరిజ్ఞానం లేదా పరిజ్ఞానం
లేకుండా అవసరమైన computing resource
 ని, Processor, storageData
applicationలని పొందవచ్చు.
అంటే ఇది ఒక resources  ని గుర్తించే
పద్దతి.
resources  ని ఎంచుకోవడం మరియు
computing grid పై ఉపయోగించడం.
కాబట్టి, here ఆలోచించాల్సిన విషయం మన సొంత అల్goరిథం
, పద్దతి మరియు మనకు ఏమి కావాలి ; resources
 అవసరం ఏమిటి?
ఇప్పుడు మనకు ఒక ప్రత్యేక computing
grid అనుమతిస్తే మనము ఆ grid పైనే
ఆధారపడి మన రిసోర్సెస్ ని , ప్రోగ్రామ్స్
ని  మరియు ప్రాససెస్ని  అమలు చేయాలి
మరియు కొన్ని వనరులను గుర్తించాలి.
కాబట్టి, grid అనేది PC, workస్టేషన్
, మొదలైనటువంటి computing
వనరులను Hybridization మరియు ఇది access చేయడానికి
అవసరమైన పద్దతులను తెలుపుతుంది.
కనుక , consumerడి అభిప్రాయం ప్రకారం
ఈ grid ని access చెయ్యడానికి ఒక పద్దతి
అవసరం.
మీరు grid computing లక్షణాలు చూస్తే.
ఇది ఒక సమాచారమే కాకుండా , data computing ద్వారా చాలా institutionలు వాటి resources
 ని సమర్థవంతంగా వినియోగించడం.
కాబట్టి, ఒక UG-PG తరగతుల computing lab
ను గమనించినట్లైతే, మనం ఆ resources
ని సమర్ధవంతంగా ఉపయోగించుకోవచ్చు, ఎలాగంటే , ఆ విధ్యార్థులు
ఎక్కువగా lab కు కేటాయించిన సమయమునే
ఉపయోగిస్తారు.
కనుక, మనం ఆ మిగిలిన సమయమును computing
grid  గా ఏర్పాటు చేసుకోవచ్చు.
దానిని, ఇతర పరిశోధనలకు computing ప్లాట్ఫారమ్గా
 ఉపయోగించవచ్చు.
కనుక , 100 PC లు ప్రతిదీ ఉత్తమంగా ఉంటుంది.
మనం ప్రాథమికంగా మరొక మిడిల్వేర్
అనే విభాగంతో వర్చువలైస్  చేయవచ్చు.
మనం దానిని ఉపయోగించ వచ్చు ఇంకొక వైపు
ఏమి జరుగుంతోందో పట్టించుకోవలసిన
అవసరం ఉండదు.
కాబట్టి, మన ప్రోగ్రాం  కోరుకున్న విధంగా,
ఒక నిర్దిష్ట పనితీరు స్థాయితో విశ్వసనీయంగా
నడుస్తుంది, ఇది మనకు కావాల్సినది.
ఇది ఉపయోగించని resources  ఉపయోగించడానికి
ఒక మంచి అవకాశం.
here అన్నీ రకాల స్థానిక communityల
Hybridization ఉంటుంది.
వివిధ రకాల వ్యవస్థలు అనగా, కొన్ని జీవసంబంధ
విజ్ఞాన శాస్త్రాల కొరకు కొన్ని grid
resources , కొన్ని ఆర్ట్స్ విజ్ఞాన
శాస్త్రాలు ,కొన్ని జన్యు పరిశోధనలకు
సంబంధించినవి.
computing మాత్రమే కాకుండా వాటికి కావలసిన
కొన్ని ప్రాథమిక ప్రక్రియలు కూడా
ఉంటాయి.
కాబట్టి, ఇంకొక భావనలో మనం మన దగ్గర resources
 ని purchase చేసి ఇంస్టాల్ ,
నిర్వహించకుండా resources  ని
కావాలనుకుంటాము.
అంతర్లీన విభాగాలు ఒకదానితో ఒకటి పరస్పరమ్
సహకరిస్తూ , consumerకు సులువైన పద్దతిలో
బదిలీ చేయబడాలి.
అంటే,మనకు ఒక consumerడిగా interface  కలిగి
ఉండి, మిగిలిన resources  గురించి గాని
మరి ఏ ఇతర అంశాల గురించి పట్టించుకోవలసిన
అవసరం లేదు. మనం ఎంత ఉపయోగిస్తామో అంతా
ఖరీదు వాళ్ళు తీస్కోవచ్చు కానీ వాళ్ళు resources
 ను, network  ని, services
 ని ఎలా నిర్వహిస్తారో తెలుసుకోవలసిన అవసరం
లేదు.
grid computing అవసరం ఎక్కువగా ఉందని
అర్థం అయ్యింది.
ముఖ్యంగా శాస్త్రీయ పరిశోధన శాఖ అనేది
ఒక పెద్ద consumerలని చెప్పవచ్చు, అందులో,
ప్రత్యేకంగాData అనాలిసిస్ ,
data ఎనలిటిక్స్ , విజువలైజేషన్,శాస్త్రీయ
శాఖల మధ్య పరస్పర సహకారం, ఈ రోజుల్లో
ఖండాంతరాలలో ప్రజలు అంతా పరస్పర సహకారంతో
కలిసి పనిచేస్తున్నారు.
computer Simulation  మరియు మోడలింగ్
మరొక ఉపయోగం; శాస్త్రీయ మరియు ఇంజనీరింగ్
problemలు మరింత సంcomplexగా మారాయి దీనికి మరింత
ఖచ్చితమైన పరిష్కారం అవసరం.
data విజువలైజేషన్ అనేది ఒక ముఖ్యమైన
అంశంగా మారుతోంది.
వినియోగింపబడని resources ని
వినియోగకరంగా చేయడం అనేది ఒక ప్రేరణాత్మక
విషయం.
మన దగ్గర చాలా వినియోగించని resources  ఉన్నాయి.
వాటిని ఉపయోగించేవిధంగా చేద్దాం.
ఈ విధంగా మనం cloud computing
వైపు మరొక అడుగు ముందుకు వేస్తున్నాం.
grid ని ఎవరు ఉపయోగిస్తున్నారు?
అంటే చివరకు, అక్కడ ఫిజిక్స్ application
లు వాతావరణ application
లు, మెటీreal సైన్స్ రియాక్టర్ applicationలు మొదలైన వాటికి grid 
అవసరం చాలా ఉంది.
విభిన్న రకాలైన gridలు ఉన్నాయి.
వాటిలో కంప్యుటేషనల్ grid ఒకటి,
దీనిని ఎక్కువగా computing 
కొరకు ఉపయోగిస్తారు.
రెండవదిData నిల్వ కొరకు ఉపయోగించే
data grid కావచ్చు.
మరొకటి కొలబోరేషన్ grid , ఇది
Systems  మధ్య మంచి సహకారాన్ని
అందించడంలో సహాయపడుతుంది; network gridల
వంటి ఇతర gridలు కూడా అందుబాటులో
ఉన్నాయి.
అధిక performance , fault tolerance
 కలిగిన Communication serviceలను అందిస్తుంది,
మరొక ముఖ్యమైన grid utility grid
 ఉంటుంది, ఇది ఒక వినియోగకరమైన
grid, దీనిలోData మరియు computing
సైకల్  ని పంచడంతో పాటుగా,
Software మరియు ఏ resources 
నైనా పంచుతుంది.
కాబట్టి, దీనిని utility grid అని అంటాము.
దీనిలో, వివిధ రకాల విభాగాలు ఉంటాయి.వీటన్నింటికి
grid ఒక కేంద్రం గా పనిచేస్త్తింది;
ఇది provider  గా ఉంటుంది.
ఆ విభాగాలలో కొన్ని ఈ grid ని ఉపయోగించే
యూసర్  కి సంభందించినవి.
మరికొన్ని గ్రూప్ కార్యకలాపాలను కలిగి
ఉన్న గ్రూపులు,చివరిగా వేర్వేరు site 
లు resources లభ్యత స్థానాలను
చూపించే వైవిధ్యమైన ప్రదేశాలు మొదలైనవి
ఉన్నాయి.
ఇవే కాకుండా ; విధాన నిర్వహణకు సంబంధించిన
problemలు మరియు వేటిని పంచాలి వేటిని పంచకూడదు
అనే ఇతర విషయాలు వీటిలో ముఖ్యమైనవి.
computing విషయంలో మరొక ప్రాముఖ్యం
పొందిన ముఖ్యమైన అంశం cluster computing.
ఒక cluster అంటే ఏమిటి?
cluster అనేది ఒక విధమైన ప్యారలల్
 లేదా distributed computing వ్యవస్థ, ఇది ఒక స్వతహాగా ఒకే
లక్ష్యంతో పనిచేసే computerలు
సమితి.
వీటిలో PC work స్టేషన్  లు లేదా SMPs ఆపరేటింగ్
System, అధిక పెర్ఫార్మెన్స్
ఇంటర్కనెక్టన్స్, మిడిల్వేర్ పారలల్
ప్రోగ్రామింగ్ వ్యవస్థ
మరియు applicationలు లు ఉంటాయి.
ఇవి cluster computing యొక్క విభిన్న భాగాలు.
ఒక computer యొక్క స్పీడ్  మరియు
రెలియబిలిటీ  కంటే అధిక స్పీడ్
ని మరియు రేయలియబిలిటీ  ని cluster
 అందిస్తుంది.
ఈ విలక్షణ clusterలు ఒక సాధారణ LAN కంటే
network యొక్క లక్షణాలను వేగంగాను
మరియు దగ్గరగాను మరియు ఎస్.ఎం.పిల
కంటే తక్కువగా Communication  ప్రోటోcall
 యొక్క లాటన్సి  ని కలిగి, తక్కువ
లూజ్లీ కపుల్డ్  గా ఉంటాయి.
వివిధ రకాలైన clusterలNode  లు ఉన్నాయి.
వీటిలో మొదటిది హై అవైలబిల్టీ 
లేదా ఫైలోవర్ cluster , దీనిలో ఏడైన
వైఫల్యం చెందినNode  ఉంటే దాని పని
చెయ్యడానికి resources  ఎక్కువ మొత్తంలో
అందుబాటులో ఉంటాయి.
రెండవది , load బాలన్సింగ్ cluster ,
here cluster పనిని సరి సమానంగా
అన్నీNodeస్ కి పంచుతుంది.
చివరిది , పారలల్/distributed ప్రొసెసింగ్ cluster
, దీనిని పారలల్ 
మరియు distributed  ప్రొసెసింగ్
 కొరకు ఉపయోగిస్తారు.
మనం ఒక సాధారణ cluster ని గమనించినట్లైయతే
. దానిలో అనేక రకాల clusterNode లు, వాటిని అనుసంధానించే network మరియు
దాని విభిన్న network వర్గీకరణ, వీటిని
ఉపయోగించడానికి వివిధ రకాల పద్దతులున్నాయి.
దీనిలో అనేక కార్యాచరణ ప్రయోజనాలు ఉన్నాయి;
వీటిలో System అవైలబిలిటీ , fault
tolerance, మరియు scalability
అంశాలు ఉన్నాయి.
O.S  మరియు cluster  నుంచి మనం ఆశిస్తున్న
application reliability  మరియు
అధిక పనితీరు ఉన్నాయి.
సాధారణంగా cluster అధిక పనితీరును అందిస్తుంది.
మనం distributed computing తో మొదలుపెట్టి grid , cluster
 మొదలైనవన్నీ నేర్చుకుంటున్నాం.
ఇవన్నీ కూడా utility computing కు ప్రేరణ.
utility computing లేదా utility
అంటే ఏమిటి?
utility అనగా మన దగ్గర కొన్ని resources
 ఉంటాయి వీటితో పాటు మరికొన్ని అవసరమవుతాయి,
మరియు మనకు అవసరమైనప్పుడు మనం వాటిని పొందగలుగుతాము.
ఇది మనం market  కి వెళ్ళి వస్తువులను
purchase చేయడం ,లేకపోతే railway ticket  ని ,airplane ticket  ని book  చేయడం
లాంటిదే.
వీటన్నింటికి మనకు ఒక interface 
అనగా ఒక మధ్యవర్తి అవసరం వుంటుంది.
కనుక, here మనం ఏచేస్తాం అంటే?
ఏ పనిని అయితే చేయించుకోవాలనుకుంటున్నామో ఆ పని ఎలా చేశారో
పట్టించుకోనవసరం లేదు, ఉధాహరణకి మన
ఇంటిలో plumbing చేయించాలనుకోండి,
utility  కార్యాలయానికి call చేసి ఈ విషయం
చెప్తాము.
here మనతో మాట్లాడే వ్యక్తి గురించి
కూడా మనం పట్టించుకోనక్కర్లేదు లేదా మాట్లాడుతున్న
వ్యక్తికి plumbing గురించి తెలియక పోయిన
అతను లేదా ఆమె ఆ పని గురించి తెలిసిన
వాళ్ళకి call ని కలుపుతారు.
కానీ ఒక consumerనిగా మనకు అక్కడ ప్రయోజనం
జరిగిందా లేదా అనేది కావాలి.
కాబట్టి, మనకు resources  ఆవరమైనప్పుడు
అవి ఉన్నాయా లేవా అనేది మాత్రమే చూసుకోవాలి.
అలాగే మనం ఈ distributed computing , cluster మరియు ఇతర రకాలైన computing
system చూస్తే, వారు కూడా consumer
అవసరాన్ని బట్టి కొన్ని ప్రయోజనాలను
అందించడానికి ప్రయత్నిస్తారు.
consumerనికి వంరుల నిర్వహణ భాధ్యత
తగ్గుతుంది.
కాబట్టి, మనము నేర్చుకోబోయే cloud computing అమలు చేసేదే ఈ utility computing
.
ఇది ఒక , service provisioning model ,
ఇందులో service provider  ,consumerనికి
కావలసిన computing resources 
ని , infrastructure  ని అందుబాటులో
ఉంచి వాటికి ఒకే రకమైన ఖరీదు కాకుండా
వినియోగించిన దానిని బట్టి ఖరీదు కడతారు.
కనుక, here utility  అనే పదం ఎలెక్ట్రికల్
power  లాంటి services  కి
దగ్గర policy.
దీనిని బట్టి చూస్తే ఇది నిలకడ లేని consumerని
అవసరాలకు అనుగుణంగా, flat rateల
ఆధారంగా కాకుండా వనరుల వినియోగం ఆధారంగా
ఖరీదు వసూలు చేస్తారు మరియు కొన్నిtimes
ఈ modelను మనం ఎంత వినియోగిస్తే అంతా
చెల్లించడం అంటాం లేదా pay as యు go
model  అంటాం.
మనం విద్యుత్ serviceలను చూస్తే.
ఒక meter ఉంటుంది.
మనం ఏదైనా విద్యుత్ ఉపకరణాలను అంటే ఎలక్ట్రికల్
లైట్ లేదా మైక్రోవేవ్ ఓవెన్ లేదా ఎయిర్ కండీషనింగ్ అయి ఉండవచ్చు
లేదా computer అయి ఉండవచ్చు, మనం
వినియోగించే వనరులు ఏమైనప్పటికీ, వినియోగాన్ని
బట్టి ఎలెక్ట్రిక్ అథారిటీకి 
లేదా ఎలెక్ట్రిక్ power అథారిటీ నిర్ణయించిన ఖరీదు చెల్లిస్తాము.
here , మనకు ఈ power  ఎలా ఉత్పత్తి
అవుతుందో పట్టించుకోవలసిన అవసరం లేదు. ఇవి మన
ఇంటికి ఎలా వస్తున్నాయో కూడా తెలియదు . మనము
ఉపయోగించే serviceను సరిగ్గా ఉపయోగించుకోవడంలో
మనం శ్రద్ధ వహించేది ఏమిటంటే అది meter
. మరో ప్రసిద్ధ ఉపయోగం
టెలికాం serviceలు ముఖ్యంగా mobile
serviceలు.
దీనిని ఒక utility  గా ఉపయోగిస్తాము,
telephone లేదా mobile service provider నుండి connectionని తీసుకుని ఉపయోగిస్తాము
తెర్వత ఎంత ఉపయోగిస్తామో అంత charge model
యొక్క model ఆధారంగా చెల్లిస్తాము, అది
post paid  లేదా prepaid కావచ్చు, service provider
ఎవరన్నది మనం పట్టించుకొనవసరం లేదు.
here మనకు కావలసిన సౌకర్యాలు , call
సౌకర్యం ,సందేశాలను పంపడం మరియుData
serviceలకు సంబంధించినData video services
 లాంటివి , ఇవ్వన్ని ఉంటే మనం ఖరీదు చెల్లించడానికి
సిద్ధంగా ఉంటాం.
కాబట్టి, మన అవసరాలను బట్టి serviceను ఎంపిక
చేసుకుంటాం, ఇది కూడా ఒక utility
service .
ఇది కూడా ఒక meter model  మరియు
pay as you go model .
కాబట్టి, ఈ model హఠాత్తుగా ఖచ్చితంగా
ఒక రోజు utility computing గా రూపాంతరం చెందుతుంది.
కాబట్టి, ఇది అన్ని distributed
computing  నుండి grid,
cluster  cloud computing
వరకు ఉద్భవించింది.
కాబట్టి, ఇది ఒక మంచి చిత్ర రూపం మరియు
policy, ఇందులో వివిఢ రకాల IT  resources
 ఉన్నాయి.
పై చిత్రం లో చూపినవిదంగా మనకు resources 
అవసరం ఉన్నప్పుడు tap  ని తెరిచి
ఉంచుతాము.
అవసరం లేనప్పుడు ఈ tap ని మూసి
ఉంచుతాము.
utility computing అనేది కూడా Virtualization
రూపంగా చూసినట్లైతే, ఒక computer 
సామర్ధ్యం కంటే అధిక మొత్తం లో storage
 మరియు computing  సామర్ధ్యం అందుబాటులో
ఉంటుంది.
కాబట్టి, మనము అపారమైన resources  మన
అవసరన్ఈ తగినట్టుగా ఉన్నాయి అనుకుంటే
వాటిలో అlimitedమైన computing ,
networking  మరియు applications
 మొదలైనవి.
మనం దీనిని విధ్యుత్ సరఫరా తో పోల్చి
చూస్తే , power  ని ఉపయోగించేటపుడు
, కొంత వ్యవధి అంటే ఎక్కువ కిలో watts
 లేదా మెగా watts  ఉపయోగించకూడదు
అనే limitedి ఉంటుంది.
లేకపోతే వాస్తవంగా మనం అlimitedమైన resources
 ఉన్నట్లుగా భావిచ్చి వాటిని
ఎంచుకుంటాము.
ఎంచుకున్న resources  కి వాటి వాడుకను
బట్టి ఖరీదు చెల్లిస్తాము.
అదేవిధంగా, computing లేదా టెలికాం
లేదా mobile serviceలకు కూడా, మనం ఒక నిర్దిష్ట
ఫైల్  ను download చేస్తున్నప్పుడు
, మనకు అవసరమైన బ్యాండ్విడ్త్ అందుబాటులో ఉందని
అనుకుంటాము.
ఇది 10 KB లేదా 100 KB ఫైల్ కావచ్చు లేదా అది
100 MB ఫైల్  గా ఉండవచ్చు, resources  అన్నీ
ఉన్నాయి మనము ఖరీదు చెల్లించాల్సిన
అవసరం ఉంది, కానీ మనం దాన్ని ఉపయోగించుకోగలగాలి.
utility computing లో మనము చూడాలనుకుంటున్నది
ఏమిటంటే, computing అనేది infrastructure
 computing resource  నుండి
మొదలుపెట్టిన hardware లేదా ఎక్కడైతే మనం
కంపైల్  చేస్తామో ఆ ప్లాట్ఫారమ్
services  కావచ్చు, లేదా కొన్ని ప్రత్యేకమైన
data నిల్వ సామర్ధ్యంకు సంభంసించునవై కావచ్చు
లేదా మ్యాథమేటికల్ Simulation టూల్  కావచ్చు.
వీటన్నింటినీ మనం ఎంత వరకు వినియోగిస్తే
అంతా ఖరీదు చెల్లిస్తాము.
కాబట్టి, ఇది ఒక భారీ అపారమైన resources
storage .
ఇది power grid  లో ఉపయోగించే
Tier నిర్ణయ modelను ఉపయోగించడం జరుగుతుంది.
ఇది ఒక ముఖ్యమైన అంశం.Data Center
Virtualization లేదా provisioning
అనేది మరొక ప్రధాన అంశం. అనగా, మన దగ్గరి
నుంచి కూడా resource ను వర్చువలైజ్
చెయ్యొచ్చ . మనం ఒక System  ని ,అంటే
అందులో 8 GB Processor, 16 GB లేదా 128 GB RAM మరియు
అధిక సామర్ధ్యం కలిగిన Hard Disk  అనుకరించాలని అనుకున్నాము.
మరియు ఒక ప్రత్యేక సైంటిఫిక్  Simulation
ను అమలు చేయాలనుకుంటున్నాము.
కనుక మొత్తం resource  పరిమాణం నుండి
ఒక resource  ని విర్చువలైజ్ 
చెయ్యాలనుకుంటున్నాం.
ఆ resources  సమూహం లోనే మరొక
వినియోగ దారుడు వేరొక resource  ని
Virtualize చేయవచ్చు.
కాబట్టి, ఇదంతా కూడాData Center Virtualization
మరియు provisioning
కలిగి ఉండి, resource  వినియోగ problemను
ఛేదిస్తుంది, మన వద్ద చాలా resources
 ఉంటే మనం వాటిని సరఫరా చెయ్యొచ్చు.
ఎలాగంటే వాటిని మనం Outsource  చేయ్యొచ్చు
మరియు Software maintenance  ని కొందరికి లేదాData storage
ని మరికొందరికి Outsource  చెయ్యొచ్చు.
కాబట్టి, మనం Web services
ని outsourcing చేయవచ్చు,
గతంలో మాదిరిగా కాకుండా, ప్రాథమికంగా మనం
data డ్రివెన్ architecture  నుండి
service డ్రివెన్ architecture కి మారాము.
మనంData కంటే services కి
ఎక్కువ ప్రాముఖ్యత ఇస్తాం.
కాబట్టి, here వినియోగం కి మరియు Automation
కి అపారమైన పరిధి ఉంటుంది.
మన దగ్గర వివిధ రకాల resources  కలిగి
ఉంటే appపుడు మొత్తం resources  ను
Automate చేయడానికి అనుమతించే work
flow ని నిర్మించగలము.
ఈ utility computing యొక్క మరొక అంశం
ఉంది.
ఒక ఉదాహరణ On-Demand Cyber infrastructure
; అంటే మనము ఉద్యోగ నియమకానికి
లేదా విద్యార్థులకు పరీక్షలను నిర్వహించడం
కొరకు, ప్రత్యేక infrastructure
 వేర్వేరు విభాగాలలో కలిగి
ఉండాలనుకుంటున్నాము లేదా ఇంట్లో అయి
వుండవచ్చు.
appపుడు మనకు exam రాయుటకు అనుకూలిన్చే విధంగా
,Virtual resources  ఉండేవిధంగా
ఒక Cyber infrastructure  అవసరం.
మనము ఈ రకమైన Cyber infrastructureను
ని కలిగి ఉంటాము, కొన్ని సందర్భాల్లో
, సాధారణ కార్యక్రమ నిర్వహణకు, కాన్ఫరెన్స్
లాంటి వాటికి మనము ఒక సాధారణ Cyber
infrastructure  ని కలిగి
ఉండాలనుకుంటాము, నిజ జీవితంలో జరిగే
వైపరీత్యాల నిర్వహణ కోసం ఒక infrastructure
 కలిగి ఉంటాము, here resources
 అవసరము ఒకదానికొకటి వేర్వేరుగా ఉండవచ్చు,
ఇలాంటి resources  ని పెట్టుకోవలసిన
అవసరం లేదు. కానీ IIT Kharagpurలో మేము కాన్ఫరెన్స్స  నిర్వహిస్తాము,
అవి ఒక నెలకు ఒకటి లేదా రెండు జరుగుతాయి
వాటిలో కొన్ని work షాప్  లు, మొదలైనవి,
వీటికోసం ప్రత్యేకించి infrastructure
అవసరం లేదు. మనం మన అవసరాలకు తగిన విధంగా
ఒక infrastructure ని ఏర్పరుచుకుని
దానికి ఖరీదు చెల్లించవచ్చు.
అలాంటి వాటిలో ఒకటి డిమాండ్ Cyber infrastructure
.
here మరొక అంశం ఏమిటంటే here provider
 లేదా service provider
మరియు consumerడు ఉంటారు, ఆ రెండింటికి
వేర్వేరు అవసరములు ఉన్నాయి మరియు మనకు
విభిన్న modelలు ఉన్నాయి మరియు నిర్వాహక
problemలు ఆ రెంటినీ కలిపి ఉంచుతున్నాయి.
అందులో ఒకటి pricing , ఏ Tier అయితే మనం
చెల్లిస్తామో , సారూప్యతను తీసుకుంటే, మనం ఏ
service provider అయితే అనుకూలమైన
Tierకి servicesని అందిస్తాడో మరియు
అధిక data services ని అందిస్తాడో
, ఆ provider ని ఎంచుకుంటాము.
ఇందులో మెరుగైన రేటు లేదా మెరుగైన పనితీరును
అందించే mobile Service providerను ని ఎంపిక చేయాలనుకుంటాం.
ఈData services  పై ఎవరైనా performance
 గురించి పట్టించుకోనక్కరలేదు, కొంతమంది messaging
 మరియు calling  services 
ని కావాలనుకుంటారు.
అది వారి సొంత విషయం .
కనుక ఇది pricing model , తర్వాత
here service level agreements  ఉంటాయి . అంటే ఇది ఒక serviceా స్థాయి
ఒప్పందం , అందులోDataను ఉపయోగించడానికి
మరియు store  చేయాలని అనుకుంటే
resource  లభ్యతకు సంభందించినవి మరియు
security అంశాలకు సంభందించినవి మదలైనవి ఉంటాయి.
here ఎవరైనా మనData ఉపయోగించి
లేదా చూడటం జరగకూడదు.
అందువల్ల, అక్కడ security అంశాలు మరియు
అందులో ఓకటైన denial ఆఫ్ service  వంటివి ఉండకూడదు, security అంశాలలో access
mechanisms మొదలైనవి ఉంటాయి.
చివరిగా application sizing 
అవసరం అవుతుంది; కొన్ని application
 కి టెరాByట్లData ఉంటుంది,
అలాంటి applicationలను  మెగాByట్స్
dataDataతో విశ్లేషించలనుకుంటున్నాను.
కాబట్టి, మనకు పెద్దదైన application అవసరం
లేదు, కానీ మన అవసరాన్ని బట్టి, ఈ application
ని sizing చేయాల్సిన అవసరం
వుంది.
వివిధ రకాల payమెంట్ models 
ఉన్నాయి.
వాటిలో, flat rate, tiered మొదలైనవి.
scale  ని, commitment ని మరియు payమెంట్
frequency అద్గారంగ వివిధ
consumerల కొరకు విభిన్న pricing
models  ఉన్నాయి.
utility computing యొక్క లక్షణం
అదే విధంగానే ఉంటుంది, Tierల యొక్క model
కేవలం Tier యొక్క providerల వ్యక్తీకరణ;
దీని అర్థం, రిసోర్సెస్  ఎంతవరకు కేటాయించాలో
అనేది provider  నిర్ణయిస్తారు.
ఇందులో రిస్క్స్  కూడా చాలా ఉన్నాయి;
ఈ utility computing లో ఉన్న లోపాలలో
మొదటిదిData బ్యాకప్.మనData ఎక్కడో
ఒకచోట ఉంటుంది, ఏమైనా క్రాష్  ప్రమాదం
జరిగినప్పుడు,Dataను మూడవ పక్షంలో store
 చేస్తారు మరియు ఆ మూడవ పక్షంలోని
service provider కూడా వ్యాపారం
నుండి బయటికి వెళ్లి పోతే ఏమి జరుగుతుంది.
ఇలాంటప్పుడుData security అవసరం అవుతుంది.
మన data ను ఎవరైనా చదివినప్పుడు లేదా
institutionల మధ్య పోటీతత్వం ఉన్నప్పుడూ ఈ భధ్రత
అవసరం అవుతుంది.
SLA ను నిర్వచించడం మరొక పెద్ద problem.
ప్రతిఒక్కరూ వారికి నచ్చిన విధంగా అగ్రీమెంట్
 ను నిర్వచించాలని అనుకుంటున్నారు
మరియు వేర్వేరు provider  మరియు consumerల
మధ్య ఈ agreements  తయారు చెయ్యడానికి
ఒక ప్రామాణిక విధానం ఇప్పటికీ లేదు, agreements
 విఫలం అయితే మనము చెల్లించిన
రుసుము ను ఎలా తిరిగి పొందడం అనేది కూడా
సరిగా లేదు. ఇవన్నీ న్ని cloud computing పరిణమించడానికి కారకాలు.
కాబట్టి cloud computing అనేది, NIST నిర్వచనం
"సర్వ వ్యాప్త , అనుకూలమైన , మనం అమర్చుకోగలిగే
computing resources సమితిని,servers ,storage ,application
 మరియు services ) అవసరానికి మేర
త్వరిత గతిన అతి తక్కువ నిర్వహణ బాధ్యత
తో serviceలను అందించేది."
ఇది అన్నింటి గురించి చెబుతుంది.
దీనిని మనం అనుసరించే లేదా గౌరవించటానికి
ప్రయత్నిస్తాము.
ఈ నిర్వచనం ఏం చెప్తుందంటే , భారీ resources
 సమితిని సులభతరంగా తక్కువ నిర్వహణతో
ఉపయోగించడం మరియు విడుదల చేయడం.
మనం ఇప్పటికీ వరకు నేర్చుకున్న computing
పరిజ్ఞానం నుండి చూస్తే, ఇది అకస్మాత్తుగా
వచ్చింది కాదు. ఇది కొన్ని అంశాల నుండి
పరిణమించింది.
మనము ఈ computing ప్రపంచాన్నివివిధ
కోణాలలో చూస్తున్నప్పుడు మరియు కొన్ని ప్రాథమిక
modelలతో విభిన్న రకాలైన ప్రయోజనాల
కోసం computingను సులభతరం చేయడానికి
ప్రయత్నిస్తాము.
వీటిలో ముఖ్యంగా pricing models
, SLA models , security model
 నిర్వహణ ఉంది; అనగా, మేము వేర్వేరు
విషయాలను ఉంచాలనుకుంటున్నాము మరియు computing
ని ఒక service గా అందించాలనుకుంటున్నాం.
మనమిప్పుడు నేటి చర్చను సంపూర్ణం
గా ముగుస్తున్నాం.
దీని ఆధారంగా మనము ఇతర అంశాలను కొనసాగిస్తాము.
కాబట్టి, మనము ఈ విషయాలలో కొన్నింటిని payర్కొనడానికి
కావలసిన figures  , materials
 మదలైన వాటిని కొన్నింటిని వివిధ
వనరుల నుంచి తీసుకున్నాము, మనము అన్ని సూచనలను
ఉంచటానికి ప్రయత్నించాము మరియు మనము ప్రత్యేకంగా
దీన్ని విద్యాపరమైన ప్రయోజనం లేదా విధానాల
కోసం ఉపయోగిస్తున్నాం అంతేకాని వ్యాపారపరంగా
వాడుతున్నది కాదు. మనము నేటి చర్చను
ముగిస్తున్నాం మరియు రాబోయే ఉపన్యాసాలలో
మనం ఇతర అంశాలను లేదా ఇతర అంశాలపై
వేర్వేరు అంశాలని పరిశీలిస్తాము, cloud
computing యొక్క విభిన్న అంశాలు మరియు
వేర్వేరు లక్షణాలు ఏమిటి ప్రయోజనాలు
appరయోజనాలు గురించి తెలుసుకుంటాం.
ధన్యవాదాలు.
స్వాగతం.
ముందుగా ఈ cloud computing 
యొక్క ప్రాధమిక లేదా పునాదిపై మనం చర్చను
కొనసాగించి, ఆపై మరిన్ని వివరాలకు
వెల్దాము.
మనం గత తరగతి లో NIST cloud computing
ని ఎలా నిర్వచించింది అన్న విషయాన్ని చర్చించాము
,NIST cloud computing  ను ఎలా నిర్వచించిందంటే,
cloud computing అనేది సర్వవ్యాప్తికి
తోడ్పడుతున్న,సౌకర్యవంతమైన,డిమాండ్కి తగినట్లు ఆకృతీకరించుకోదలచిన
computing వనరుల భాగస్వామ్య పూల్ని కలిగిఉంటుంధి.
కాబట్టి, అది త్వరగా పొందుపరచగలదు.
అనగా ఏదో గ్రహించటానికి మరియు విడుదలైన నిబంధనలను
అవసరం లేనప్పుడు అది తక్కువ నిర్వహణ
కృషి లేదా serviceా ప్రదాత పరస్పర చర్యతో విడుదల చేయగలదు.
అనగా, ఒక customer లేదా consumer
లేదా service consumerనికి అది అవసరమైనప్పుడు
దానిని సరఫరా చేయగలదు అలాగే అనవసరమైనప్పుడు
సరఫరా నిలిpayయగలదు.
మనం cloud computing కి అవసరమైన లక్షణాలనుపరిశీలిస్తే,ఇది వరకే కొన్ని చూశాము,అందులో
మనకు అవసరమైనవి, on డిమాండ్ సెల్ఫ్
Service .
ఇది ఒక service మరియు ఇది డిమాండ్ ఉన్న
స్వీయ service. అలాగే బ్రాడ్ network
access: ఇది చాలా ముఖ్యమైనది;
దీని అర్థం మనకు తగిన network ప్రాప్యతను
కలిగి ఉండాలి ఎందుకంటే?
here వనరులు పంపిణీ చేయబడుతున్నందున,
అవి వివిధ భౌgoళిక స్థానాల్లో ఉంటునందున,వాటిని
సమీకరించి consumerనకు అందించడం.
మరొక విషయం resource పూలింగ్: అంటే,
నా అవసరాల కోసం ప్రాథమికంగా వనరులను సమీకరించగలిగి
మరియు మనకు ఒకే భౌతిక మరియు virtual వనరులను ఒక బహుళ అద్దెదారు  modelగా ఇస్తుంది,
డైనమిక్ కేటాయింపుతో ఒక Service provider
నుండి ఒక windows ఉపsystem అనేక
hardware స్పెసిఫికేషన్లు మరియు ఇవి వేరే సాఫ్టవేర్
స్పెసిఫికేషన్లతొ కలిగి ఉండాలనుకుంటున్నాను.
ఒకే serviceా providerల నుండి ఎవరైనా Linux లేదా
Ubuntu ఉపవ్యవస్థ వనరుల విషయాలను తెలుసుకోవలనుకుంటారు.
అందువల్ల వనరుల పూరింపు మరియు నిర్వహణ,resource
పూలింగ్ యొక్క ముఖ్యమైన అంశాలు.
మిగిలిన లక్షణాలను చూసినట్లైతే అందులో
మెషర్డ్ Service: ఇది ఎలాంటిదంటే
నేను ఉపయోగించే దాని కోసం నేను చెల్లిస్తాను
అనటం లాంటిది.
నేను ఉపయోగిస్తున్న దాన్ని కొలుస్తారు.
కాబట్టి, ఇది కొలవబడిన serviceలు మరియు
మరొక ముఖ్యమైన అంశం ర్యాపిడ్ ఎల్యస్టిసిటీ: అనగా, నేను అవసరం ఉన్నప్పుడు పైకి
మరియు క్రిందకు వెళ్ళవచ్చు.
నేను ఒక ఉదాహరణకు నేను ఒక 4 GB RAM అవసరమైయే
application వాడుతున్నాను,ఇప్పుడు మరింతDataను లేదా
మరింత applicationను load చేయాల్సి ఉంది,
కాబట్టి నేను4GBను 8GB RAMగా పెంచాలనుకుంటున్నాను.
దాని కోసం నేను మరింత వనరులను తీసుకురావాలి.
కాబట్టి, నేను వేగంగా ఏర్పాటు చేయగలగాలి
మరియు ఈ రకమైన స్థితిస్థాపకత అక్కడ ఉండాలి; ఇది
నేను అవసరం ఉన్నప్పుడు వనరులను పెంచవచ్చు,తగ్గించవచ్చు.
కాబట్టి, అది cloud యొక్క ముఖ్యమైన లక్షణాలలో
ఒకటిగా ఉండాలి.
సాధారణంగా cloud computing 
ప్లాట్ఫారమ్లో లేదా cloud Service provider
 అందించే అనేక సాధారణ లక్షణాలు
ఉన్నాయి.
మనము చర్చించినటువంటి,మ్యాసివ్ స్కేల్,రెసిలింట్
computing,హోమోజెనీటి, నాకు వనరుల వెనుక
ఎలాంటి వైవిధ్యమైన వాతావరణం ఉన్నదో
అవసరంలేదు నాకు ఒకే విధమైన విషయం కావాలి.
సాధారణంగా వనరులు భౌgoళికంగా వ్యాప్తిచెంది
ఉంటాయి అదే జియోగ్రాఫిక్ డిస్ట్రిబ్యూషన్.
ఒక ప్రధాన అంశం వర్చువలేజేషన్ . Service ఓరియంటేషన్ అనేది ఒక ముఖ్యమైన అంశంగా ఉంది.here
serviceలు ఒకదానితొ ఒకటి సంబంధం కలిగి ఉంటాయి.
కాబట్టి, ఇది service ధోరణే కానీData
ధోరణి కాదు, వివిధ రకాలైన serviceలు ఉండవచ్చు.
దీని గురించి service ఆధారిత నిర్మాణంలో
చూద్దాం.
కాబట్టి, మనము ఒక service providerను
కలిగి ఉండటమంటే, అక్కడ ఒక Service
consumerడు ఉండవచ్చు మరియు అక్కడ ఒక రిజిస్ట్రీ
service లేదా కేటలాగ్లు ఉంటాయని చెప్తాము.here
మనం ముందుగా రిజిస్ట్రీలో ఏ ఏ serviceలు ఉనాయో తెలుసుకొని
Service provider నుండి పొందగలము.ఇది
telephone డైరెక్టరీ లాంటి విషయం, here
నాకు వేర్వేరు రకం పసుపు రంగు payజీలు
మరియు ఇతర విషయాలు ఉన్నాయి మరియు ఒకవేళ
నేను ఒక నిర్దిష్ట వ్యక్తి నుండి మొదలుపెట్టి
ఏదో ఒక నిర్దిష్ట చర్య వరకు వెతకలి
అనుకున్నా ఉదాహరణకు , నేను హోమ్ డెలివరీ
serviceలను వెతుకుతున్నా.
సో, నేను హోమ్ డెలివరీలో ఉన్న విషయాల గురించి
తెలుసుకొని దాని telephone ద్వారా
connect చేస్తాను.సో, here ఒక కేటలాగ్
లేదా రిజిస్ట్రీ లేదా Service provider
మరియు consumerడు,అన్ని ఒక Service ఓరియెంటెడ్
ఆర్కిటెక్టర్ని ఏర్పాటు చేస్తున్నాయి.దీని
గురించి మళ్ళీ మనం కొంచెం ఎక్కువ చూద్దాము.
ఈ cloud computing  యొక్క ప్రధాన
అంశాలలో ఒకటి service ఆధారిత నిర్మాణాన్ని
గుర్తించడం.అలాగే మరొకటి తక్కువ Tier
Softwareను కలిగి ఉండటం.
ఇది ఒక మల్టీ టెనెంట్ రకం, ఇది Software
యొక్క మొత్తం వ్యయాన్ని consumerని కోసం
తగ్గిస్తుంది మరియు ఆధునిక securityని ఇస్తుందని
ఆశించచ్చు.విభిన్న security విషయాలు ఉన్నాయి.
మనం మరి కొన్ని విషయాలను చర్చిస్తాము, కాని
స్థిరమైన security ఉంటుందని భావిస్తున్నాము.
security అనగా ఎవరైనాDataని భద్రపరచడం
మాత్రమే కాదు,Data cloudలో ఉన్నట్లయితే
ఆDataను మనం కోల్పోలేము.
కానీ ఇది నా స్వంత Systemలో ఉంటే Systemను
అమర్చడం నా బాధ్యత.
అదేవిధంగా, నేను కొన్ని applicationలు
చూసినటైతే; cloudలో ఒక మెయిల్ application
గురించి చూద్దాం.ఒక వేల అది నా సొంత మెయిల్
server మరియు మెయిల్ రిలే మొదలైనవి కలిగి
ఉంటే, appపుడు నిర్వహణ నా భాద్యత.
కాబట్టి, విభిన్న అంశాల విషయాలు ఉన్నాయి.
here వివిధData ప్రిసర్వేషన్ కోసం
లేదాDataపై దాడులు అడ్డుకోవటానికి
సంబంధించిన నియంత్రణను access చేయడానికి
ముందస్తు security లక్షణాలను అందించబడుతాయి.
మనం వివిద cloud Service modelస చూస్తే, తదుపరి మనం మరిన్ని వివరాలకు
వెళ్దాము.
మనము చూసినట్లైతే మొదటిగా Software
యాస్ ఎ Service.
here cloud infrastructure  పై consumerనికి
అమలుదారుడి యొక్క applicationను వినియోగించుకునేలా
చూడటం.
మనం ఈ రోజుల్లో వేర్వేరు రకాలైన విషయాలను
ఉపయోగిస్తున్నాము, ఉదాహరణకు వర్డ్ processing,
internetలో ఒక స్ప్రెడ్ షీట్ వంటి అంశాలని
ఉపయోగించడం మొదలైనవి . Webలో ఉన్న అంశాలు;
దీని అర్థం, ఆ అనువర్తనాలు cloudలో ఎక్కడో
ఉంటాయి మరియు మనం ఆ applicationని ఉపయోగించి
మరియు నాData స్థానిక యంత్రంలో నిల్వ చేయబడుతుంది
లేదా అదే సమయాల్లోData ఇతరData serviceా
ప్రదాతలో నిల్వ చేయబడుతుంది . అంటే, మనకిక్కడ ప్రాధమికంగా
ఎక్ష్టర్నల్ cloud తో interface అవసరం
మరియు ఇప్పుడు అది ఒక Software Serviceగా
పొందగలం.
ఇప్పుడు software ఒక వ్యవస్థగా ఎక్సిగ్యుట్
అవుతుండాలి లేదా కొన్ని ప్లాట్ఫారమ్లో
కంపైల్ చేయబడాలి.
ఒక consumerగా నేను దాని గురించి
బాధపడటం లేదు మరి నేను ఏమి చెప్పాలనుకున్నానంటే
ఒక system ఉపయోగించడం కోసం ప్రాథమికంగా
మొజిల్లా, internet ఎక్స్ ప్లోరర్, క్రోమ్
మొదలైన వంటి Web బ్రౌజర్ల interface
అవసరం.
నాకు Software ఉపయోగించడానికి
జ్ఞానం కలిగిఉండాలి, అది వర్డ్ Processor
కానీ, అది ఒక శాస్త్రీయ అనుకరణ కానీ, అది
ఒక టెక్స్ట్ processing కానీ, కొన్ని ఇతర
applicationలు కానీ; ఏదో ఒక మ్యాథ్మేటికల్
application అయి ఉండచ్చు.
ఇది ఒక Software యాస్ ఎ Service.here మనం Softwareని ఒక serviceగా పొందుతాము.
మరొక విషయం ఏమిటంటే infrastructure
యస్ ఎ Service; దీని అర్ధం,
నేను నా మౌలిక సదుపాయాలను గుర్తించాలనుకుంటున్నాను
. ఇది ఒక infrastructure యస్ ఎ Service.
ఇలా, నేను ఒక యంత్రంయొక్క ప్రత్యేక వివరణని
గుర్తించాలి ప్రస్తుతానికి నాకు 4GB RAM ,చాలా మెగాహెర్జ్
Processor మరియు చాలా Hard Disk
ఉండాలి.
కాబ్బటి, ఇది ఒక మౌలిక సదుపాయము, నేను నా
డెస్క్ మీద మొత్తం system తెలుసుకుంటున్నాను.
నేడు నాకు ఒక 4GB RAM అవసరం అవచ్చు, రేపు వేరే
పని కోసం ఒక 64GB RAM అవసరం కావచ్చు, తర్వాత
రోజు ఒక 2 GB RAM అవసరం కావచ్చు.
ఈ విధంగా నాకు asథిరమైన అవసరాలు ఉన్నట్లైతే
నేను infrastructure పై ఆధారపడుతాను.here
infrastructureని serviceలా అందించే providerలు
ఉంటారు.
ఈ 2 IA'S మధ్య, Software యస్ ఎ Service మరియు
infrastructure యస్ ఎ Service మధ్య,
మనకు platform యస్ ఎ Service
ఉంది. కాబట్టి, ఇది కొన్ని development
కార్యక్రమాల కోసం వేదికను అందిస్తుంది.
నేను ఇంకొక విషయాన్ని ఉపయోగిస్తున్న Software
కావాలి, నేను infrastructure కలిగి ఉన్నాను, నేను
OS లేదా OS ను infrastructureతో load చేస్తాను, నేను
ఇతర applicationను రన్ చేసి పరీక్షించి
మరియు ఇతర విషయాలు load చేస్తాను; లేకపోతే
నాకు platform అన్నది serviceలా అవసరం.here
Service provider, platformని Serviceగా
అందిస్తున్నారు.
ఇది నాకు ప్లాట్ఫారమ్గా ఉపయోగించడానికి
అనుమతిస్తుంది.
ఇవి మూడు ప్రముఖమైన cloud యొక్క service
modelస ఇవే కాకుండా ఇతర service modelలు
ఉన్నాయి ఉదాహరణకి data యస్ ఎ Service
ఇదిDataను నిక్షిప్తం చేస్తుంది.ఇలాంటివి
మరిన్ని ఉన్నాయి.
మనం ఈ stackని చూస్తే.
మనకి క్రింద ఉన్నది ప్రాథమిక మౌలిక సదుపాయాలు,
ఇది మరియు ఇది ఒక service వలె ప్లాట్ఫారమ్
మరియు ఒక Softwareగా Software ఉన్నట్లుగానే
ఉంది. virtual machine చాలా మౌలిక సదుపాయంగా
చెప్పగలగడం వంటి వివిధ రకాలైన మౌలిక
సదుపాయాలు ఉండవచ్చు.
serverలు, నిల్వ, load బాలన్సర్, network
ఈ వివిధ రకాలైన అవస్థాపనలు, మరియు మీరు అలా అనిపించవచ్చు
వంటి అవస్థాపన వివిధ ఇతర రకం ఉండవచ్చు.
నేను external పరికరాలు మరియు ఇతర విషయాలు
ఒక అవస్థాపన మరియు విషయాలను రకం కలిగి
చేయవచ్చు దీనిలో సైన్ లాగవచ్చు.
పైగా మేము ఒక వేదిక వంటి వేదిక చూడండి
ఉన్నప్పుడు రన్time,Dataబేస్, Web server,
development సాధనం ఏదో ఒక అమలు వేదిక
ఉంది , development వేదిక ఒక రకమైన ఇసుక
బాక్స్ రకాన్ని పర్యావరణం మరియు రకాలైన రకాలుగా
చెప్పవచ్చు.
సో, ఈ ఒక service ఒక వేదికగా మరింత, మరియు ఆ పైగా
నేను ఈ software CRM, ఇమెయిల్, వివిధ
వర్చ్యువల్ డెస్క్tap, ఇష్టపడ్డారు వివిధ
గేమ్స్ ఉన్నాయి కాబట్టి ఇష్టపడ్డారు ఈ సాఫ్ట్
వేర్ గ్రహించడం ఒక service ఒక SaaS లేదా Software
కలిగి ఈ cloud మౌలిక సదుపాయాలకు మరియు
పాసాలకు పైన మరియు పైకి నడిచే విషయాలపై.
ఇప్పుడు ఎలా ఎక్కడ?
ఈ భాగం cloud provider ముగింపులో చాలా భాగం.
కాబట్టి, కొందరు providerలు Iaas అందించవచ్చు,
కొంతమంది PaaS ను అందించవచ్చు, కొంతమంది SaaS, IaaS లేదా
మనం అవస్థాపనను యావరేజ్గా చెప్పవచ్చు కొంత
మంది సమ్మేళనంగా అందించవచ్చు, కానీ
మనం client కోణంలో చూస్తే, client
ఎలా access చేస్తారు?
సో, ఉత్తమ లేదా సార్వత్రిక మార్గంగా Web బ్రౌజర్
ఉంది లేదా Web client ఒక ఇతర విషయాలు ఉన్నాయి
నేను ఈ రకంగా access చేయవచ్చు , mobile
అనువర్తనాలు కలిగి ఉన్నాయి, సన్నని
ఖాతాదారులు ఉన్నారు, టెర్మినల్ ఎమెల్యూటరు
మరియు ఇతరవి ఉన్నాయి.
కాబట్టి, ఈ interface ద్వారా client
cloudతో interface చేస్తారు.
ఇప్పుడు వేర్వేరు రకాలైన model modelలను
చూధ్దాము.మొదటిది private cloud
inధులో cloud infrastructureని ఒక institution మాత్రమే
ఒంటరిగా నిర్వహిస్తుంది.
ఉదాహరణకు windows server హైపర్-వి.
రెండవది community cloud .here ఒక
ప్రత్యేక లక్ష్య సాధన కోసం cloud
infrastructureని వివిధ institutionలు ఉపయోగించుకుంటాయి.
తర్వాతది public cloud .ఈ cloudలో
ప్రతి ఒక్కరూ cloudని వినియోగించే అవకాశం
ఉంది. ఉదాహరణకు Google డాక్స్,స్ప్రెడ్
షీట్,......మొదలైనవి.
చివరగా hybrid cloud .ఇందులో రెండులేదా
అంత కంటే ఎక్కువ cloudల 
సమ్మేళనంగా చెప్పవచ్చు.
ఇప్పుడు, మనం మరింత భిన్నంగా వెళ్దాము.
cloud మరియు వర్చురైజేషన్ కొంతవరకు చేతిలో
చేతిలాగా చూస్తాం మనం ఈ చిత్రంలో చూస్తే
అక్కడ మనం దీన్ని Virtualizeడ్ లేదా
వర్చ్యువలైజేషన్ stack అని అంటాము.
చివర్లో hardware యొక్క బేర్ మెటల్
ఉంది నాకు ఒక మిడ్వేవేర్ ఉంటే, నాకు వేర్వేరు
వాస్తవిక వస్తువులను సృష్టించుటకు అనుమతించును.
కాబట్టి, మనము వేర్వేరు హార్డువేర్ కలిగి
ఉన్నామని చెప్తాము.
ఇది వివిధ network పై వేర్వేరు వ్యవస్థలు
ఉంటాయి.నా చివరి లక్ష్యం ఏంటంటే ఒక
16GB వర్చ్యువల్ mission windows పై పని చేయడం
లేదా లైనక్స్ పై నడుస్తున్న ఒక 64GB
RAM machine అన్నీ కూడా చివరిలో ఉన్న hardwareని
ఉపయోగించి వాటిని వివిధ virtual machineలగా
తయారుచేస్తుంది . ఇప్పుడు, ఈ విభిన్న
వర్చ్యువల్ missionలను తయారుచేయుటకు నేను
సమిష్టిగా గుర్తించబడుతున్నాను, మనం VMM లేదా వర్చ్యువల్
mission మానిటర్ లేదా హైపర్ కవచం మధ్య
అనుసంధానిస్తమ్ . కాబట్టి, ఈ హైపర్విజర్
ప్రాథమికంగా నాకు ఈ వివిధ రకాలైన యంత్రాలు
అనుకరించడానికి అనుమతిస్తుంది.
కాబట్టి, మనం వాస్తవికత stackకు చూస్తే
మనం ఒక వాస్తవికీకరణ చేయాలనుకుంటున్నదానిని
నేను కోరుకున్నదానికి ఒకదానిని లేదా callపనికీకరణం.
ఇప్పుడు cloud మరియు విర్చువలేజేషన్లో
virtual work స్పెసెస్ ఉన్నాయి virtual
work స్పెసెస్ అంటేఇది బాగా అమలు చేయబడిన
ప్రోటోcallను ఉపయోగించడం ద్వారా అధికారిక
ఖాతాదారులకు డైనమిక్గా అందుబాటులో ఉంచగల
ఒక అమలు వాతావరణాన్ని సంగ్రహించడం కాబట్టి,
నా ప్రత్యేకమైన ప్రాజెక్ట్ కోసం నేను పర్యావరణం
అవసరమవుతున్నాను, అది development పర్యావరణ
విజువలైజేషన్ ఎన్విరాన్మెంట్, computing పర్యావరణం
మరియు నేను డైనమిని ఉత్పత్తి చేస్తాను
లేదా institution దానిపై పని చేయడానికి డైనమిక్గా
ఉత్పన్నమవుతుంది.
మరియు అది 14 రోజుల లేదా ఏదో ఒక స్వల్పకాలిక
ప్రాజెక్ట్ కావచ్చు మరియు ఇది ప్రాథమికంగా
గ్రహించారు.
ఆ 14 రోజులు మొత్తం వస్తువులని purchase
చేయడం బహుశా ఒక ఖరీదైన వ్యవహారం, కానీ నేను
external ప్రపంచం నుండి మీకు చెల్లించే లేదా
మీరు public cloud నుండి మరియు బహుశా
ఒక పరిష్కారం నుండి సదుపాయం కల్పించాను.
కాబట్టి, విభిన్న వర్చ్యువల్ missionలలోకి
గ్రహించటానికి ఇంకొక కారకమైన విషయం వర్చ్యువల్
mission మాత్రమే ఉంది; ఆ తరువాత వర్గపు
యంత్రాల యొక్క వేర్వేరు వర్గం ఉండవచ్చు,
ఇది మేఘాలయ గురించి మాట్లాడటం వంటి వాడుకదారులచే
ఉపయోగించబడుతుంది, virtual missionల
యొక్క మూడు వర్గాలతో మనం వర్చ్యువల్ missionల
యొక్క వివిధ వర్గాలను తెలుసుకుంటాం.
వస్తువుల లభ్యతపై.
మరియు infrastructure API, hardware సపోర్ట్
infrastructure మొదలైన
ప్లగిన్లు అందిస్తుంది.
కాబట్టి, ఇది వివిధ infrastructureలకు
connect చేయడానికి API ను అందిస్తుంది.
కాబట్టి, మనం విజువలైజేషన్ వద్ద వాస్తవంగా వేర్వేరు
అంశాలని చూస్తాము.
తద్వారా మనం తరువాతి ఉపన్యాసాలలో చూద్దాము.
మనం దేని గురించైతే మాట్లాదుతునమో దాన్ని
చూసినట్లైతే.
వర్చ్యువల్ mission టెక్నాలజీ మనకు బహుళ
వర్చ్యువల్ mission ఒకే భౌతిక యంత్రంపై
అమలుకు అనుమతిస్తుంది.
కాబట్టి ఇది నా hardware.
సో, అది ఒకే యంత్రం కాదు అంటే ఒక యంత్రం
మాత్రమే కాదు, నేను రెండు పది 4GB వ్యవస్థలు
కలిగి ఉంటాను లేదా నేను కొన్ని సమర్థవంతంగా
40GB విషయాలను కలిగి ఉండవచ్చని చెప్పినట్లుగా,
యంత్రం యొక్క జంట కలిసి ఉంటుంది, మూడు
లేదా రెండు 16GB మరియు ఒక 8GB నిజానికి మీకు
జరిగే ఈ వాస్తవీకరణకు కొన్ని అవసరం ఉన్నాయి
అన్నీ డివిజన్ చేయలేరు.
కాబట్టి, ఇది 40GB మీరు రెండు 16GB లోకి డివైడ్
చేసుకోవచ్చు.
కాబట్టి, మనకు అవసరమయ్యే వర్చ్యువల్ mission
మానిటర్, హార్డువేరును అనుకరించటానికి
అనుమతిస్తుంది మరియు నేను విభిన్న వర్చ్యువల్
missionలను కలిగి ఉన్నాను మరియు గెస్ట్ OS యొక్క
భావన, విషయాలపై పునఃపరిమాణం చేద్దామ్.
here, గెస్ట్ OS లైనక్స్ కావచ్చు, ఇతర గెస్ట్
OS ఉండవచ్చు, ఇతర గెస్ట్ OS మరియు వివిధ రకాలైన
విషయాలను మరియు విషయాలపై నడుస్తున్న ఈ applicationలు
భిన్నంగా ఉంటాయి; మరియు ఈ virtual
machine కొన్ని భౌgoళిక ప్రదేశాల్లో
ఎవరైనా ఉపయోగించుకోవచ్చు, ఈ virtual machine
ఎవరైనా ఇతర భౌgoళిక ప్రాంతాల్లో మరియు
అందువలన న మరియు అందువలన కోసం. కాబట్టి,
వ్యక్తిగత consumerడి ప్రయోజనం కోసం యంత్రం
అంటారు.
కాబట్టి, Virtualizationలో వేర్వేరు వర్గీకరణలు
ఉన్నాయి, ముడి శారీరక పనితీరుకు దగ్గరగా
Virtualization కోసం ఒక పనితీరు వంటి
విషయాలను చూద్దాం.
ప్రముఖ virtual machine మానిటర్ లేదా
హైపర్విజర్ కొన్ని Xen మరొక VM వేర్ ఉంది.
వర్చ్యువల్ missionల యొక్క ప్రయోజనాలు,
భౌతిక హార్డువేరు అందుబాటులో లేని
రన్ ఆపరేటింగ్ సిస్టం వంటివి, కొత్త మెషీన్స,
బ్యాకప్ యంత్రాలను తయారు చేయటం సులభం,
ఈ virtual machineతో గ్రహించగలిగిన విషయాలు
ఉన్నాయి.
cloud సోర్సింగ్ ఎందుకు ముఖ్యమైనది?
మొదటిది అన్ని ఉన్నత స్థాయి/ తక్కువ Tier
providerలను ఉపయాయోగించడం.
కాబట్టి, నేను ఒక విషయం చాలా వనరులను
కలిగి ఉంటుంది.
అంతేకాక, మీరు వస్తువులపై చౌకైన serviceలను పొందుతున్నప్పుడు
ఆర్ధికవ్యవస్థ ఒక ముఖ్యమైన పాత్రను
పోషిస్తుంది.
మేము ఒక ప్రత్యేక lectureలో చూద్దాము,
ఈ ఆర్ధికవ్యవస్థ అనేది ఎల్లప్పుడూ
cloud ఎకనామిక్స్ చెప్పినదే మరియు
ఇది ఎల్లప్పుడూ ఉపయోగకరంగా ఉందా లేదా మేము ప్రయోజనకరమైన
మొదలైనవి ఉన్నప్పుడు అక్కడ గురించి ఆలోచించడం
అవసరం.
ఎప్పుడైనా ఎప్పుడైనా Web బ్రౌజరు ద్వారా
access చేయవచ్చు.
ఈ మొత్తం computing నా ప్రయోగాత్మక serviceలు
కోసం నేను ఎప్పుడైనా serviceలకు ఏ రకమైన ఔషధ
పద్ధతి.
నా serviceలకు పరపతి మరియు విషయాలకు here
ఆందోళన లేదు, మరియు వేగంగా scalability
పెరుగుతున్నందున ఖర్చు మరియు load
భాగస్వామ్యం పెరుగుతుంది.
scalability చాలా వేగంగా ఉంది నేను
వేగంగా స్కేలబుల్ చేయవచ్చు.
స్థానిక IT లపై దృష్టి సారించాల్సిన అవసరం
లేదు. కాబట్టి, మీ మౌలిక సదుపాయాలన్నీ
ఎక్కడ ఉన్నాయో చూడాలి; మీరు ఒక అంశం నుండి
పరపతి లేదా వనరులు ఉన్నప్పుడు తీవ్రమైన
ఆందోళనలు కూడా ఉన్నాయి, ఒక ముఖ్యమైన ఆందోళన
అనేది పనితీరు reliability మరియు serviceా స్థాయి
ఒప్పందాలు.
వాటిలో కొన్ని ఒప్పందాలు సంతకం లాంటి serviceల
విశ్వసనీయ ఒప్పందాల problemలు, వీటిని
గౌరవించాడా, గౌరవించబడలేదా, లాంటి అంశాలు ఉంటాయి.
data మరియు service పారామితులను ఆందోళన చేసే problemలు
నా cloudలో ఉన్నData యొక్క ఆందోళనను
చెపుతున్నాయి, ఒకవేళ cloud లో ఉన్న తరువాత
నేను రాస్తాను, cloud లో ఉన్న ఒక నివేదికను
నేను వ్రాస్తాను ఈData secure,
పాడు చేయకూడదు మరియు ఇప్పటి వరకు ఉండకూడదు,
మరొక problem ఉంది, ఇది service పరామితి
కూడా ఉంది, అందులో 90 శాతం లేదా 95 శాతం
లభ్యత అని వారు ఎలా చెబుతారు.
ఆ పారామితిని ఎలా చూసుకోవాలి; ఆవిష్కరించడం
ఎలా నేను చూస్తున్న సంసార విషయాలు, సరైనవి.
problemలు లేదా application లక్షణాలు మరియు ఎంపికలు
ఉన్నాయి.
కాబట్టి, ఇది కొన్నిtimes నేను cloud providerల
మధ్య పరస్పర problemల గురించి నేను కలిగి
ఉన్నాన లేదా అనే దానిపై ఉన్న problemలే
లేదా నేను అనుకూలీకరించిన ఎంపికను కలిగుందా,
. అందుల్లో, ఒక providerను purchase చేసే serviceలు
కూడా ఉన్నాయి, ఎందుకంటే ఒక inఫర్మేషన్ provider
నుండి hardware వంటి infrastructure
వంటి కొన్ని infrastructure providerను purchase
చేయడం వంటివి.
API యొక్క ప్రమాణీకరణ లేదా మాదిరి problem
ఏమంటే అది సబ్బు లేదా విశ్రాంతి రకాలైన
serviceలేదా, మేము serviceా ఆధారిత నిర్మాణం
మరియు కోర్సు యొక్క security goప్యత, security
సమ్మతి, reliability, పోటీతత్వం, అపాయం
యొక్క problemలు మేము ఒక service యొక్క ఈ విధమైన
purchase చేసినప్పుడు ప్రధాన ఆందోళన.
ముఖ్యంగా మేము కొన్ని missionలు complex
లేదా నా రోజు నేటి అవసరం కోసం ఆ విషయాలు
purchase ముఖ్యంగా ఇది కీలకం.
cloud storage ఎందుకు వేరుగా ఉంచుతున్నాం
అంటే ఇది చాలా ముఖ్యమైన పాత్ర.
సమయం నిల్వ చేయడానికి మనము కొన్ని నిల్వ
అంశాలను చూద్దాము, కానీ ముఖ్యమైన అంశం
ఏమిటంటే, service consumerలకు లేదా consumerలకు
చాలా ముఖ్యమైనది ఎందుకంటే ఇది సరైనది.
సో, డెస్క్tap computerలు, mobile ఫోన్లు లేదా
ఇతర internet అనుసంధానించబడిన పరికరంలో తాత్కాలికంగా
కాష్కిDataను రిమోట్గా నిల్వ చేయడానికి
అనుమతించండి.
కాబట్టి, మాDataను ఒక serviceగా ఉంచడం కోసం
మాకు అనేక serviceలను ఉపయోగిస్తున్నDataతో
మునిగిపోతుంది.
సో, amazon EC2, S3 వంటి విషయాలు ఈData serviceలు
అక్కడ బాగా తెలిసిన ఉదాహరణలు ఉన్నాయి.
ఒకదానిని పునఃప్రారంభించుటకు కొన్ని ప్రయోజనాలు
తక్కువ computer వ్యయం, కుడివైపున
ఉన్న ఒక ప్రధానమైన అంశాలు తక్కువ computer
ఖర్చు తక్కువ కాదు అని చెప్పాలి.
మెరుగైన పనితీరు నేను మొత్తం Tierను
మెరుగుపరుచుకుంటాను, ఎందుకంటే నేను అధిక
Tierగా purchase చేస్తున్నాను; కోర్సు యొక్క తగ్గిన
Software, నేను ప్రత్యేక Software
etcetera purchase లేదు వంటి. ఇది appడేట్
అవ్వబోతోంది నవీకరణ ఉంటే software
నవీకరణలను అనుకుందాం; డాక్యుమెంట్ ఫార్మాట్
అనుకూలత మెరుగుపరచడానికి, అంతర్ముఖం ఉంటే మీరు
ప్రసంగ మంచి మీరు ప్రసంగించారు ఉండాలి.
అlimited theoretically అlimited నిల్వ, నేను
చెల్లిస్తాను మరియు నేను నిల్వ పొందండి,
data reliabilityను పెంచుతుంది, ఇది
సరైన రిడెండెన్సీతో పంపిణీ చేయబడిన విషయాల్లో
నిల్వ చేయబడుతుంది.
అందువల్ల, అదిData, అది విశ్వం, విశ్వం
మరియు సమాచారం ప్రాప్యతగా ఉంటుందని అంచనా వేయబడుతుంది,
నేను ప్రతి పాయింట్ వద్ద సమాచారాన్ని
access చేయవచ్చు, వ్యవస్థలు మరియు
Software యొక్క తాజా వెర్షన్ అందుబాటులో
ఉంటుంది; మీరు ఒకData వివిధ applicationలు
కలిగి ఉన్నప్పుడు సులభంగా సమూహం సహకారం;
పరికర Independent నేను వివిధ రకాలైన పరికరాల
నుండి access చేయవచ్చు.
కొన్ని అన్ని మంచి పాయింట్లు ఉన్నాయి
కొన్ని పిట్ లోపాలు లేదా కొన్ని ఆందోళనలు
లేదా appరయోజనాలు, network connectivity
అయిన తక్కువ వేగం connectionతో బాగా
పనిచేయదు.
ఫీచర్ limitedం కావచ్చు.
కాబట్టి, నేను కస్టమైజ్డ్ పర్సనల్ విషయం మీద
పొందగలిగిన కొన్ని విషయాలలో నెమ్మదిగా
ఉంటుంది ఎందుకంటే చివరకు, ఈ సమయం కేటాయించడం
జరుగుతుంది.
data నిల్వ నిజంగా ఎంత సురక్షితమో లేదో
అన్న ఆందోళనలు ఉంటాయి; నిల్వ చేయబడినDataను
కోల్పోవచ్చు, ఒకవేళ క్రాషవ్వినట్లయితే
లేదా provider నష్టపోయే అవకాశమున్న విషయాల
నుండి బయటికి పోతుంది.
cloud నిజంగా అధిక పనితీరు computing
వ్యవస్థలు కాదు. కాబట్టి, cloud
అధిక పనితీరును అందిస్తుందని అనుకుంటే, అక్కడ
HPC రకాన్ని అందించలేకపోవచ్చు మరియుDataబేస్ అమలు
చేయబడినDataబేస్ connectivityని కలిగి
ఉన్న API యొక్క అనేక సాధారణ భావనలు లేదా
connectivityలు ఉన్నాయి.
కాబట్టి, మనము ఇప్పుడు hereితో నిలిపివేద్దము
మరియు మనం తరువాత Lectureలలో వివిధ
architectureల గురించి పరిశీలిద్దాము.
ధన్యవాదాలు.
ఈ విషయాల పై స్థాయి వీక్షణ చూస్తే, మనకు
ఆఖరిలో ఏం ఉంటుంది,మనము దేనికోసం చూస్తున్నామో
,అందులో ఒకటి ఉపయోగించే యూసర్ లేదా మొత్తం
క్లౌడ్ కంప్యూటింగ్, ఇది మేము కొన్నివినియోగదారుల
సంభంధించి వ్యాపార లక్ష్యాన్ని సాధించడానికి
ధోహదపడుతుంది.. ఇది నిర్మాతకు సంబంధించి
వ్యాపార లక్ష్యంగా ఉండవచ్చు లేదా క్లౌడ్
కంప్యూటింగ్ యొక్క మొత్తం ఫ్రేమ్వర్క్
కావచ్చు.
కాబట్టి, కొంత వ్యాపార లక్ష్యాలు అనేవి
ప్రధానమైనవి.
తరువాత, మనకు నాణ్యతా లక్షణాలు మరియు నిర్మాణ
వ్యూహాలు లేదా ప్రాథమిక నిర్మాణ చట్టం ఉన్నాయి.
కాబట్టి, మీరు ఎగువన ఉన్న లక్ష్యాన్ని
చూస్తే, ప్రధానంగా మేము చూస్తున్నదిఏమిటి,
ఏమిటంటే సంస్థకు మొత్తం ఖర్చు 
ఎంత,వాటదారులు ఎవపు, వాటాదారు హోదా
సంతృప్తి, వివిధ ప్రమాణిక మార్కెట్
షేర్లుతో పోలిక, ఆవశ్యత, మొదలైనవి.
కాబట్టి, ఇది CSP తరహాలోని మొత్తం వ్యాపార లక్ష్యం
మరియు ఈ వ్యాపార లక్ష్యాన్ని సాధించడానికి
,పరిశీలించి మరికొన్ని పారామీటర్లను లెక్కించి,దిశానిర్ధేశం
చేయాల్సి ఉంది.ఇక్కడ మనము సరిగ్గా నిర్వహించాల్సినవి
చెప్పాలంటే, లభ్యత, స్థితిస్థాపకత, ఇంటర్పోపెరాబిలిటీ,
భద్రత, స్వీకరించదగ్గత, పనితీరు, వినియోగం
మరియు నిర్వహణ వంటివి.
ఇప్పుటి వరకు చూసాం కదా,ఒక్కసారి ఒకటి,రెండు
ఉపన్యాశాలకు వెనకకు వెళితే , ఎక్కడ క్లౌడ్
కంప్యూటింగ్ యొక్క ప్రాథమిక నిర్వచనం
ప్రారంభించబడింది.
కాబట్టి, మనము , అది ఎలా అందుబాటులో ఉందో,
ఎలా సాగేది, అది ఎలా పరస్పరం ఉంటుంది
అనే అంశాల కోసం వెతుకుతున్నాం.
, కనుక ఇవి ప్రధానమైనవి.. ఈ లక్షణాలు ప్రాథమికంగా
ఈ వేర్వేరు క్లౌడ్ విఫణిలో తన వ్యాపార
లక్ష్యాన్ని నిర్వచించడానికి సేవా ప్రదాతను అనుమతిస్తుంది.
చివరకు, సాధించడానికి ఈ వివిధ కొలిచిన
సేవలు లేదా వ్యాపార లక్ష్యాలు, ప్రాథమిక
నిర్మాణ వ్యూహాలు లేదా నిర్మాణ వీక్షణ
ఉండాలి.
కాబట్టి, పరిగణించ దగ్గ అవసరాలు , సరిగ్గా
ఏకమవుతుందో లేదో, ఇది ఒక స్థితిలేని
రూపంగా ఉందా,ఇది భౌగోళిక వ్యాప్తి
చెందిన పలు పరికరములు ఉన్నాయి అని మనము
ఆలోచిస్తున్నాము సో, వారు వదులుగా
జత, వైవిధ్యమైన, మేము విషయం లోకి తీసుకుని
ఏమి ఉండాలి విస్తృత నెట్వర్క్ యాక్సెస్
కుడి విషయాలు మధ్య ఒక ఇంటర్కనెక్ట్
మరియు సజాతీయత విధమైన ఉంది. కాబట్టి, క్యాచింగ్
విధానం ఏమిటి.
కాబట్టి, ధృవీకరణ అవ్వాల్సినది ఏమని
చెప్పుకోవాలో, అది దావా ఆధారంగా ప్రమాణీకరణ
అనంతరం, నిర్మాణ పద్ధతుల యొక్క అనేక
ఇతర అంశాలు ఉన్నాయి.
ఇప్పుడు, మీరు ఈ విధమైన విషయాలను ఎక్కడైనా
చూస్తే ఇతరవి ఏ రకమైన సేవ మోడల్లో కనిపించవచ్చు,
నేను చెప్పినట్లుగా మౌలిక సేవా మోడల్
తీసుకుంటే, కొన్ని అంశాలు నాటకం లోకి
వస్తాయి, నేను PaaS చెప్పినప్పుడు మరికొన్ని అంశాలు
నాటకంలోకి వస్తాయి మరియు మేము SaaS లేదా
ఏ ఇతర రకం మోడల్ కలిగిఉండొచ్చు.
కాబట్టి, అభివృద్ధి చెందుతున్నప్పుడు
ఏ నిర్మాణ దృక్పధాన్ని ప్రతిపాదించినా
ఇది ముఖ్యమైనదిగా మారుతుంది.
కాబట్టి, ఈ గౌరవంతో దృష్టిలో ఉంచుకొని,
మేము ఈ క్లౌడ్ ఆర్కిటెక్చర్లో ప్రాథమిక పరిశీలన
ఏమిటి అని చూస్తాం.
కాబట్టి, మీరు క్లౌడ్ కంప్యూటింగ్ నిర్మాణం
యొక్క ప్రధాన నిర్మాణ బ్లాక్ను చూసినట్లయితే,
ఒక టెక్నాలజీ నిర్మాణం, XaaS స్టాక్ ప్రకారం
నిర్మిస్తోంది.
క్లౌడ్ కంప్యూటింగ్ పధార్ధాలను,క్లౌడ్
సేవలు మరియు భాగాలు, మిడిల్వేర్ మరియు
కమ్యూనికేషన్ మరియు నిర్వహణ మరియు భద్రతలను
రూపొందించడాలను అమోదించడం.
కాబట్టి, ఇవి వాస్తుకళాపూరిత సాంకేతిక పరిజ్ఞానం
యొక్క సాంకేతిక లక్షణం.
విస్తరణ ఆపరేషన్ నిర్మాణం యొక్క కొన్ని
విషయాలు ఉన్నాయి.
నాఫెడరల్ అవసరం ప్రకారం నామొత్తం డేటా , ప్రభుత్వ
సంబంధిత కార్యకలాపాలకు అవసరమయ్యే నా దరఖాస్తులు
దేశ భూభాగంలో ఉండాలి.
నేను హోస్ట్ లేదా ఏ అప్లికేషన్ లేదా
విషయాలు బహిరంగంగా చేయొచ్చు.
ఇలా, నేను ఒక మెయిల్ సేవ కలిగి ఉంటే, మెయిల్
డేటా, మెయిల్ సర్వర్ మొదలైనవి మా దేశం
యొక్క భౌగోళిక సరిహద్దు ప్రాంతంలోనే ఉండాలి,
కాబట్టి ఒక విషయం చట్టపరమైన సమస్యలు
కూడా ఉండవచ్చు.
ఆపరేషన్ మరియు పర్యవేక్షణ వంటి లావాదేవీల సమస్యలు
ఉన్నాయి.
కాబట్టి, కార్యాచరణ వ్యూహంగా ఎలా ఉండాలి,
ఇది ఎలా పర్యవేక్షిస్తుందో, ఈ XaaS స్టాక్లు ఇతర
విస్తరణ ఆపరేషన్ నిర్మాణం ఎలా చేస్తైయో.
ఈ విధంగా, మీరు ఈ విలక్షణ XaaS విషయాన్ని గమనించినట్లయితే,
ఉన్న ఈ సేవలలో PasS,SaaS కంటే ఏది తగ్దింది.
ఇప్పుడు, మీరు ఈ నిర్మాణ భాగాన్ని లేదా ప్రాథమిక
బిల్డింగ్ బ్లాక్ను చూస్తే, అందులో నిల్వ
మరియు అవస్థాపన మరింత ఉంటుంది.
కాబట్టి, ఈ నీలం రంగు ఉంది; అప్ లో విషయం
ఈ కుడి అప్లికేషన్.
మరియు క్లయింట్ అవస్థాపన ఈ అనువర్తనం సంకర్షణ
ఇది ఉన్నాయి; మధ్యలో మధ్యస్థం లేదా మనం
చెప్పేది ఏమిటంటే, PaaS,ప్లాట్ఫారమ్లో
సేవలు క్లౌడ్ రన్టైమ్ గ్రంధాలయాలు మరియు
ఇతర విషయాలు బయటకు వస్తాయి.
కాబట్టి, ఏ క్లౌడ్ కంప్యూటింగ్ అంతర్గ్హత
నిర్మాణం అయినా అది పబ్లిక్, ప్రైవేటు,
బహిరంగ మూలం, అనుకూలీకరించబడినాయినా, మనకు ఈ రకమైన పరిపూర్ణతను
కలిగి ఉన్న ఇతర ప్రదేశాలలో చూడవలసిన అవసరం ఉంది.
మరియు వినియోగదారుడికి వర్తకులు లేదా కస్టమర్
వర్సెస్ ప్రొవైడర్ యొక్క దృక్కోణంగా
చూస్తే, ఐఏఎస్ఎస్ మరొకసారి ఐటీ ఆపరేషన్
రకంలో ఐటి వాస్తుశిల్పి ప్రధానంగా ముఖ్యమైనది.
వినియోగదారుని అప్లికేషన్, నిర్వాహకుడు etcetera
అనేది చాలా ఉపయోగకరంగా ఉన్న వినియోగదారు
లేదా అప్లికేషన్ వినియోగదారుకు CRM
గా చెప్పవచ్చు.
మరియు ఈ హార్డ్వేర్ అంతర్గ్హత నిర్మాణంను
ఉపయోగిస్తున్న లేదా మధ్యస్థంగా ఉన్న
సాఫ్ట్వేర్ ఆర్కిటెక్ట్ డెవలపర్ కోసం, ఇది
ఒక సేవ వలె ఈ మౌలిక సదుపాయాన్ని ఉపయోగిస్తుంది,
దీనిని అభివృద్ధి చేయడం లేదా దీనిపై
ఈ అనువర్తనానికి మద్దతు ఇవ్వడం, ఈ
రకాలు మధ్యలో ఉన్నవి.
కాబట్టి, వివిధ వ్యక్తులు లేదా వివిధ రకాల
వినియోగదారులు ఈ నిర్మాణం యొక్క పద్దతిని
వివిధరకాలుగా ఉపయోదిస్తారు.
ఇప్పుడు మనము రెండు ప్రముఖమైన క్లౌడ్
సేవలను కలిగి ఉన్న రెండు ప్రముఖమైన
వాటికి మ్యాప్ చేసేందుకు ప్రయత్నిస్తాము,
అక్కడ అనేక ఇతర ప్రముఖ సేవలు ఉన్నాయి, కానీ
ఇవి ప్రస్తుతానికి అందుబాటులో ఉన్నాయి
మనము పొందడానికి.
కాబట్టి, మైక్రోసాఫ్ట్ విండోస్ ఆజర్ ప్లాట్ఫారమ్(windows
azure platform), మరొకటి అమెజాన్ క్లౌడ్ ప్లాట్ఫారమ్(amazon
cloud platform) లేదా అమెజాన్(amazon) EC2. ఇప్పుడు ఆ మూడు
స్టాక్లో ఎక్కువ లేదా అంతకంటే తక్కువగా
విభజించబడినది.
చొచ్చుకొని పోయే విషయాల దిగువ భాగంలో
ఇది ECE2లోఎక్కువ.
అమెజాన్ విషయంలో ఇది విండోస్ సర్వర్లు
మరియు సంబంధిత అంశాలలో గమనించవచ్చు; EC2 విషయంలో
ఇది అమెజాన్ S3 మరియు సాధారణ DV మరియు ఇతర
రకాల నిల్వలతో విండోస్ లైనక్స్(windows linux) మౌలిక
సదుపాయాలుగా ఉంటుంది.
మరియు మధ్యలో మనకు ఈ మిడిల్వేర్(middleware)
కలిగిన వేదిక ఉంటుంది, stuff యొక్క అనలాగ్(analog)
లా ఉంటుంది.
మరియు పై స్ధాయిలో అప్లికేషన్లు(application)
ఉన్నాయి.
ఇవి కొన్ని విండోస్(windows) ఆజరు అప్లికేషన్స్(azure
applications) మరియు అమెజాన్ అప్లికేషన్లు(amazon
applications).
ఇక్కడ ఒక క్లయింట్(client) ని మరో క్లయింట్(client)
కు కనెక్ట్(connect) చేయవచ్చు ఈ సందర్భంలో silver light
లేదా బ్రౌజర్(browser) ద్వారా కనెక్ట్(connect)
చేయవచ్చు.
కాబట్టి, నేను ఇంతకు ముందు చెప్పినది
గమనిస్తే అది కూడా మునుపటి స్లయిడ్లో
ఉంది, నిర్వహణ మరియు భద్రతా హక్కుసంభంధించిన
రెండు నిలువు వరుసలు ఉన్నాయి.
ఇవిరెండు చాలా ముఖ్యమైనవి,ఎందుకంటే మానేజ్మెంట్ మరియు
భద్రత వియయాలలో కొంతమంది భద్రతను ఒక మేనేజ్మెంట్
అంశంగా పరిగనిస్తారు మరియు కొన్నిసార్లు
క్వాలిటి ఆఫ్ సర్వీస్ ను పరిగనిస్తారు.
అందువల్ల, సేవల యొక్క నిర్వహణ నాణ్యత మరియు
సూచనలు లేదా విషయంలో కొన్నింటిని మీరు
గమనిస్తుండాలి.
కాబట్టి, ఇవన్నీ ఇక్కడ నిలువుగా ఉన్న
స్టాక్ అయిన దృశ్యాలు, అంటే భద్రత లేదా
నిర్వహణ ను ఒక లేయర్ తోనే సాధించలేము.
అందువల్ల, ఇది ఒక విధమైన క్రాస్ లేయర్
పరిశీలన అవసరంఉంది, అందుకే ఇవి నిలువుగా
ఉండే స్టాక్లు.
మీరు ఈ అంశాన్ని AZURE లేదా EC2లో చూసినట్లయితే,
ఇవి కూడా ఈ నిలువు స్టాక్లు ఏను. అందువల్ల,
వారు నిర్వహణ యొక్క భద్రత సంబంధిత అంశానికి
చెందిన వివిధ భాగాలను కలిగి ఉంటాయి, కానీ
ఇవి నిలువు స్టాక్లకు సంభంధించినవి.
అదేవిధంగా, భద్రత ఆధారపడిన అంశం,దానిపై
గల నియంత్రణ అంశం తరువాత చూద్దాం.
నాకు ఒకవేల infrastructure as a service కలిగి ఉన్నట్లయితే,
నా భద్రత లేదా నిర్వహణ మౌలిక సదుపాయాలు
మరింత పరిశీలనగా ఉంటుంది.
కాబట్టి, ఒకసారి నేను ఈ మౌలిక సదుపాయాన్ని
బయలుపరచుకుంటాను, ఈ మౌలిక సదుపాయాల
వెలుపలి యంత్రం మొదలైన వాటికి నేను కేటాయించాను,
అందువల్ల వినియోగదారుని లేదా వినియోగదారుడి
బాధ్యత ఈ విషయాన్ని పరిశీలిస్తుంది.
నేను ఒక సాఫ్ట్వేర్ను ఒక సేవగా కలిగి ఉన్నట్లయితే,
ఈ సమస్యలన్నింటినీ ఆ లేయర్ కు సరిగ్గా
అందించాలి.
సో, వర్డ్ ప్రాసెసింగ్ సేవ లేదా CRM సేవ అనేది
సాఫ్ట్వేర్ సేవ. కాబట్టి, ఆ స్థాయి
నిర్వహణ మరియు భద్రతకు సంబంధించిన అన్ని
అంశాలను అందిస్తుంది, అందుచే ఇది ఏ విధమైన
సేవా కేటాయింపు లేదా ఏ విధమైన సేవా విస్తరణను
చేస్తున్నామో ఈ ప్రత్యేక deployment లో ఉంటుంది
ఇవి మనం మాట్లాడుతున్న వివిధ అంశాలు మరియు
సమస్యలు; ఒకటి elasticity.
మనము చెప్పినట్లుగా లేదా మనము తెలుసుకున్నట్లుగా,
క్లౌడ్ యొక్క అతి ముఖ్యమైన లక్షణాలలో
ఒకటి scaleup,scale down ఇప్పుడు, అది సాధించడానికి.
, రెండు విస్తృత విధానాలు ఉన్నాయి.
ఈ రెండు విస్తృత విధానాలు , క్లౌడ్
లేకుండా ఇది ఎక్కువ elastic computing ని కలిగి ఉంటుంది.
ఒకటి మీరు నిలువు స్థాయిని చేయవచ్చు;
అనగా, ఎక్కువ వనరులను బాక్స్ కు కుడివైపున,
మనము ఒక ప్రత్యేకమైన మౌలిక సదుపాయాన్ని
కలిగి ఉన్నప్పుడు, ఉదాహరణకు, నాకు వేరే
సర్వర్లతో ప్రత్యేక రాక్ ఉంటుంది.
కాబట్టి, మేము మొదట కొన్ని 24 సర్వర్లను
కలిగి ఉన్నామని చెప్పాము, అప్పుడు నేను మరిన్ని
సర్వర్లను పెట్టినట్లయితే లేదా నా classes 16 బ్లేడ్లు
కలిగి ఉండవచ్చు మరియు అవసరాన్ని బట్టి
ప్రారంభంలో 4 కలిగి ఉండవచ్చు, సంస్థకు
మరో నాలుగు లేదా 16వరకు blade chases అవసం అనిపించవచ్చు
. ఇప్పుడు ఇది నిలువుగా ఉంది. కాబట్టి, ఇది
ఒక చిన్న scenario కు లాభంగా ఉంటుంది.మాములుగా
ఇది scaleup కు చాలా తక్కువ స్ధాయి , ఇది కేవలం
మీరు ఎంపికచేసిన 1 way server కంటే ఎక్కువ
ధర. అంశంపై పనిచేస్తుంది.
ఒకే computational box కుమరిన్ని వనరులను చేర్చవచ్చు,
ఎక్కువ పనిభారాన్ని వనరుల నుండి కంప్యుటేషన్
యూనిట్కు తరలించండి.
కాబట్టి, ఎక్కువ వనరులను కలిగి ఉన్నాము.
అయితే, మనకు ఉన్న scenarios లో పెద్ద scenario
ఉన్నప్పుడు పరిష్కారం 64 వే సర్వర్.కాని
64 అనేది 1 way server కంటే ఎక్కవ విలువ.
. అందువల్ల,64 computational unit అనేది 1 unit of computation
కన్నా విలువ తక్కువ.
నాకు పెద్ద ఎత్తున దృశ్యం వచ్చినప్పుడు,
ఆ పద్ధతిలో విస్తరించడం చాలా ఖరీదైనది కావచ్చు.
కాబట్టి, ఆ సందర్భాల్లో మాత్రమే ఆర్థిక అంశాల
పరంగా వ్యయం పరంగా విస్తరించడం మాత్రమే
కాదు, ఇది ఒకే వ్యవస్థ, అది వైఫల్యం ఒకే
ఒక్క పాయింట్ అయితే వైఫల్యం యొక్క నిర్వహణ
రేటు కావచ్చు ఆ సమయంలో.
నేను బహుళ వ్యవస్థలు కలిగి ఉంటే, కనుక
కొన్ని వ్యవస్థలు విఫలమైతే, నేను కొద్దిగా
తక్కువ పనితీరు మెట్రిక్ లో పనిచేయగలగాలి,
కానీ నేను దానిపై పని చేయవచ్చు.
అందువల్ల, ఇది horizontal scale up లేదా scale out లేద
vertical scale out అనేది మన అవసరాన్ని బట్టి
పరిగణించవలసి ఉంటుంది.
ఇప్పుడు, మా సేవా మోడల్కు తిరిగి వచ్చినా,
కాబట్టి XaaS ఏమి జరుగుతుందో, అవగాహన ఏమిటంటే సేవా-ఆధారిత
అంతర్గ్హత నిర్మాణం లేదా మౌలిక సదుపాయాన్ని
గుర్తించడం మరియు క్లౌడ్ కంప్యూటింగ్
XaaS ను గ్రహించడం.సర్విస్ ఓరియెంటెడ్ ఆర్కిటెక్చర్(service
oriented architecture) అంటే ఏమిటి, నేను చాలా వరకు ఇప్పటికే
తెలుసుకున్నారని భావిస్తున్నాను.
కాబట్టి; తదుపరి ఉపన్యాసాలలో సేవా-ఆధారిత
నిర్మాణంపై కొన్ని రకాల స్లైడ్స్ ఉంటయి.
కాబట్టి, ఆ ఈ విధమైన విషయాలు చాలా బాగా
తెలిసినవా లేదా కాదు, మేము వెంటనే తనిఖీ
చెస్తాము.
అయితే ఇది మౌలిక సదుపాయాలకు లేదా
PaaS లేదా ఏదైనా రకాలైన విషయాల కోసం నడిచే
ఒక విధానం.
సో, మేము ఈ XaaS గ్రహించడం కోసం SOI మరియు క్లౌడ్
కంప్యూటింగ్ మిళితం ప్రయత్నించాము.
అందువల్ల, క్లౌడ్ సంబంధిత సేవల సాధారణీకరణ
అనేది ఏదైనా సేవగా స్థానికంగా లేదా
సైట్లో కాకుండా ఇంటర్నెట్లో పంపిణీ చేయబడిన సేవల
సంఖ్యను సూచిస్తుంది.
XaaS అనేది క్లౌడ్ కంప్యూటింగ్ యొక్క సారాంశంఅని
మనకు ముందే తెలుసు.
కాబట్టి ఏదైనాservice అయితే, మనం డేటాను
మరొక ప్రజాదరణ కలిగిన ఇతర సేవగా కలిగి
ఉంటుంది.
ఈ ప్రసిద్ధ XaaS ఉదాహరణలో ఒకటి infrastructure as a service,platform
software service మనకు ముందుగానే తెలిసినవి.
ఇంకొక విషయం ఏమిటంటే,business process as a servise అనే మరొక
వచ్చి బాగా popular అయింది.
కాబట్టి, నాదగ్దర ఉండే workflow ని service క్రింద
ఇవ్వాలనుకుంటున్నాను.
కాబట్టి, సమాంతర లేదా నిలువు వ్యాపార
ప్రక్రియలు కంపెనీలు లేదా పరిశ్రమలకు
చందా ఆధారంగా అందించబడతాయి.
ఒక నిర్దిష్ట ఆపరేషన్ కోసం , నేను ఒక వ్యాపార
ప్రక్రియ కలిగిఉన్నాను.
కాబట్టి, దీని అర్థం ఏమిటి, ఇది కేవలం
పంపిణీ చేసే ఒక అప్లికేషన్ మాత్రమే కాదు.
వాటి మధ్య వాద్యాలుగా కలిగి ఉన్న వేర్వేరు
ప్రక్రియలు నాకు కలిగి ఉంటాయి, అప్పుడు
నాకు ఒక నిర్దిష్ట అనువర్తనాలను గుర్తించడం
కోసం అనుమతిస్తాయి.
ఇది బ్యాంకింగ్ రంగం కోసం ఉంటుంది, ఇది
విషయాలు వివిధ అభివృద్ధి ప్రణాళిక కార్యకలాపాలు
కొన్ని అంశాలను కోసం ఉంటుంది.
కాబట్టి, నేను application ను run చేసి ఫలితాలు
పొందేది ఇది ఒక్కటే కాదు ఒక అప్లికేషన్
ఇతర applications పై ఆధారపడి ఉంటుంది.
నాకు realize అవ్వడానికి భిన్న applications లభిస్తాయి.
కాబట్టి, P12 అని పిలవబడే p13ఇది P3 మరియు అంతర్గత
P3 మరియు P4 లకు ఇన్పుట్గా ఉంటుంది, అంతేకాక
అంశాల యొక్క తుది ఫలితంతో వస్తుంది.
ఇప్పుడు, నాకు భిన్నమైన వేరే విధానాలు ఉండవచ్చు.
కాబట్టి, ఈ విషయాలలో వాద్యములు ఉన్నాయి.
కాబట్టి, నేను బిజినెస్ ప్రాసెస్ అనేది . వివిధ
సబ్ ప్రాసెస్లు లేదా సబ్ అప్లికేషన్ల
సమ్మేళనం లేదా ఏకీకరణ.
ఆసక్తికరమైన అంశం ఏమిటంటే ఒక టైమింగ్
సంబంధం ఉంటుంది,ఎలా చెప్పొచ్చు అంటే
process execution tree లేదా process execution graph ఉంటుందని,
అది ఒక నిర్దిష్ట అంశాలను అనుసరిస్తుంది.
ఇప్పుడు, ఈ విధమైన విషయాల కోసం, ,ఇది
నిర్వచించబడితే, అప్పుడు , ఒక వ్యాపార
ప్రక్రియతో ఒక సేవను అందించాను అని చెప్పగలను.
కాబట్టి, ఇది కేవలం application as a service or software as a
service గాఉండదు, కాబట్టి నేను ప్రాథమికంగా
software as a service కన్నా ఎక్కువ విషయాలు కలిగి ఉంటాను.
యాదృచ్ఛికంగా ఈ విభిన్న ప్రక్రియలు విభిన్న
వైవిధ్యమైన ప్రొవైడర్ల నుండి రావచ్చు.
కాబట్టి, నేను ప్రాథమికంగా ఇప్పుడు క్లౌడ్ సర్వీసు
ప్రొవైడర్లతో సంప్రదించి ఆపై విషయం తెలుసుకోవచ్చు.
సో, ఈ వ్యాపార ప్రక్రియ అనేది organisations రోజు
ఆఖరి సమాయనికి చాలా అవసరం, ఈ విషయాలను,
మీరు చాలా మంది విన్న ఉండవచ్చు . కాబట్టి,
ఇది మీరు ఎక్కడైతే business process of outflow ని ఉపయోగిస్తారో
అక్కడ business process execution language ఉంటుంది.ఇది ప్రధాన
అంశాలలో ఒకటి.
IaaS అనేది RAW infrastructure.
PaaS వర్చ్యులైజ్డ్ అప్లికేషన్ డెవలప్మెంట్
లేదా రన్ టైమ్ ప్లాట్ఫారమ్.
SaaS అనేది subscription ఆధారంగా అందించబడిన క్లౌడ్లో
హోస్ట్ చేసిన సాఫ్ట్వేర్ అప్లికేషన్.
మరియు business process service అనేది horizontal లేద vertical గా companies
or industries లో subscription basis లో ఆధారపడి ఉంటుంది.
మరియు మరొకసారి వెనకకు తిరిగి చూసినట్లయితే,
అది మా జనాదరణమైన IaaS, PaaS మరియు, PaaS ఇతర
మౌలిక సదుపాయాలను కలిగి ఉంటుంది.
కాబట్టి, ఇవే కాకుండా ఇక్కడ మూడు అత్యంత
ప్రసిద్ధ ఉదాహరణలు ఉన్నాయి, అనేక వ్యాపార
కార్యకలాపాలు, అనేక ఇతర XASS సంఘటనలు ఉన్నాయి,
business process as a service ,storage as a serviceగా ఇంతకమునుపే
చూసాము., security as a service ఉంటే అది వివిధ security
అంశాలను అందిస్తుంది., database as a service కలిగినట్లైతే
, నేను etcetera ఇన్స్టాల్ చేయవలసిన పనిలేదు,
నేను datebase ని service గా చేసుకోవచ్చు.
monitoringmanagement asa service తో నేను నా IIT infrastructure ని manage చేసుకోవచ్చు.మా
IIT infrastructure లో వివిధ రకాల ug,pg labs ని నిర్వహించాల్సి
ఉంటుంది.
సాఫ్టువేర్ మొదటి నుంచే మనం నిర్వహన
భాద్యతను చేపట్టాల్సి ఉంటుంది,ఎలాగంటే
సాఫ్ట్వేర్ లో ఏమి జరుగుతోందో, hardware లేద
ఇతర వాటి నుంచి ఏదైనా సమస్య ఉందా అని చూడాలి.
కాబట్టి, నేను ప్రత్యేక టూల్స్ కలిగి ఉన్నానా
లేదా లేక ఇంకెవరైన machine తో అనుసంధానించే
service ని large infrastructure కు సంభంధించిన విషయంలో
అందించారా . కాబట్టి, communication content computing as a service
లో identity as a service,backup asa service,desktop as a service కొన్ని ముఖ్యమైనవి
. కాబట్టి, నేనుఏ service నైనా కలిగి ఉండగలము
మరియు ఇవి ప్రపంచవ్యాప్తంగా ఉపయోగించబడుతున్నవి.
CSP లేదా క్లౌడ్ ప్రొవైడర్ పెరుగుదల ఉత్పాదకత,
తుది వినియోగదారు సంతృప్తి, కొన్ని
వినూత్న సేవలు, దాని మార్కెట్ స్థానం
కలిగి ఉండటం రోజు ముగింపులో గమనించవచ్చు.
మరియు వేర్వేరు దారులు ప్రవేశించాడానికి
ఉంటాయి.
కాబట్టి, ఇది నడవ వలె ఉంటుంది మరియు
ఇది దానికై అదే ఏ వస్తువు కావాలో తెలుసుకో
గలదు.
మనము మరలా చూస్తే, మన ప్రాథమిక నిర్వచనానికి
తిరిగి వచ్చి చూడడానికి ప్రయత్నిస్తే, అందువల్ల
విస్తృత నెట్వర్క్ యాక్సెస్, రిసోర్స్
పూలింగ్, వ్యాపార నడిచే మౌలిక సదుపాయాలు
అక్కడ మరియు సేవ ఆధారిత ఓరియంటేషన్,
సేవ ఆధారిత నిర్మాణం.
కాబట్టి, ఈ నాలుగు ఈ సేవలు XAS రకం సేవలను
గుర్తించడంలో అనుకూలిస్తాయి.
కాబట్టి, సర్వీస్ ప్రొవైడర్ యొక్క
నాలుగు సాధారణ డిమాండ్లను XaaS నెరవేరుస్తుంది.
ఇప్పుడు, మా TCP / IP లేదా OSI మోడల్ల వంటి మా
నెట్వర్క్ స్టాక్ లాగా, నేను మా యొక్క
మాడల్ మోడల్ లేదా XaaS మోడల్ యొక్క సాధారణ
క్లాక్ స్టాక్ . కాబట్టి, ఆధారం ఏమిటంటే అది
అలాంటిది కాదు, కాబట్టి మనము ఏమి చెప్తున్నామో,
తార్కిక విధానాన్ని చూద్దాం, సరియైనది
కాదు, అది ఏదో ఒకదానికంటే ఎల్లప్పుడూ జరుగుతుంది,
కానీ అది విషయాలు తార్కిక ప్రాతినిధ్యం.
విషయం యొక్క కోర్ వద్ద వలె నెట్వర్కింగ్
ఉంది. కాబట్టి, మీకు ఒక విస్తృత నెట్వర్క్
యాక్సెస్ ఉంది, ఇది విషయాలు ఒకదానితో
ఒకటి మాట్లాడటానికి అనుమతిస్తుంది.
ఇంకొక ముఖ్య భాగమే అది సర్వోన్నతమైన
ఏదో నిల్వ.
ఇతర అంశం సర్వర్.
కాబట్టి, మీరు ఈ మూడు అంశాలను చూసినట్లయితే
ప్రధానంగా ప్రధాన భవనం బ్లాక్, ఇది
మేము ఏమి పనిచేస్తుందో దానిపై బేర్ మెటల్
విషయాలు చెబుతాము.
కాబట్టి, ఒక కమ్యూనికేషన్, ఒకటి ఈ వేర్వేరు
సర్వర్లు మరియు ఇతర భౌతిక అవస్థాపన,
మరియు ఇతర ఒకటి నిల్వ ఉంది. నిల్వ ఎల్లప్పుడూ
మేము మౌలిక సదుపాయాలలో ఒకదానిని ఉంచకుండా
మరొక ప్రత్యేక కారకంగా ఉంచడానికి ప్రయత్నిస్తాము,
కొన్ని సందర్భాల్లో నిల్వను మౌలిక సదుపాయంగా
ఉంచారు, కానీ నిల్వ వేర్వేరు రకం నిల్వ
నిర్వహణ నిర్వహణ విభిన్నంగా ఉంటుంది,
అందువల్ల నిల్వ యొక్క ముఖ్యమైన అంశాలు
ఇన్పుట్ కారకంగా చెప్పవచ్చు.
గ్రహించడం క్రమంలో ఏమిటంటే విషయాలు
వాస్తవికత యొక్క అంశంగా ఉంటాయి.
కాబట్టి, నేను అన్ని విషయాలు వర్చ్యువల్
అవసరం.
కాబట్టి, నేను మొత్తం మౌలిక సదుపాయాల యొక్క
వర్చువలైజేషన్ను కలిగి ఉండవచ్చు,
నేను ప్రత్యేక ప్రవర్తన వర్చువల్ మెషిన్
యొక్క వర్చువలైజేషన్ను కలిగి ఉండవచ్చు,
నేను కూడా నెట్వర్క్ను వాస్తవికీకరించవచ్చు.
సో, నేను ఒక ఇన్ఫ్రాస్ట్రక్చర్ వాస్తవీకరణ కలిగి,
నేను ఒక నిర్దిష్ట వాస్తవిక నెట్వర్క్
అవస్థాపన గ్రహించడం, మరియు కోర్సు యొక్క,
నిల్వ.
కాబట్టి, వర్చువల్ అనేది ప్రాథమికంగా
ఈ పిలవబడే వర్చ్యువల్ మిషన్లు లేదా వర్చ్యువల్
నెట్వర్క్, వర్చ్యువల్ స్టోరేజ్ రకము కలిగివుంటుంది.
అది ఒక వర్చువల్ మెషీన్ను ఉంటే నేను
ప్రత్యేకమైన OS ను నేను తప్పక సరిగా
అమలు చేయాలి.
కాబట్టి, ఈ మిడిల్వేర్ తరువాత నేను రన్టైమ్
లైబ్రరీని కలిగి ఉంది, దత్తాంశంతో
దగ్గరికి దత్తాంశం మరియు చివరికి, స్టాక్
యొక్క చివరి భాగం అనువర్తనాలు.
కాబట్టి, ఈ ఐఏఎస్ఎస్ను తయారు చేసే విభిన్న
భాగాలు, అన్ని భాగాలు సమానంగా ముఖ్యమైనవి
కావు, అన్ని రకాలైన XaaS రకం కోసం సమానంగా
ముఖ్యమైనవి కావని గమనించవచ్చు, అయినప్పటికీ
వారు గ్రహించడంలో ముఖ్యమైన పాత్రను
పోషిస్తారు.
ఇప్పుడు మనము ప్రయత్నిస్తే, మనం ఎక్కడా కొంతమంది
మనం ఎవరికైనా ఉంటున్నారంటే మనము ఇప్పటికే ఈ
వస్తువులను పొందుతున్నాము, ఈ పెద్ద పరదైసు షిఫ్ట్
సరైనది.
కాబట్టి, అప్పటికే మనం మన ప్రధమ ఉపన్యాసాలలో
ఇప్పటికే వివరించాము, ఇప్పటికే మేము పంపిణీ
వ్యవస్థలు మరియు ఇతర విషయాలను కలిగి
ఉన్నాము.
మేము విషయాలు చాలా తెలుసుకుంటారు etcetera.
అందువల్ల, ఇది మరింత మార్కెట్ లాభదాయకంగా
మరియు ఒక కొలవలేని కంప్యూటింగ్ మౌలిక
సదుపాయాన్ని కలిగి ఉండటంతో మేము మామూలు
ప్రమాణాలు సేవలను నిజంగా సులభంగా మళ్లించాము.
కాబట్టి, మీరు సరళీకృత ఐటి స్టాక్ను చూస్తే,
మనము వినియోగదారుని దరఖాస్తు మరియు అంకితమైన
అవస్థాపనను తుది చేస్తాము.
కాబట్టి, ఇది ఐటి లెగసీలో ఉంది లేదా
ఇప్పటికీ ఇది ఇప్పటికీ చాలా సంస్థల్లో లేదా
వివిధ సంస్థల్లో మరియు ఇతర విషయాల్లో
సర్వసాధారణంగా ఉంది, కాబట్టి ఇవి కొంతవరకు
సరైన లేదా మరింత బలంగా జతచేయబడిన
హక్కును కలిగి ఉంటాయి.
అందువల్ల, అంకితమైన దరఖాస్తు మౌలిక సదుపాయాలకు
అంకితమైన అనువర్తనాలపై నడుస్తుంది.
అందువల్ల, అప్లికేషన్ పరిమాణాత్మక అంశాలని
మౌలిక సదుపాయాలపై లేదా ఇతర మార్గాల
ఆధారంగా తయారు చేస్తారు.
అంతిమ వినియోగదారుడు పని చేయడానికి కొన్ని
ప్రత్యేకమైన అప్లికేషన్లను కలిగి ఉంటారు, అయితే
మనం ఏమి చేయాలో ప్రయత్నిస్తున్నామంటే మనం ఎలా తెలుసుకోవాలనుకుంటున్నాము
అనేది సరళీకృత ఐ.టి ఇన్ఫ్రాస్ట్రక్చర్
ఎక్కువ, ఇవి కొద్దిగా ఎక్కువ సౌకర్యాలను
కలిగి ఉంటాయి.
కాబట్టి, నేను దరఖాస్తు ముగింపు వినియోగదారు
పరికరాలపై కొన్ని ప్రత్యేక అవస్థాపనను
కలిగి ఉన్నాను, కానీ అవి చాలా గట్టిగా
కట్టుబడి ఉండవు.
కాబట్టి, మనము చేయబోయే విషయమేమిటి, అది
కూడా తరువాత చూపించిన కొన్ని ఉపోద్ఘాతాలను
చూద్దాం, ఈ విధమైన విషయాలు వనరులను
బాగా ఉపయోగించుకోవచ్చని లేదా ఇన్వెస్ట్మెంట్
కుడి వైపు మంచి రాబడిని కలిగిస్తాయి.
లేదా ఇదే రకం లేదా సేవల యొక్క సాధారణ
వనరు ఆధారిత రకాన్ని సేవలను వివిధ రకాల
సేవలను అందించడం.
కొన్ని సందర్భాల్లో అనేక సంస్థలు చాలా
మిగులు వనరులను కలిగి ఉన్నాయి, మా సొంత
యుజి లేదా పిజి ల్యాబ్ల గురించి నేను మళ్లీ
మాట్లాడటం వంటివి, ఇది గణన వనరులను
భారీ మొత్తంలో కలిగి ఉండవచ్చు, కానీ అప్పుడు
వారు 24 గంటలు వినియోగిస్తారు, 8 నుండి 10 గంటల చాలా
లోడ్. కానీ క్లాస్ గంటలు లేదా లేబుల్
గంటలు లేనందున, పరిశోధకులు వారి ప్రాథమిక వనరుల
ప్లాట్ఫారమ్పై అధిక అనుకరణను అమలు చేయడానికి
అవకాశాన్ని కల్పించవలసి ఉంటుంది, అందువల్ల
ఒక సొంత వనరులను ఉపయోగించుకునే ఒక
మార్గం కావచ్చు మంచి ఫ్యాషన్.
సాంప్రదాయిక మోడల్ ప్లస్ XaaS మోడల్ వంటి
కొన్ని ఇతర విషయాలు లైసెన్స్ చేయబడిన
సాఫ్టవేర్, హార్డ్వేర్ ఉత్పత్తి మరియు ప్రజల
ఆధారిత సేవలు వంటివి, మా సాంప్రదాయిక క్లౌడ్,
సంప్రదాయ అవస్థాపన నమూనాలు లేదా సాంప్రదాయిక
అవస్థాపన నమూనా.
మరియు మేము ఈ ప్రయత్నాన్ని పెంచుకునేందుకు
అలాంటి పద్ధతిలో నిర్మాణాన్ని చేయవలసి
ఉంది. అయితే, మనము ఊహించిన విషయాలు
XASS యొక్క సేవలకు వెళుతున్నాము, అందుకే సాఫ్ట్వేర్
IaaS, PaaS లేదా XASS రకం ఏ రకమైన అయినా రకాలు.
మీరు మా క్లాసిక్ విషయం చూస్తే లేదా
ఇప్పటికీ చాలా చెల్లుబాటు అయ్యే ఉంటే మేము
ఒక క్లయింట్ సర్వర్ నిర్మాణం కలిగి.
కాబట్టి, అనేక క్లయింట్లకు సేవ చేసే సర్వర్
ఉంది; మరియు సర్వర్ ప్రోగ్రామ్ ఆధారంగా
సర్వర్లో నడుస్తుంది, మరియు కక్షిదారుడు
కనెక్ట్ కావడానికి ఎల్లప్పుడూ ఎదురు
చూస్తున్నాం మరియు మేము అంశానికి కనెక్ట్
చేస్తాము.
మరియు ఈ చాలా ప్రజాదరణ మరియు ఇప్పటికీ చాలా
ఉపయోగం మరియు కుడి అనేక సందర్భాల్లో
ఉపయోగంలో ఉంటుంది.
కానీ అక్కడ నుండి మనం ఒక సేవా ఆధారిత
నిర్మాణంకి వలసవెళ్లాము, దానికి బదులు ఈ చాలా
బలంగా కలుపుకున్న క్లయింట్ సర్వర్కు,
సేవకు సంబంధించి ఒకదానితో ఒకటి సేవా
చర్చలు ఉన్నాయి.
మరియు మేము ఒకదానితో ఒకటి మాట్లాడటానికి
వైవిధ్యమైన విషయాలు కలిగి మరియు మేము
flexibilities చాలా ఉన్నాయి ప్రత్యేక ప్రయోజనాలు
ఉన్నాయి.
చాలా ప్రజాదరణ క్లయింట్ సర్వర్ విషయాలు FTP
సర్వర్ లాగా ఉంటాయి, టెల్నెట్, HTTP ఈ మార్గం
ఈ క్లయింట్ ఈ చర్చలు కనిపిస్తోంది సర్వర్
భాగంగా ఒక నిర్దిష్ట డెవ్ ఉంటాయి.
కాబట్టి, క్లౌడ్ కంప్యూటింగ్ యొక్క
ఈ ప్రత్యేక నిర్మాణ అంశాలపై మా తర్వాతి
ఉపన్యాసాలలో మా చర్చను కొనసాగిస్తాము మరియు
మనం వాస్తవికత యొక్క మరొక విషయాలను మరో
విషయం చూస్తాము.
కాబట్టి, నేటికి ఈ ఉపన్యాసం ఇక్కడతో
ముగుస్తుంది.
ధన్యవాదాలు.
మన చర్చను కొనసాగిద్దాం.
గత చర్చలో మనం ఈ client server గురించి ,సాంప్రదాయిక
client server రూపాంతరము, మరియు
service దృక్పధంతో cloud అందించే serviceల గురించి
తెలుసుకున్నాం; మనము ఆ చర్చను here కొనసాగిస్తాం.
ఒక client server model ఏమి
కలిగి ఉంటుందని నేర్చుకున్నాం, ఒక server మరియు
ఈ server తో అనుసంధానించబడిన అనేక clients 
ఉంటాయని.
కనుక,ఈ ప్రత్యేకమైన server కు అనుసందానించబడిన
అనేక client లు ఉన్నాయి.
అంటే ఈ server మరియు client
తార్కికంగా లేదా భౌతికంగా ఒకే machine
లో ఉంటాయి, అదే machine  client
లేదా server గా ఉంటుంది, లేదంటే
మరొక machine  అయినా ఒక client
లేదా ఒక server గా ఉంటుంది.
ఒక client server ని మొదలైన వాటిని
access చేయవచ్చు.
కాబట్టి, మనకు ప్రతి server కి ఎలాంటి
clients  ఉంటాయో తెలుసుకుందాం, ఇప్పుడు
ఎఫ్‌టి‌పి  client serverని కలిగి
ఉన్నట్లయితే ,మనము ftp డెమోన్ ను ఒక
ప్రత్యేక Linux ఎన్విరాన్మెంట్ లో కలిగి ఉంటే అందులో
ftp client ఉంటుంది.
కాబట్టి, ftp client  ftp server కోసం
చూస్తుంది.
ఈ సందర్భంలో, ఒక server ని గుర్తించడానికి
ఎలా ప్రయత్నించాలంటే ప్రధానంగా server
ప్రాసెస్  ఒక ప్రత్యేక పోర్ట్
లో వేచి ఉంటుంది.
కాబట్టి, మనం ఏమి చేస్తామంటే, ftp ఉంటే
ftpd server లేదా telnetd ఉంటే telnet server
లేదా చాలా ప్రజాదరణ పొందిన http ఉంటే, appపుడు
మనం httpd server ని కలిగి ఉండాలి.
కాబట్టి, ఈ అన్ని విషయాలు కూడా ఒక
ప్రత్యేక పోర్ట్ మార్గాలు.
దీని అర్థం ఏమిటంటే, ఈ server machine
 లో, ఉదాహరణకి http డేమోన్  server
 లో ఒక ప్రత్యేక పోర్ట్ 80 లేదా తార్కిక
పోర్ట్ 80 ని, http డెమోన్ను గుర్తిస్తుంది.
ఇప్పుడు ఎక్కడ నుండి అయిన లేదా ఏ బ్రౌజర్
నుండి అయినా client లేదా http client
రెక్వెస్ట్  ని server  కి పంపినపుడు
server వేగంగా connect అవుతుంది
. కాబట్టి, server ఎల్లప్పుడూ ఒక నిర్దిష్ట
పోర్ట్  ద్వారా ఏ client కి
అవసరం ఉంది అని గమనిస్తూ ఉంటుంది.
ఎప్పుడు ఏ client service  అవసరం
అయినా, దానికి సంభందించిన పోర్ట్ తో కలిపి
ఆ అవసరాన్ని తీరుస్తుంది.
మనం here రెండు రకాల servers
 ని చూస్తాము.
అందులో ఒకటి కంకరెంట్  server ,
ఇది ఏకకాలంలో సెర్విసెస్  ని పూర్తి చేస్తుంది.
మరియొకటి, ఇటరేటివ్ server , ఇది ఒక
service  తర్వాత మరొక డాన్ని పూర్తి
చేస్తుంది.
కానీ మొత్తం ప్రక్రియకు ఒకే ఒక కాంపొనెంట్
 కీలక పాత్ర వహిస్తుంది.
ఎలాగంటే http కి , httpd server  ఒకదానితో
ఒకటి సహకరించుకోవడానికి httpd అవసరం అయినట్లుగా.
కనుక, కొంతవరకు వీటి మధ్య బంధం మరింత
బలంగా ఉంటుంది, అయితే అది మన అన్నీ ప్రయోజనాలను
పూర్తి చెయ్యగలగాలి.
కొన్ని రకాల application  లో వేటిలో అయితే
data మరియు application ఒకదానితో మరొకటి
కమ్యూనికేట్ అవుతాయో అక్కడ మన
ప్రామాణికతకు ఇది విభిన్నంగా ఉంటుంది.
ఇప్పుడు, client server నిర్మాణం
చూద్దాం . ఇది ఒకటి లేదా ఎక్కువ load
బాలెన్సింగ్ server లను కలిగి
ఉండి. client పంpay రిక్వెస్ట్
 లను పరిష్కరిస్తాయి.
clients  మరియు serverలు రిక్వెస్ట్-
రెస్పోంస్  పద్దతిలో మెసేజస్  ని మార్పిడి
చేసుకుంటాయి.
client అనేది సాధారణంగా తక్కువ కొంపుటేషనల్
సామర్ధ్యంతో ఒక తిన్ client లేదా
యంత్రం కావచ్చు.
server  ఒక load బాలన్స్డ్ cluster లేదా ఒక Independent యంత్రం.
ఉదాహరణకి , http server ని తీసుకున్నట్లైతే
, అది ఒక బలమైన సామర్ధ్యము గల System . అదే
మనము ఒక client ను మన mobile నుంచి
కానీ లేక ల్యాప్tap  నుంచి కానీ చూసినట్లైతే
వాటికి సమర్ద్యం తక్కువ మరియు అవి
serverను ఉపయోగించడం చాలా బలంగా మరియు
మెరుగైన వ్యవస్థలతో ఉంటుంది.
. కాబట్టి, అది ప్రాథమికంగా మూడు రకాలైన నిర్మాణాన్ని
అనుకరించడానికి ప్రయత్నిస్తుంది,
ఒకటి ఎగువ స్థాయిలో ప్రెజెంటేషన్ లేయర్, తర్వాత లాజికల్  లేయర్  మరియు
దిగువ స్థాయిలోData లేయర్.
కాబట్టి, దీనిని త్రీ టైర్ architecture
 అంటాము.
దీని ఉపయోగాలను భట్టి ఇది ప్రజాTierణ పొందింది.
ఇప్పుడు cloud computing అవసరం లేదా ఎక్కడ
ఇది భిన్నం గా ఉంటుంది అనేది చూద్దాం.
client server model అనేది
ఒక సాధారణ service model  ఇందులో
server clientు రిక్వెస్ట్  లను
Service చేస్తుంది, అదే cloud  లో
అయితే సంక్లిష్ట service  models
 అయిన IaaS, PaaS, SaaS వంటివి ఉంటాయి.
క్లైంట్ server model  లో ప్రతి
service కి , client ని connect చెయ్యాలంటే
ఒక server ప్రాగ్రామ్  తప్పనిసరిగా
ఉండాలి, అదే cloud  లో అయితే, వివిధ
రకాల XaaS model  లు ఉంటాయి.
కాబట్టి, service modelను చూసే
విధానం, client server  విషయంలో
వేర్వేరుగా ఉండవచ్చు మరియు load బాలన్సింగ్
 లేకుండా ఉండచ్చు.
కానీ cloudస్  అన్నీ కూడా లఓడ్
బాలన్స్  అయి ఉంటాయి.
ఇది cloud  యొక్క ప్రధాన అంశాల్లో
ఒకటి. cluster కొంత
వరకు స్కేలబుల్, మరియు cloudలో
theoretically అనంతమైన స్కాలబిలిటీ 
ఉంటుంది.
client server విషయంలో, వర్చ్యులైజేషన్
అనే విషయం ఏదీ లేదు. మరియు వాస్తవీకరణ
అనేది మా ప్రధాన భావన లేదా cloud
computingలో ప్రధాన భావన.
కాబట్టి, మనం ఈ cloud computing
యొక్క మరింత సమర్థత లేదా మొత్తం resources
 యొక్క మరింత మెరుగైన వినియోగం
మరియు వాటాదారుల పెద్ద సంఖ్యలో ప్రతిపాదించడానికి
ప్రయత్నించడం తెలుసుకుంటాము.
పై చిత్రం అంత స్పష్టంగా లేదు, ఇందులో services
విభజన చూపబడుతుంది, దిగువ భాగంలో కార్యాచరణ,
కార్యాచరణ వ్యవస్థల యొక్క inఫ్రస్తృక్చర్
అంటే network storage  సౌకర్యాలను
అంచనా వేయడం మరియు మధ్యలో వేర్వేరు
రకాలు services  ఉన్నాయి.
మనము infrastructure ని కలిగి ఉన్నాము.
ఈ cloud computing యొక్క cloud
services  గురించి విస్తృతంగా
తెలుసుకుందాం.
ప్రతి లేయర్ ఒక service ని ఇస్తుంది.
అనగా IaaS, PaaS లేదా SaaS services
ఉంటాయి.
కొన్ని వ్యాపార ప్రక్రియలు అమలు చేయడానికి ఈ
services  ని ఉపయోగిస్తారు.
కాబట్టి,ఈ services మాత్రమే కావు, వ్యాపార
అభివృద్దికి కూడా తోడ్పడతాయి.
వివిధ వ్యాపార ప్రక్రియలను అమలు చేయడానికి మనము
ఈ services  ని ఉపయోగించుకుంటాను.
కాబట్టి, ఇది ఒక business ప్రాసెస్ .
మనము business ప్రాసెస్  ఒక service
 గా పొందవచ్చు.
here ఉన్న మరొక లేయర్  ప్రెజెంటేషన్
లేయర్, ఇది consumerలతో
నేరుగా సంప్రదించడానికి కొన్ని interfaceలు
 ఉంటాయి లేదా వేర్వేరు service
modelని connect చేయడానికి కొన్ని
API లు ఉంటాయి.
వివిధ Service provider కోసం వివిధ రకాలైన
API లను ఉపయోగిస్తారు.
ఆ API లను ఉపయోగించి connection  నిర్మిస్తాము.
ఈ API ఇవ్వడం వలన మనము service provider గా చెప్పలేము.
consumerని యొక్క అనుకూలీకరించిన
కొన్ని application  లు లేదా కొన్ని
ప్రత్యేక interfaceలు తో ఎలా connect చేయాలి
అనేది చూస్తాం.
ఇప్పుడు మొత్తం వ్యవస్థ ఇంటెగ్రటెడ్ ప్లాట్ఫారమ్ను కలిగి ఉండాలి, అంటే ఇది అంత బలమైన
ఇంటెగ్రేషన్ ప్లాట్ఫారమ్ ఉందవలసిన అవసరం
లేదు, hardware ని ఇంటెగ్రేషన్ చెయ్యడానికి ఒక విధమైన నిర్దిష్ట
నిర్మాణాత్మక స్థానం అవసరం, Service ఇంటెగ్రేషన్ చెయ్యడానికి ఒక ఆర్చెస్ట్రేషన్
Engine  ఉండాలి కాబట్టి ఇంటెగ్రేషన్
 అనేది service ని అమలు చేయడానికి
ఉపయోగిస్తారు.
ఈ ఇంటెగ్రేషన్  చెయ్యాలంటే , మనం
చేసే service  నాణ్యత లేదా కోరుకున్న
service ని యొక్క సరైన స్థాయిలో చేస్తుందా
లేదా అన్నది చూసుకోవాలి.
సమాచారం యొక్క రకం లేదా సమాచారాన్ని
ప్రచారం చేయడం అనేది, ఏ విధమైన services
 ని అందిస్తుంది.
inఫర్మేషన్  రకాలైన విషయాలతో
ఎలా connect  అవుతుంది అనేది తెలుసుకోవాలి.
చివరికి, మనం మొత్తం గవర్నెన్స్ 
ని కలిగి ఉండాలి; ఈ గవర్నెన్స్ 
అనేది infrastructure  నిర్వహణ లేదా
మొత్తం వ్యవస్థ నిర్వహణ అయి ఉండవచ్చు.
మనకు చట్టపరమైన problemలు మరియు పాలసీలు అమలు
చేయబడ్డాయి, తద్వారా సమాఖ్య చట్టాలు మరియు
నిబంధనల ప్రకారం చట్టబద్ధంగా చెల్లుబాటు
అయ్యేవి గవర్నన్స్  ని రూపొందిస్తాయి
ప్రాథమికంగా వివిధ services  ఉంటాయి.
నేను దీనిని పునరావృతం చేయడం లేదు, ఎందుకంటే
ఇది అనేక రూపాల్లో మనం చెప్పుకున్నాం.
కాబట్టి, చివరకు, మనం ఈ విభిన్న service
model  ని ఉపయోగిస్తున్నాము.
కాబట్టి, కొంత సమయం SaaS, PaaS మరియు IaaS ల గురించి
కొంచెం వివరంగా పునరావృతం చేసుకుందాం .
ఒక ట్రాన్స్పోర్టేషన్  ఉదాహరణతో
దీన్ని పోల్చుకుందాం.
రవాణా వ్యవస్థలో రహదారులు infrastructure
 అయితే , కార్లు మరియు ట్రక్కులు
రవాణా ప్లాట్ఫారాలు, మరియు వస్తువులు,
వ్యక్తులు software లు లేదా
సాంకేతిక పరంగా inఫర్మేషన్  అంటాం.
కాబట్టి, ఇలాగే cloud computing 
లో కూడా , మనము ఈ infrastructure  ని కలిగి ఉన్నట్లయితే,
వివిధ ప్లాట్ఫారమ్లు మరియు విభిన్న application
 లు పనులను అమలు చేస్తాయి.
software as ఆ service 
నిర్వచనం మనకు తెలుసు కనుక దానిని పునరావృతం
చేయవలసిన వసరం లేదు , ఇది internetలో
ద్వారా వినియోగించే ఒక Software,
పాయ్ as యు go model గా ఉపయోగించుకోవచ్చు.
మరియు మనము ప్రాథమికంగా శోధించవచ్చు మరియు
ఆ servicesని  ఉపయోగించుకోవచ్చు.
SaaS లక్షణాలు; విలక్షణమైన లక్షణాల్లో ఒకటి
వాణిజ్య Software  కి Web access
; Software  అనేది ఒక కేంద్రీకృత
స్థానం నుండి నిర్వహించబడుతుంది, కనుక ఇది పంపిణీ
చేయబడవచ్చు మరియు విస్తరణ పంపిణీ చేయబడుతుంది,
అయితే నిర్వహణ అనేది తార్కికంగా కేంద్రీకృత
స్థానాన్ని కలిగి ఉంటుంది, వివిధ Simulation
, అంటే మ్యాథమేటికల్ Simulation
కి మద్దతు ఇచ్చే ఒక విధమైన computing
 కోసం, మొదలైనవాటి కొరకు Software
 ఒక service  గా ఇస్తాము.
ఈ మొత్తం Simulation అంతా కూడా వైవిధ్యమైన
వివిధ ప్లాట్ఫారమ్ల్లో పై లేదా డిస్ట్రిబుటెడ్
Systems  లో గాని ఉండవచ్చు,
కానీ మొత్తం నిర్వహణ తార్కికంగా కేంద్రీకరిస్తుంది.
Software అనేది ఒన్-టు-మెనీ
model లో పంపిణీ అవుతుంది.
కాబట్టి, దీనిని ఒన్ టు మెనీ
అంటాము.
consumerలు app గ్రేడ్  చేయనవసరం
లేదు. మరొక లక్షణం, application ప్రోగ్రామింగ్
interface వివిధ Software
భాగాల మధ్య ఏకీకరణ కోసం అనుమతిస్తుంది.
API అనేది Software  సమ్మేళనం లేదా
ఇంటిగ్rate చేయడానికి అనుమతిస్తుంది.
ఎక్కడైతే వివిధ institutionల మధ్య, బయటి ప్రపంచంతో
ఒక ముఖ్యమైన పరస్పర సహకారం ఉంటుందో అక్కడ
ఇది చాలా ఉపయోగకరంగా ఉంటుంది, ఉదాహరణకి
ఇ-మెయిల్, లాంటి ప్రచారం Software
వంటి institution.
కనుక , దీనిలో చాలా interface లు
ఉంటాయి.
Web మరియు mobile access కోసం
అవసరమైన application; స్వల్పకాలిక అవసరాలకు
మాత్రమే ఉపయోగపడే Software, ఏదైనా
మనకు ఎల్లప్పుడూ అవసరం అవసరము ఉండకపోవచ్చు.
కానీ మనం స్వల్పకాలిక అవసరాల కోసం మాత్రమే
ఉపయోగించాలనుకుంటున్నాము.
ఉదాహరణకి , ఒక ప్రత్యేక పరీక్షను నిర్వహించాలనుకుంటున్నాము
లేదా ఇంటర్వ్యూ కోసం నిర్దిష్ట వ్రాత
పరీక్షను అమలు చేయాలనుకుంటున్నాము మరియు ఒక ప్రత్యేకమైన
లక్ష్యం కోసం ఆ పనిని అమలు చేయాలనుకుంటున్నాము,
ఆ రోజు మాత్రమే వాటిని అమలు చేస్తున్నాము.
కనుక, అన్నింటిని మనం deploy 
చేయనవసరం లేదు. మనం ఎక్కడైనా services
 ని పొందవచ్చు అనగా ఒక నిర్దిష్ట
ప్రయోగశాలలో డెస్క్tap ద్వారా services
ని పొందడం , ఆ పరీక్షను అమలు చేయవచ్చు.
తరువాత కాలానుగుణంగా ఆ విషయం మర్చిపోవచ్చు.
కాబట్టి, పన్ను, బిల్లింగ్ మొదలైనవాటికి Software
డిమాండ్గణనీయంగా పెరుగుతుంది.
కాబట్టి, డిమాండ్లకు వచ్చే చిక్కులు ఉంటాయి,
సాధారణంగా పన్నులు చెల్లిస్తున్నప్పుడు
లేదా పన్ను దరఖాస్తును పూరిస్తున్నపుడు,
సంవత్సరంలో నిర్దిష్ట సమయం వరకు డిమాండ్
పెరుగుతుంది.
మిగిలిన సమయంలో అది తగ్గిపోతుంది.
appపుడు వీటిలో కొన్ని ప్రసిద్ధమైన Software
 లు సేల్స్ ఫోర్స్ , CRM మొదలైనవి
ఏ application  లో SaaS అనేది ఉత్తమ
ఎంపిక కాదో చూద్దాం.ఏ application 
కైతే చాలా వేగవంతమైన processing లేదా
real timeData అవసము ఉంటుందో వాటికి
. ఎందుకంటే, ఆ cloud computingలో మనం చూడగలిగినది లేదా అధిక పనితీరు
నిజమైన రకమైన operationగా పరిగణించబడదు.
దీనిలో డిలే అంటే ఆలస్యం కావచ్చు.
కనుక, ఏ application  కైతే real
data ఆవరమయ్యి చాలా వేగంగా కార్యకలాపాలు
జరుగుతాయో అనగా ఉదాహరణకు, వైపరీత్యాల నిర్వహణ
మొదలైనవి వాటికి ఇది సరైన ఎంపిక కాదు.
మనము provision చేస్తూ ఉన్న, అది
కచ్చితమైనదిగా , ప్రత్యేకమైన QoS నిర్వహణతో అంకితమై
ఉండాలి.
మరొక రకమైన application , ఏవైతే చట్టాలు
మరియు ఇతర నియంత్రణలు externalంగా host
చేసినDataను అనుమతించవు.
ఇలాంటి, ఒక institutionాగత పని లేదా institutionలో
చెప్పాలంటే, institutionకు సంబంధించి సమాచార
సంబంధిత Communicationను దాని మెయిల్ serverలోనే ఉండాలి లేదా institution యొక్క ఇమెయిల్
ఐడిని public అవసరానికి ఉపయోగించకూడదు
అని చెప్పవచ్చు.
కాబట్టి, ఇది మనDataలో చట్టపరమైన నిబంధన.
మరొక application  ఇప్పటికే ఉన్న
on-ప్రేమిస్  సొల్యూషన్  institution
యొక్క అన్నీ అవసరాలను తీరుస్తుంది.
institution అవసరాలను తీర్చగలగే ఒక లెగసీ applicationలు
కలిగి ఉండటం అవసరం కావచ్చు.
అదేవిధంగా, platform as ఆ Service  అనేది SaaS application  కి ఎలా ఉపయోగపడుతుంది,
ఇది ఒక Software డెవలప్మెంట్ ప్లాట్ఫారమ్ కు ఉపయోగపడుతుంది . సాస్ అనేది Webలో
 ద్వారా Softwareను పంపిణీ చేస్తుంది.
కానీ  అనేది Software  ని create
 చేసి , పంపిణీ చెయ్యడానికి ఉపయోగపడే
ఒక platform .
కాబట్టి, ఇది మన సొంత system development
చేయడానికి ఒక వేదికను ఇస్తుంది.
కనుక డెవలప్,, deploy  ,host
 చెయ్యడానికి కావలసిన services  లాంటి
లక్షణాలను అదే సమీకృత డెవలప్మెంట్
ఎన్విరాన్మెంట్ లో ఉన్నాయి.
వివిధ consumer interface మరియు
ఇతర విషయాలను రూపొందించడానికి, సవరించడానికి, పరీక్షించడానికి
పరీక్షా ఉపకరణాలను రూపొందించడానికి
Web ఆధారిత interface ను తయారుచేస్తారు.
multi టెనెంట్ architecture , here
ఒక అభివృద్ది చేసిన application 
ఒకేసారి ఎక్కువ consumerలు ఉపయోగిస్తారు.
deployడ్ Software  యొక్క load
బ్యాలన్సింగ్  మరియు ఫైలోవర్
 తో కూడుకున్న అంతర్నిర్మితంగా
ఉన్న scalability.
here టీమ్  సహకారం చాలా ముఖ్యమైనది.
వివిధ ప్రాంతాలలో లద వివిధ దేశాలలో
వ్యాపించి ఉన్న ఒక విభిన్న development
బృందానికి ఒక సాధారణ development వేదిక
అవసరం అవుతుంది.
దీని పై పనిచేస్తే ఇది ఒక మంచి పరిష్కారాన్ని
చూపిస్తుంది.
బిల్లింగ్ సబ్స్క్రిప్షన్ నిర్వహణ కు కావల్సిన
టూల్స్ మొదలైనవి ఇతర అంశాలు.
ఇది చాలా ఉపయోగకరంగా ఉంటుంది, ఎక్కువగా
ఇది development చేస్తున్న ప్రణాళికలో బహుళ
డెవలపర్లు పనిచేసే పరిస్థితిలో ఉపయోగకరం.
ఇతర external partyలు డెవలప్మెంట్ ప్రాసెస్ తో ఇంటెరక్ట్ అవ్వడానికి ఇది ఉపయోగపడుతుంది.
కాబట్టి, institution కార్యాలయంలో కీలకమైన development
బృందాలను కలిగి ఉన్నాము.
customer తో రోజువారీ ప్రాతిపదికన ఇంటెరక్ట్
 అవ్వడానికి ఒక డెవలప్మెంట్
జట్టు ఉంటుంది మరియు ప్రధాన కార్యాలయంలో
ఇతర development బృందం ఉండవచ్చు.
మనము ఈ రెండింటి మధ్య సమన్వయం చేయాలనుకున్నప్పుడు
ఈ ప్లాట్ఫారమ్ ఉపయోగపడుతుంది.
డెవలపర్లు ఎక్కడైతే టెస్టింగ్ మరియు
డెవలప్మెంట్  Automate చెయ్యాలనుకునటారో
అక్కడ PaaS ఉపయోగపడుతుంది.
కాబట్టి, మీరు Automate చేయాలనుకుంటే తనిఖీ
చేయవలసినవి అక్కడ ఉంటాయి.
Software డెవలప్మెంట్ పద్దతుల్లో
ప్రజాTierణ పొందినది ఎజిల్ Software పద్దతి, ఇది ఈటెరటివే  మరియు ఇంక్రీమెంటల్
 model పై ఆధారపడి ఉంటుంది, ఈ సందర్భాలలో
PaaS చాలా ఉపయోగకరంగా ఉంటుంది.
ప్రముఖ PaaS రcallలో ఒకటి azure, మరియు
Google యాప్ Engine లేదా ఇతర అనేకమైనవి
ప్రజలు తమ application development చేయటానికి
ఉపయోగిస్తారు , అది Web ఎనేబుల్
application గా Web లలో అందుబాటులో
ఉంటాయి.
PaaS ఏ సందర్భాలల్లో ఉపయోగకరంగా ఉండదో
చూద్దాం.
ఏ application లకు host  పరంగా
అత్యంత పోర్టబులిటి  అవసరం అవుతుందో
అక్కడ PaaS మంచి ఎంపిక కాదు. కాబట్టి, అధిక
portability అవసరమైతే ఇది మంచి ఎంపిక కాదు.
ఎక్కడైతే ప్రోప్రైటరీ లాంగ్వేజెస్  లేదా విధానాలు development ప్రక్రియపై
ప్రభావం చూపుతుంటాయో , ఉదాహరణకు, రక్షణ
శాఖలో ,ఆర్థిక శాఖలు మాదైలన వానిలో PaaS
సరైన ఎంపిక కాదు. ఇలాంటి institutionలలో
ఏది open గా ఉండదు అంటే open source గా చెప్పలేము ,ఇది public Systemsలో కాదు, దీనిలో సంశ్యాలను పరిష్కరించడానికి
కొన్ని ప్రోప్రీటెరి  పద్దతులు ఉంటాయి.
ఇందువల్ల here PaaS అంత ఉపయోగకరంగా ఉండకపోవచ్చు.
మరొక provider తో ఇంటెరక్ట్ అయ్యేటప్పుడు
ఈ ప్రోప్రైటరీ లాంగ్వేజెస్  అంతరాయం
కలిగిస్తుంది.
, దీని వల్ల అమ్మకం దారులు ఆందోళనలకు
దిగవచ్చు.
కనుక ఈ సందర్భంలో కూడా PaaS ఉపయోగకరంగా
ఉండదు.
ఎక్కడైతే application పనితీరుకి అంతర్లీన
hardware మరియు Software అనుకూలీకరణ
అవసరమో అక్కడ కూడా PaaS సరైన ఎంపిక కాదు.
కాబట్టి, నా objective దాని ఆధారంగా application
Performance కలిగి ఉంది అంతర్లీన hardware
మరియు Software ను అనుకూలీకరించడానికి
కస్టమిజెడ్  stack  అవసరం,
సాధారణ stack సరిపోదు.
చివరగా, IaaS, ఇది serverలను , storage  ని
, network మరియు ఆపరేటింగ్ సిస్టం లను infrastructure  గా అవసరాన్ని
బట్టి అందిస్తుంది.
resources  ని purchase లేదా నిర్వహించడం
కంటే మనము వాటిని Virtualization 
రూపంలో కలిగి ఉండవచ్చు లేదా ఒక virtual
ఇంస్టాన్స్  మరియు వర్చ్యువల్
storage  మొదలైనవాటిని కలిగి
ఉంటుంది.
కాబట్టి, ఇది ప్రజాదరణ పొందిన మరియు ఎక్కువగా
ఉపయోగించే IaaS.
IaaS లక్షణాలలో మొదటిది resources  ని
, services  గా పంపిణీ చేస్తాయని
బాగా తెలుసు, డైనమిక్ scalingను అనుమతిస్తుంది.
ఇది వేరియబుల్ Tier ను కలిగి ఉంటుంది.
మనము utility computing  కు, దానిలో
అయితే బహుళ consumerలు ఒకే Software 
ని ఉపయోగిస్తారో , దానికి చెల్లించినట్లుగా
here కూడా చెల్లిస్తాము.
ఒకే hardware stack  పై ఎక్కువ
యూజర్లను కలిగి ఉంటుంది లేదా అదే
hardware stack ని వివిధ virtual
machineగా చేస్తాము.
IaaS ఎక్కడ ఉపయోగించబడుతుందో చూద్దాం, డిమాండ్
చాలా asథిరంగా ఉంటుంది.
మనము కొన్ని times ఒక నిర్దిష్ట మెమరీ
అవసరాన్నిలేదా కొన్ని ఇతర అవసరాలు కలిగి
ఉంటాను.
అందువల్ల డిమాండ్లు మారుతూ ఉంటాయి , అంటే
పెట్టుబడిదారుల సామర్ధ్యం లేకుండా
ఉండే కొన్ని institutionలు ఉన్నాయి.
అనేక institutionలలో లేదా అనేక ప్రాజెక్టులలో
మనము వెంటనే హార్డువేర్లను  కొనడం అనేది
సాధ్యం కాదు లేదా కొన్నిtimes మనము
ఏమి చేయాలనుకుంటున్నామో అంటే PoC: proof of concept యొక్క
కొన్నింటిని చేయాలని కోరుకుంటున్నాము
#NAME?
ఇది ఎక్కువ సమయం తీసుకుంటుంది లేదా
మొత్తం ప్రక్రియ యొక్క ఒక త్వరిత
ప్రారంభం కలిగి ఉంటుంది.
ఎక్కడైతే కాపిటల్ ఎక్స్పెండీచర్  limitedంగా ఉంటుందో అక్కడ ఈ IaaS ఉపయోగపడుతుంది.
ఒక్ నిర్దిష్ట వ్యాపారానికి లేదా తాత్కాలిక అవస్థాపన
అవసరాలను లేదా ప్రూఫ్ ఒఫ్ కోన్సెప్ట్  IaaS ఉపయోగపడుతుంది.
ఏ సందర్భాల్లో ఇది ఉత్తమమైన ఎంపిక కాదో
చూద్దాం, ఎక్కడైతే , నిభంధనలు ఉంటాయో
అక్కడ data storage ని మరియు ప్రొసెసింగ్
ని ఆఫ్షోరింగ్ లేదా out సోర్సింగ్
 చెయ్యడం కస్టము.కొన్ని ముఖ్యమైన చట్టపరమైన
problemలు లేదా నియంత్రణా ఒప్పందాలు ఉండవచ్చు.
ఎక్కడైతే ఉన్నత స్థాయి పనితీరు అవసరం అవుతుందో,
మరియు ఒక institution అవసరాలను తీర్చడానికి on-premise
లేదా స్వంత host కు అత్యధిక సామర్థ్యం
ఉంటుంది.
మనము ఈ VM లను కలిగి ఉన్నప్పుటికీ, వర్చ్యువల్
మెషీన్ మానిటర్ పైన దానికి
సంభందించిన hardware మొదలైన వాటిని కలిగి
ఉండాలి.
తర్వాతనే మనం విభిన్న VM లను తయారు చేయగలం.
వీటన్నింటికి ప్రాథమికంగా కొంత మొత్తంలో resources
 మరియు కంప్యుటేషనల్ సమయం పడుతుంది.
కనుక , మనము పనితీరు యొక్క అత్యధిక స్థాయిని
కోరుకుంటున్నప్పుడు మరియు complex
పని అయినప్పుడు, IaaS అనేది సరైన ఎంపిక
కాదు.
సాస్ providerలో కొన్నింటిని
చూద్దాం , మనము దీనిపై వివరంగా వెళ్ళడం
లేదు. ఇందులో విభిన్న pricing models
 ఉన్నాయి.
వాటిలో కొన్ని pay as యు go model , కొన్ని ఉచితంగా లభించేవి, మరికొన్ని
సబ్స్క్రిప్షన్  ఆధారంగా లభించేవి.
ఇదేవిధంగా PaaS provider లకు కూడా ఉంటాయి.
అవి వివిధ రకాల ప్లాట్ఫార్మ్స్ data బేస్ , dataబేస్
 లోని పెద్ద పెద్ద టేబుల్ ని అందిస్తుంది.
కాబట్టి, మనము here చూస్తున్న విభిన్న
రకాలైన లక్షణాలను ,వివిధ రకాలైన కోయరాకు
ఉపయోగిస్తాము, వాటిలో కొన్ని డాట్ నెట్
platform , Web డెవలప్మెంట్
ఎంటర్ప్రైజెస్ application  మొదలైనవి.
ఇది వివిధ రకాలైన వ్యవస్థలను కలిగి
ఉంటుంది.
మరియు ఇతర IaaS providerలు కూడా కలిగి ఉంటుంది.
ఈ IaaS provider  లు వివిధ రకాలైన
hardware సామర్థ్యాలను కలిగి ఉంటాయి, వివిధ
రకాలైన ఆపరేటింగ్ Systemలు
ఉంటాయి మరియు మనకు విభిన్న రకాలైన బిల్లింగ్
విధానాలు ఉన్నాయి.
కాబట్టి, ఇవి IaaS provider యొక్క వివిధ రకాలు.
మనము ఇప్పటికే చర్చించినట్లుగా , ఈ భాగాల యొక్క సాధారణ
stackను మళ్ళీ ఆవిష్కరించినట్లయితే,
SaaS అనేది application  స్తాయి వరకు
service provider  నిర్వహిస్తారు.
కాబట్టి, here cloud Service provider యొక్క బాధ్యత application
స్థాయిలోనే ఉంటుంది, అయితే XaaS లో అయితే
ఈ నిర్వహణ బాధ్యత రన్time ఎన్విరాన్మెంట్
 తీసుకుంటుంది, తద్వారాData మరియు
applicationలు consumerలుగా
ఉంటాయి.
అదే IaaS విషయంలో Virtualization మరియు VM లను అందివ్వడం
provider యొక్క బాధ్యత, అయితే దానిలో
కొన్నిtimes provider గెస్ట్  OS ను అందిస్తుంది
లేదా గెస్ట్  OS ని load చేసుకోవచ్చు.
వర్చ్యువల్ mission లో load చేసుకోవాలి,
తద్వారా.
మిగిలిన విషయాలన్ని ప్రాథమికంగా IaaS consumerని
యొక్క బాధ్యత.
కాబట్టి, ఈ cloud యొక్క మరొక కోణాలను
పరిశీలిస్తే, networking ఉంది. ఈ నెట్ వర్కింగ్
చాలా ముఖ్యమైన పాత్రను పోషిస్తుంది, ఎందుకంటే
మనం విభిన్న hardware resources  ని
కలిగి ఉంటాము.
కనుక, ఈ విభిన్న resources  అన్నీ network
ద్వారా కలుపబడి ఉంటాయి, వీటిలో ప్రత్యేకంగా
రాక్ server లేదా బ్లేడు server మొదలైనవి ఉన్నాయి, ఈ network అనేది
cloud computing కి ఒక వెన్నెముక
అని చెప్పవచ్చు, ఎందుకంటే, ఈ networkలతో
, server లు అధిక ఆపరేటింగ్ స్పీడ్ ని కలిగి ఉంటాయి.
కాబట్టి, cloud computingలో network ముఖ్యమైన పాత్రను
పోషిస్తుంది.
network యొక్క మరొక అంశము, ఈ networkను
Virtualize చెయ్యగలామా లేదా
అనేది.
మనం మన institutionాగత అవసరానికి ఒక సాధారణ
network దృష్టాంశాన్ని కలిగి ఉంటాము.
మనం ప్రత్యేకమైన ఈవెంట్ కొరకు ఒక
network ని సెటప్ చేయాలనుకుంటే రౌటర్లుని
మరియు serverలుని మొదలగునవి గుర్తించాలి.
ఒక విధంగా దీన్ని ఎలా చూడవచ్చు అంటే
వేర్వేరు resources  ని purchase
చేసి వాటిని connect చెయ్యడం.
ఈ infrastructure  మొత్తాన్ని
మనం వర్చువలైజ్ చెయ్యగలమా లేదా , మొత్తంగా
virtual networkని సృష్టించగలమా
లేదా అనేది చూసుకోవాలి.
కాబట్టి,కొన్ని ఈవెంట్స్ కొరకు అక్కడ ఉన్నప్పుడే
ఈ networkనుని గుర్తిస్తాము, ఇవి
కొన్ని పరీక్షలు కావచ్చు, కొన్ని
ఇతర విభాగాలను ఏదో ఒకవిధంగా తయారుచేయడం
కావచ్చు.
తరువాత వాటిని నెట్ work నుండి దూరంగా
పంపిస్తాము.
మరో మాటలో చెప్పాలంటే, నేను ఈ విధమైన నెట్
వర్కింగ్ ను నిర్మించడానికి
ఒక మార్గం కలిగి ఉంటాము, అందుచే ఇది
మరొక అంశం. కాబట్టి, cloud computing
network resources  ని మనము చూసినట్లుగా
డైనమిక్గా కేటాయించవచ్చు.
cloud computing యొక్క cloud కోర్ను
రూపొందించగల కొన్ని networking 
అంశాలు ఉన్నాయి.
వాటిలో virtual లోకల్ ఏరియా network లేదా VLAN, VPN మరియు వేర్వేరు ప్రోటోcall
పొరలు అనేవి ప్రముఖంగా ఉంటాయి.
దీనికి వాస్తవ రూపాన్ని ఇవ్వడానికి OpenSSH, OpenVPN
అనే టూల్స్  మరియు పద్దతులు ఉపయోగపడతాయి.
వివిధ cloud modelస్లో networking
ఉంటే, అది పైన చూపిన విధంగా సాధారణ OSI
stack లాగా ఉంటుంది.
మనము IaaS లో చూస్తే,Data లింక్ లేయర్ వరకు provider చూసుకుంటుంది.
మిగిలిన లేయర్లన్నీ consumerని బాధ్యత.
ఇక SaaS విషయంలో, మొత్తం stack అంతా providerల
బాధ్యత.
PaaS విషయంలో అయితే ప్రెసెంటేషన్ లేయర్
 వరకు provider బాధ్యత, application
లేయర్  consumerని భాధ్యత.
కాబట్టి, ఈ OSI ను ఒక Service model గా గుర్తించాలని మీరు కోరుకుంటే,
వ్వివిధ రూపాల్లో చూడవచ్చు, మీరు మొత్తాన్ని
infrastructure  గా చూస్తే,
మొత్తాన్ని platform  గా లేదా Software
ని ఒక Service గా చూస్తాం.
కాబట్టి, నెట్ వర్కింగ్ ముఖ్యమైన పాత్ర పోషిస్తుంది.
network ఫంక్షన్ Virtualization కేవలం త్వరితంగా పరిచయం కలిగి ఉంటుందని
మేము చెప్pay మరో అంశం ఉంది. network
ఆపరేటర్లను వాస్తవిక సాంకేతిక
పరిజ్ఞానాన్ని రూపొందించడం ద్వారా అనేక network
పరికరాల రకాలను, పరిశ్రమ ప్రామాణిక
స్విచ్లు మొదలైనవిDataసెట్లలో
ఉంచవచ్చు.
మనం చర్చించబోతున్నట్లుగా infrastructure
 పై పని చేస్తామని చెప్పడానికి అది
ప్రయత్నిస్తుంది.
ఇది Software ప్రామాణిక server
hardware పరిధిలో అమలు చేయగల
Softwareలోని network ఫంక్షన్ల అమలును కలిగి ఉంటుంది మరియు కొత్త
పరికరాల inస్టలేషన్  చేయకుండా అవసరమైన
network యొక్క వివిధ ప్రదేశాల్లో
ఇది తక్షణం తరలించగలదు.
మా తర్వాతి చర్చలో నేను కొద్దిగా చర్చిస్తాను.
మనము ఒక infrastructure  కలిగి ఉంటే
వివిధ networkల ను తెలుసుకోవచ్చు,
ఇవి సంప్రదాయ విధానాలు మరియు here infrastructure
 ని కలిగి ఉంటే, ఈ ప్రాధమిక infrastructure
 మీద వివిధ network లను
గ్రహించటానికి ప్రయత్నిస్తాము లేదా ఒకే infrastructure
 పై వివిధ వర్చ్యువల్ network లు
కలిగి ఉంటుంది.
నేటి lecture hereితో ముగిస్తూ, తదుపరి
మన చర్చను కొనసాగిస్తాము .
ధన్యవాదాలు.
స్వాగతం.
నేడు, మన cloud architecture పై కొంత చర్చ
కొనసాగుతుంది మరియు ఒక cloud యొక్క
కొన్ని ప్రత్యేకమైన అంశాలను, అందులో
ఒకటి Virtualization  చూద్దాం.
మునుపటి Lecture  లలో మనము వివిధ
రకాలైన Service modelస్ పై చర్చించాం
, అలాగే cloudలో వివిధ రకాలైన deployమెంట్
modelలు,అయిన public , private ,
hybrid మరియు community cloud లు ఉన్నాయి.
వేర్వేరు అంశాలు మరియు అన్ని రకాలైన
serviceలు వేర్వేరు రకాలైన మోహరింపు modelలలో
host చేయబడతాయి, సరియైనవి.
ఒక public cloud, payరులో
సూచించినట్లుగానే ఇది ఎక్కువ మందికి
అందుబాటులో ఉంటుంది.
కనుక, దీన్ని ఎవరైనా purchase చేయవచ్చు
మరియు ఇది internet అంతటా అందుబాటులో
ఉంటుంది.
చాలా ప్రసిద్ధ ఉదాహరణలలో కొన్ని Google app Engine, microsoft azure, IBM cloud,
amazon EC2 మొదలనవి, అనేక ఇతర cloud
 లు ఉన్నాయి.
ఈ public cloud ని ఒక institution లేదా
వ్యక్తిగత అవసరాలకు Subscribe 
చెయ్యొచ్చు.
internetలో ఈ public cloud సబ్స్క్రిప్షన్  మరియు దాని
services  గురించిన వివరాలు ఉంటాయి.
కాబట్టి, ఈ cloud  infrastructure
 లు సామాన్య ప్రజానీకం, institutionలు
, enterprise  లు మరియు ఎవరైతే
చెల్లించి , ఉపయోగించగలరో వారి కోసం కేటాయించబడతాయి,
ఇందులో ఖచ్చితంగా కొన్ని చట్టపరమైన
విధాన problemలు ఉన్నాయి.
కాబట్టి, ఇది వ్యాపారం, విద్యావేత్తలు, ప్రభుత్వ
institution లేదా వాటి యొక్క కొన్ని Hybridizationల
ద్వారా నిర్వహించబడుతుంది.
ఇది cloud provider యొక్క అదీనంలో
ఉంటుంది.
కాబట్టి, భౌతికంగా ఇది CSP యొక్క ఆవరణలో
లేదా premisesలో ఉంటుంది, అందుచే
computing infrastructure, storage
infrastructure మరియు ఇతర
రకాలైనవి CSP లు లేదా cloud provider
premisesలో ఉంటాయి, అంతేకాని private
లేదా consumerల అదీనంలో ఉండవు, కాబట్టి
ఇది ఒక అంశం.
మరియు public అమరికలో, provider
యొక్క computing మరియు storage 
resources  అధిక మొత్తంలో సమర్థవంతంగా
ఉంటాయి , కాబట్టి ఇది అందరికీ ఉపయోగపడుతుంది.
Communication లింకు లు ,public
internet , service ల మీద
అమలు చేయబడతాయి; మరియు cloud service
 అనేది అన్ని client  యొక్క
ఒక విభిన్న సమూహం పై పనిచేస్తుంది
మరియు వాటిలో అందరూ విశ్వాసకులుగా ఉండకపోవచ్చు,
వారిలో కొనదారు హానిపరులు,హాకర్లు మొదలైనవాళ్లు ఉండవచ్చు.
కాబట్టి, ఇది సాధారణంగా ఒక service provider
ను కలిగి అందరికీ , ఎవరైతే Subscribe
 చేసుకుంటారో వారందరికి ఉపయోగకరంగా
ఉంటుంది.
ఇందులో విభిన్న రకాల consumerలు ఉంటారు.
విలక్షణమైన లక్షణాలలో ఒకటి workload
స్థానాలు client కు తెలియవు , ఇది ప్రధానమైన
వాటిలో ఒకటి consumerనిగా మన virtual machine మరియు మన వాస్తవికData ఎక్కడ ఉంటుందో
అంటే ఏ server లో లేదా ఏ virtual
machine  లో ఉంటుందో మనకు తెలియదు,
కాబట్టి, security మరియు ఇతర అంశాల గురించి
చట్టపరమైన మరియు విధానపరమైన అంశంపై
మీరు కఠినంగా లేకుంటే, మీరు శ్రద్ధ వహించకపోతే,
చాలా కాలం ఉండే మన servicesకి.
multi tens నుంచి ప్రమాదం ఉంటుంది;
అనగా, మన computing మరియు storage 
ఎక్కడ ఉంటుందో అక్కడ ఇతర consumerల
data కూడా ఉంటుంది.
ఇది తార్కికంగా లేదా theoretically సాధ్యం
అవుతుంది.
ఇప్పుడు, కొన్ని institutionలకు చెందిన
వ్యక్తులు లేదా మరికొందరు విశ్వాసం లేనివారు
వుంటే అది మనకు సౌకర్యవంతమైన కాదు, ఇద్దరు వేర్వేరు
consumerలు ఇద్దరూ ఇదే విషయాల్లో పనిచేయగలరు.
కాబట్టి, ఇతర అర్ధంలో here ప్రమాదం ఉంది;
ముందు మనం చూసిన multi-tenancy వలన కూడా నష్టాలు ఉన్నాయి, ఎందుకంటే
అక్కడ services  ఎక్కడ ఉన్నాయో
మనకు తెలియదు,Data servicesని
మరియు ఇతర రకాలైన resources  ని
access చేయడానికి ఒక నిర్ధేశిత channel
ఉన్నదా లేదా అనేది తెలియదు, కనుక, ఈ multi-tenancy వలన ప్రమాదం ఉంది. అందువల్ల, ఒకే machine
లు అన్నీ work load లకు , subscriber
 లకు share చేస్తారు.
ఈ work load లు పోటీదారు work
load లు అన్నీ కలిపి ఒకేచోట ఉంటాయి,
కాబట్టి ఇది reliability మరియు security ప్రమాదం
రెండింటిని పరిచయం చేస్తుంది.
onsite public cloud వినియోగాన్ని
పరిగణనలోకి తీసుకున్న institution network
dependency ని పరిగణించాలి.
ఎప్పుడైనా IIT Kharagpurలో lab ల్లో కొన్ని
public cloud లు నడుపుతున్నాము,
తద్వారా మా మొత్తం నిర్వహణ వ్యయం లేదా
నిర్వహణ load మొత్తం మీద తగ్గుతుంది.
ఇప్పుడు, మొదటి dependency network.
అందువల్ల, network connectivity ఎల్లప్పుడూ వరకు అందుబాటులో
ఉండాలి.
కనుక, ఇది ఒక dependency .
securityకు సంబంధించినDataపై limited
దృశ్యమానత మరియు నియంత్రణ ఉన్నాయి.
కాబట్టి, మనంData యొక్క limited దృశ్యమానతను
కలిగి ఉన్నాము.
data  ఎక్కడ ఉందో మనకు తెలియౌ మరియు
అది ఎలాంటి securityను కలిగి ఉన్నదో తెలియదు,
కేవలం ఒక విధమైన SLA లేదా ఒక provider
 తో మనం కుదుర్చుకున్న ఒక విధమైన ఒప్పనడం
లాంటి MOU మాత్రమే ఉంటుంది.
elasticity ; అlimited resources
 లభ్యత యొక్క స్థితిస్థాపకత లేదా
భ్రాంతి problem ఉంది. కాబట్టి, మీరు public
cloud ని ఉపయోగించినప్పుడు ఇది చాలా బాగా ఉపయోగకరంగా
ఉంటుంది, ఎందుకంటే సిద్దాంత పరంగా మనకు
మరింత computing శక్తి అవసరమైతే elasticity
 ని విడుదల చెయ్యొచ్చు.
ఆ విషయాలు సాధ్యమయ్యేవి.
అందువల్ల, theoretically అనంతమైన scaling
app , scaling down కు అవకాశం
ఉంది.
cloud లోకి మైగ్rate  అయ్యేటప్పుడు
తక్కువ app-ఫ్రంట్  cost  ఉంటుంది.
ఇది మరొక ముఖ్యమైన విషయం.
కాబట్టి, మీరు మీ సొంత private cloud ని నిర్మించాలనుకుంటే, మీరు resources ని
purchase చేసి వాటిని provision  కు
ఉంచాలి, Softwareను install చేయడం
మొదలైనవి అన్నీ ఉంటాయి; here maintenance
problemలను ఎదుర్కోవాలి.
క్కడ చాలా తక్కువ app ఫ్రంట్ ఖర్చు
ఉంటుంది , మీరు చెల్లించి దాన్ని ఉపయోగించుకోండి.
నియంత్రిత డిfault SLA లు ఉంటాయి, కాబట్టి
ఏదో ఒక resource  ని purchase
చేసినప్పుడు అది ప్రామాణికమైనదా
లేదా అని నిర్ధారించేందుకు, provider మరియు
consumerల మధ్య నిర్ధిష్ట service
level agreements  ఉంటాయి.
కాబట్టి, చాలా సందర్భాలలో ప్రత్యేకమైన నిబంధనలను
అనుసరించాల్సిన అవసరం ఉంది, వాటిలో
కొన్ని provider  ఏది ప్రొవైడ్
 చేస్తున్నారు, large scale deployమెంట్
 అనగా ప్రత్యేక రేటుతో, ప్రత్యేకమైన
SLA తో చర్చలు జరిపి తీసుకుంటామో.
కానీ సాధారణంగా ఒక చిన్న institution మరియు
ప్రజలకు ఏది అందించబడుతుందో అది మేము ధృవీకరించాల్సిన
అవసరం ఉంది.
మరొక అంశం private cloud .
మీరు మీ సొంత cloud  ని కలిగి ఉంటారు
మరియు దానిపై పనిచేసే అన్నీ resources
 ని కలిగి ఉంటాము.
కనుక, cloud infrastructure  అనేది ఒకే
institutionకు limitedమై ఉంటుంది.
ఆ institutionకు సంభందించిన అనేక consumerలు
లేదా వ్యాపార విభాగాలు వాటి ప్రత్యేక ఉపయోగం
కోసం దీన్ని వినియోగిస్తారు.
IIT KGP private cloud  resources
 ని, IIT  విభాగాలు, section  లు మొదలైన
వాటిలో అన్నింటిని కేటాయిస్తుంది.
దీని నిర్వహణ అనేది స్వయంగా ఉండచ్చు
లేదా institution ajamanyaంది కావచ్చు లేదా here
మూడవ party management resources 
ని outsource చేయవచ్చు, కానీ ఇది
మీ పరిధిలో, మీ network నియంత్రణలో మరియు
మీ premisesలో ఉంటుంది.
ఇది premises లోపల లేదా బయట కూడా ఉండవచ్చు.
ఇది సాధారణంగా, premisesలో ఉంటాయి లేదా private
సమూహాలు గా ఉంటాయి లేదా private cloud
ని outsource చెయ్యొచ్చు.
here నేను office premisesలోనే ఉన్నాను,
అయితే అది అధికార పరిధి లేదా నా పాలసీ
నియమ నిబంధనలను లేదా institution నియమాలను నిర్వహిస్తుంది.
కనుక, కొన్ని open source మరియు
ఇతర public cloud లో ఒకటి ప్రజాదరణ
పొందిన eucalyptus , open stack, ubuntu enterprise cloud, amazon
VPC - virtual private cloud,
VMware cloud infrastructureస్ suite, microsoft
ECIData centers మొదలైనవి.
private cloud లో అనేక విషయాలు
ఉన్నాయి.
ప్రముఖ నమ్మకానికి విరుద్ధంగా, private
cloud premisesలో ఉండకుండా, మూడవ పక్షం
ద్వారా నిర్వహించబడవచ్చు.
బాధ్యత తీసుకోవడమే కాకుండా, ప్రధానంగా
మొత్తం మీద నియంత్రణను కొనసాగించాలని కోరుకుంటున్నాను,
కానీ నేను ప్రాధమికంగా ఆవరణలో ఉన్నాను లేదా
నేను ఒక మూడవ పక్షం సహాయంతో కూడా ఒక
ప్రత్యేకమైన resources  ని install
చేసుకోవచ్చు.
అందువలన, రెండు private cloud scenarios
 ఉన్నాయి.
అందులో ఒకటి on site private cloud
, ఇది వాస్తవంగా ఉంది లేదా customer
premisesలో అమలు చేయబడిన private
cloud లకు వర్తిస్తుంది, ఇది privateగా ఉన్న
దాని గురించి మాట్లాడుతున్నప్పుడు మనకు గుర్తుకు వస్తుంది.
customer  premisesలో లో private cloud
 ను implement  చేస్తుంది.
మరొకటి out sourced private cloud
, ఇది private అయినా premises
దాటి Outsource చేస్తుంది.
అందువల్ల, private cloudకు వర్తిస్తుంది,
అక్కడ server side  ను
hosting company కి outsource
చేయబడుతుంది.
on site private cloud
విషయంలో, security అనేది రెండింటి subscriberస్
on site resources మరియు private
cloud resources రెండింటినీ
విస్తరించి ఉంటుంది.
security లేదా మీ చట్టపరమైన నియంత్రణ ప్రాథమికంగా
private cloud ని కలిగి ఉంటుంది.
security perimeter private cloud
resources పై నియంత్రణకు
haami (Not an English word but included for context) ఇవ్వదు, కానీ subscriberస్
ఇతర వనరులపై నియంత్రణను కలిగి ఉంటారు.
అదే on site అయితే, అక్కడ ఏ private
cloud ఉన్నా, దాని యొక్క మొత్తం
resources పై మనం మొత్తం నియంత్రణను
కలిగి ఉంటాము.
కొన్ని అంశాలు client యొక్కon site private
cloud ని నిర్వహించడంలో కొన్ని
అనుకూల లక్షణాలను మరియు ప్రతికూల లక్షణాలు
కలిగి ఉంటాయి, వీటిలో ఒకటి network dependency on site private.
ఇది మీ internet network
పై ఆధారపడి ఉంటుంది.
ఒక institution దాని సొంత cloud నిర్వహించడానికి
లేదా institution సొంత cloud నిర్వహించడానికి
subscriber కి IT నైపుణ్యం అవసరం.
కాబట్టి, దానిని నిర్వహించడానికి
ఒక విధమైన నైపుణ్యం ఉండాలి.
work load  స్థావరాలు client కు తెలియవు.
వివిధ client  లు వేర్వేరు సబ్
unit  లో ఉన్నప్పటికి, work load  స్థావరాలు
client కు తెలియవు.
premisesలో లేదా on site private
cloud లో ఉన్నకూడా, నిజానికి
cloud నుండి inఫ్రాసృక్టురే  ని దాచి పెడుతుంది,
ఎక్కడైతే ఆ institution client  గా లేదా
institution client మరో వైపు ఉంటాయి.
multi-tenancy నుంచి వచ్చే ప్రమాదం
మరో అంశం . ఇంకొక సమయData దిగుమతి egumati
మరియు పనితీరు limitedులు.
hereData దిగుమతి egumati సంభందించిన
problemలు ఉంటాయి ఎందుకంటే చాలాDataను పెరుగుతూ,
తగ్గుతూ ఉంటుంది.
కనుక, on site private cloud network సామర్థ్యం వలన on డిమాండ్
 data  దిగుమతి egumati limitedంగా
ఉంటుంది మరియు real time లేదా complex
processing ఈ networking 
లోపల వలన problemాత్మకంగా మారవచ్చు.
external threat ల నుండి బలమైన security,
ఇది మన network సరిహద్దులోని ఒక
private cloud  అయితే మన network
యొక్క అన్ని ఇతర features వస్తాయి.
మన ముందు lectureలో కొన్నింటిని ప్రస్తావించినట్లుగా,
IIT, Kharagpur దాని పరిశోధన ప్రయోజనం
కోసం ఒక private cloud ని development
చేసింది, దాని payరు Meghamala, అది ఆ network
పరిధిలోనే ఉంది. కాబట్టి, IIT, Kharagpur
కు ఏయే network security limitedులు
లేదా లక్షణాలు ఉన్నాయో , అవన్నీ కూడా ఈ infrastructure
కు వర్తించబడుతుంది.
అందువల్ల, ఇది powerful బలమైన security లక్షణాలను
కలిగి ఉంటుంది.
cloud లోకి మైగ్rate  అవ్వటానికి అధిక
app ఫ్రంట్ cost అవుతుంది.
ఇది మరొక problem.
మన దగ్గర ఒక private cloud ఉన్నట్లైతే.
దానిని install చేసి నిర్వహించడానికి
మరియు private cloud లోకి మైగ్rate
అవ్వడానికి significant ఖర్చు అవుతుంది.
ఇందులో, limited resources  ఉంటాయి, కనుక
కొన్ని times మనం purchase చేయవలసిన
అవసరం రావచ్చు, అది ఇప్పటికే ఉన్న విషయాలతో
సరిగా అనుసంధానం కావాలి.
కొన్ని times, scalable resourceలు
ఉన్నప్పుడు ఈ resources  ఆవసరం పెరగడం,
reduce జరగవచ్చు.
ఏ నిర్దిష్ట సమయం లో అయినా on site
private cloud లో ఊహించిన
work load  మరియు ఖర్చు అనుగుణంగా,
ఒక స్థిర computing మరియు storage 
సామర్ధ్యం కలిగి ఉంటుంది.
మనం ఒక private cloud ని install
చెయ్యాలనుకున్న, storage , computing,
మొదలైనవాటిని అంచనా వేయాలి.
తర్వాత ఒక సదుపాయం, ఒక partnership దీన్ని
x amount purchase చేసి , 1.5 total install
చేస్తే , దాని యొక్క limitedి 1.5x అవుతుంది.
ఇది నేను privateగా ఉపయోగిస్తున్న వాటిలో
ఇంకొక వైవిధ్యమైనది here చర్చిస్తాము,
కానీ నేను దానిని outsource
చేస్తాను, అనగా నిర్వహణ, management మొదలైనవి,
నా objective, institution protection తీసుకోదు
అని కాదు, కానీ అది outsource
చేస్తుంది, కాబట్టి source  లేకుండా
outsource చెయ్యడం.
outsource private cloud
రెండు security limitedులను కలిగి ఉంటుంది,అందులో
ఒకటి cloud లో ఉన్న subscriberఅమలు
చేసేది ,మరియు provider చే అమలు చేయబడేది.
కాబట్టి, ఇది ఒక perimeter.
here ఏమి జరుగుతుందంటే ఒక విధమైన ఛానల్,
ఇతర premisesలో outsource చేయబడిన private
cloudకి లేదా కొన్ని cloud Service
provider యొక్క ఉపసమితి
కి కలుపుతుంది.
కాబట్టి, వీటన్నిటిని కలపడానికి నేను ఒక
ఛానల్ కలిగి ఉంటాను, కానీ చివరికి మొత్తం
private గా ఉంటుంది.
కాబట్టి, outsource private cloud లో నిర్వహించేData మరియు processing
యొక్క security, security limitedుల మరియు సురక్షిత
Communication యొక్క బలం మరియు
లభ్యత పై ఆధారపడి ఉంటుంది.
కాబట్టి, external విషయాల్లో మన infrastructure
 భద్రపరచబడాలని కోరుతున్నాము, మన
కమ్యూనికేట్  అయ్యే ఛానల్ లేదా
network connection లింక్ ఒక
నిర్ధిష్ట స్థాయి వరకు securityను పాటిస్తూ
సురక్షితమై ఉండాలి.
out sourced private cloud 
ఉపయోగించుకోవడంలో ఉన్న ప్రయోజనాలు
మరియు appరయోజనాలు చూద్దాం.
అందులో ఒకటి network dependency  అనగా మనం ముందు చర్చించుకున్నట్లుగా
అన్నీ ఎలా connect చేయబడ్డాయి అనే దాని
పై ఆధారపడటం.
workload స్థానాలను clientకు తెలియకుండా
ఉంచడం లాంటి problemలు.
multi tenancy  problemలు అనగా,
మనం మన private cloud ని ఎక్కడ
hosting చేస్తున్నామో, అక్కడ ఇతర వ్యక్తులు
కూడా private cloud ని host చేయవచ్చు.
data దిగుమతి, egumati మరియు పనితీరు limitedి
అదే problemలు ఉన్నాయి.
external threatస్  నుండి బలమైన
security అవసరం.
ఎందువలన అనగా ఇప్పటికీ మన వ్యక్తిగత విషయాలు
ఉన్నాయి, ఇది completely public కాదు
మరియు అందరూ వ్యక్తులు మన cloud లోకి
రాలేరు, అయితే మీరు బహుశా infrastructure
ని పంచుకోవడం మరింత తక్కువ స్థాయిలో
ఉంటుంది.
కానీ ఉన్నత స్థాయిలో మీరు ఎవరికీ విషయాలు
పంచడానికి లేదు.
cloud లో కి మైగ్rate  అవ్వడానికి Tierలు
మధ్యరకం నుంచి గరిష్టంగా ఉంటాయి ఇవ్వన్ని
కూడా ముందుగా చెప్పుకున్నవే.
మరియు ఎక్కువ సంTier్భాలలో , మనకు ఈ cloud అందించే
provider  లేదా మూడవ party అందించే
provider తో SLA పరంగా చర్చలు అవసరం.
విస్తృతమైన resource లభ్యత బహుశా ఒక ప్రయోజనం,
ఎందుకంటే ఇది limitedం కాదు. నేను ఒక అవకాశాన్ని
తీసుకుంటాను, సాధ్యమైనంత resource లభ్యత
ను పెంచడానికి అభ్యర్థిస్తాను.
provider resource  లేకుండా ఉండరు,
సాధారణంగా వారి దగ్గర resourceలు
ఉంటాయి.
కాబట్టి, ఒక వైపు private cloud
 మరో వైపు public cloud  ఉన్నాయి,
ఇవే కాకుండా మరొక సాధారణ cloud
community cloud ఉంది. కాబట్టి,
మనం ముందుగా చర్చించుకున్నట్లుగా ప్రధానంగా ఇది ఒక
ప్రత్యేక community కి services
ని అందిస్తుంది.
ఇది సాధారణంగా ఒక public మరియు private
రెండింటిలో పనిచేయగలదు మరియు ఇది ప్రాథమికంగా
ఒక ప్రత్యేకమైన ప్రత్యేక community కి
services ని అందిస్తుంది.
ఏదైతే దాని operation కి ఒకే domain లేదా
ఒకే లక్ష్యం కలిగిన interoperating
ఉంటుందో దానికి.
అందువల్ల cloud infrastructure
ని, institution యొక్క ప్రత్యేకమైన community యొక్క
ప్రత్యేకమైన ఉపయోగం కోసం ఉద్దేశించబడ్డాయి,
అంటే వాటికి సంబంధించిన విషయాలు, ఆ community
 యొక్క mission , security అవసరాలు,
పాలసీ సమ్మతి పరిశీలన, మొదలైనవి ఉండవచ్చు,
దీనిని ఆ community లో ఉన్న ఒకటి లేదా
అంతకంటే ఎక్కువ institutionలు నిర్వహించవచ్చు.
కాబట్టి, థర్డ్ party  లేదా వారి Hybridizationతో
అది premisesలో ఉండి ఉండవచ్చు లేదా బయట
ఉండవచ్చు.
అందువల్ల అది premises లోపల లేదా premises
భయట ఉండవచ్చు, అనేక community cloud లు వేర్వేరు service provider
ద్వారా అందించబడుతున్నాయి.
here A, B, C అనే institutionలు మరియు అనేక X, Y, Z institutionలు
ఉన్నాయి.
వాటిని ABC, XYZ వంటి విభిన్న Hybridizationలను ఏర్పరచగలవు
అది ఒక community కావచ్చు; X, Y తో ఏ కలిసి
మరొక community గా ఈవిధంగా వేర్వేరు
community  లు గా ఏర్పడవచ్చు.
అన్నిటిని కలిసి తీసుకురావడానికి
అవకాశం ఉంది. ఒక community కొంత సమయం వరకు ఉండవచ్చు
లేదా ఇతర సమయాలలో ఇది ఉనికిలో ఉండకపోవచ్చు,
రోజువారీ జీవితం లో ఒక institution కు ఒకటి
కంటే ఎక్కువ community  లు ఉండవచ్చు.
మనం మన office లో ఒక భాగమే కావచ్చు.
దానితో పాటు నివాస community  లో
కూడా భాగంగా ఉంటాము.
కాబట్టి, విభిన్న విధానాలు ఉండవచ్చు
మరియు ఇతర విషయాలు కూడా ఉన్నాయి, కానీ
ప్రధాన objective ఏమిటంటే, ఒకే రకమైన
సంబంధిత లేదా work flow  ఉంటుంది.
ఒకే రకమైన వాటిని ఒకే community 
లో తయారుచేయడానికి మరియు ఉత్పాదకతకు
ఈ సంఘం సహాయపడుతుంది.
here మరలా దీని లక్షణాలు ,లాభాలు
మరియు నష్టాలు మొదైలన వాటి గురించి తెలుసుకుందాం.
భాగస్వామ్య institutionలు సరిహద్దు నియంత్రికల
మధ్య ఒక అనుసంధానముతో కలుపబడి ఉంటాయి,
మరియు firewall విధానాలు లేదా సరిహద్దు
విధానాల వంటి వాటి security పారామితుల
ద్వారా access  ను అనుమతించును.
community cloud యొక్క access 
విధానం సంcomplexగా ఉండవచ్చు ఎందుకంటే
ఇందులో ఎక్కువ community  లు ఉంటాయి.
అందువల్ల, access  చేయలేని data
 ను ఏ విధానం లో access  చేస్తున్నాం,
ఎదైనా community  సమాచారాన్ని
మరొక community  కి పంపడం, లాంటివి
limitedం చేయాలి.
వీటికి role  ఆధారిత access నియంత్రణ,
లక్షణం ఆధారిత access నియంత్రణ వంటి విధాన
వివరణ పద్ధతులు ఉన్నాయి; నా role  ఆధారంగా
నేను కొంతDataను access చేస్తున్నాను.
మరియు విస్తరణ modelల యొక్క ఇతర రూపం వలె,
here కూడా మేము network dependency ని కలిగి ఉన్నాము.
subscriber  కి ఇప్పటికీ కొన్ని
IT నైపుణ్యాలు అవసరం ఎందుకంటే, ఇది వివిధ
community విషయాలు నిర్వహించడానికి
అవసరం.
workload స్థానాలు client నుండి
మళ్లీ దాచబడతాయి.
data దిగుమతి egumati మరియు performance
limitedులు, community  ల మధ్య, community
 లోపల ఎక్కువ subscriber 
లు ఉనప్పుడు data  కు సంభందించిన
problemలు ఉన్నాయి.
చాలా సంధార్భాలలో community 
లు చాలా loosely coupled గా ఉంటాయ, తద్వారా
బలమైన securityను నిర్వహించడం, మరింత complexగా
మారుతుంది, ఎందుకంటే మీరు ఇప్పటికీ ఒక
community లో ఉన్నారు, తద్వారా
మీ community విధానాల ఆధారంగా
మరియు మీ సొంత విధానంతో external threatస్ కు మంచి ప్రతిఘటన ఉంటుంది.
cloud కు మైగ్rate  అవ్వడానికి అయ్యే
అధిక స్థిరత్వం లేని app-ఫ్రంట్ ఖర్చులు,
నిజమైన private cloud విషయంలో
మనము చూసినట్లుగా, cloud కు మైగ్rate
 అవ్వడానికి అధిక app-ఫ్రంట్ ఖర్చులు
ఉంటాయి, ఎందుకంటే ఇది public  గా
లభించదు.
కాబట్టి, వీటిని మనం create 
చేసుకోవాలి.
విభిన్న విధానాలు, అంటే కొన్ని institutionలు
కలసి అక్కడ కొన్ని సరిహద్దు నియంత్రికతో
ఏర్పరుస్తాయి.
ఇది private subscriber  మరియు దాని
అంశాలతో కూడుకుని ఉంటుంది.
community cloud అనేది on ప్రిమేసిస్లో లేదా off-premisesలో అయినా ఉంటుంది.
అనగా, ఒక private cloud విషయంలో
మనం చూసినట్లుగా community cloud కూడా outsource చెయ్యవచ్చు.
కాబట్టి, ఒకసారి మేము network dependencyని outsource చేస్తే, work
స్థానాలు clients  కి తెలియదు.
multi-tenancy,Data దిగుమతి
egumati మరియు performance  limitedి problemల
నుండి వచ్చే అపాయం, ఇది మనం చెప్పిన
విధంగా external threatస్ 
ల నుండి powerful security ఉంటుంది.
మోడrate-నుంచి-అధిక app ఫ్రంట్ వ్యయం,
ఒక సొంస్థ లో outsource చేస్తే చాలా load
లు తీసుకుంటుంది.
కాబట్టి, మొత్తం loading మనం in
premise కొనసాగితే, మొత్తం ఖర్చు తక్కువగా
ఉంటుంది.
మరియు theoretically, మీరు outsourcing చేస్తే విస్తృతమైన resource లభ్యత
సాధ్యమే.
మనం theoretically చూసినా లేదా ఆచరణాత్మకంగా
చూసినా నేను ఆ cloud అనేది అన్నిటి Hybridization.
మనం private, public, community
cloud లను కలిగి ఉంటాము.
ప్రత్యేకంగా private cloud , public
cloud  లా కాకుండా ఇది ఒకటి కంటే ఎక్కువ
రకాలైన modelల Hybridizationతో ఉంటుంది.
cloud infrastructure అనేది రెండు విభిన్న
cloud infrastructure  private,
community లేదా public cloud
 ల యొక్క Hybridization.
కాబట్టి, here మూడు రకాలైన అంశాలు ఉన్నాయి,
మరియు ఈ మూడు అంశాల Hybridizationతో ఉన్న cloud
ని ఉపయోగించాలనుకుంటున్నాం.
ఎందుకు, ఇది ముఖ్యం అంటే, అంటే మొదటిది
ఏ విధమైన model ఉపయోగిస్తున్నాం అనేదానిపై ఆధారపడి
ఉంటుంది.
మన దగ్గర ఉన్న కొన్ని consumerల modelలు,
ఏవైతే private గా చెయ్యాలనుకుంటున్నామో
అవి security threatస్ కి మరింత
complexగా లేదా ప్రమాదకరమైనవిగా
ఉంటాయి.
నేను తగిన network సరిహద్దు లేదా network
చుట్టుకొలత securityను కలిగి ఉండాలని అనుకోవడం
లేదు. here కొన్ని resource లో
కొన్ని చాలా secure కావని నేను కోరుకోకపోవచ్చు
లేదా అన్ని విషయాలలోని అన్ని security గురించి
నేను పట్టించుకోను మరియు కొన్నిటిని
public గా తయారు చేయవచ్చు.
విద్యార్థులకు computing labs కోసం
practice sessions ఉంటాయి, అందువల్ల
security స్థాయి విద్యార్థి రికార్డులు లేదా
విద్యార్థుల పరీక్షా విషయాలు మొదలైనవాటిని
ఉంచినప్పుడికంటే చాలా తక్కువగా ఉంటుంది.
కాబట్టి, అదే రకమైన కార్యకలాపాలను కలిగి
ఉండవచ్చు, కానీ కొన్నింటిని మాత్రం బయట కలిగి
ఉంటాను మరియు దానిని outsource
చేయడం మరియు public cloud కి పంపవచ్చు.
మరియు మరొకొన్నింటిని ఆర్థికంగా ఉన్నప్పటికీ,
నా వ్యక్తిగత విషయాలను నేను private
గా ఉంచాలని అనుకుంటున్నాను.
ఇప్పుడు, నేను ఒక private Hybridizationలు
కలిగిన cloud ని తీసుకుంటాను.
సందర్భానుసారంగా, కొన్ని times మీరు
private గా ఏదో ఒకటి చేస్తారనేది
జరుగుతుంది, మరియు మీరు కొన్ని రిసోర్సెస్
ఆకస్మిక పెరుగుదల కారణంగా ఏర్పాటు
చేయవలసి ఉంటుంది.
appపుడు అకస్మాత్తుగా private cloud లో resource provisioning లేదా purchase
చేయడం మొదలైనవి sudeergh ప్రక్రియ.
కనుక, మీరు ఒక స్వల్ప కాలానికి ఒక public
cloud లో resourceని purchase చేయవచ్చు.
అందువల్ల, infrastructure community  ఏకైక institutionలను అలాగే ఉంచుతుంది.
కానీData మరియు applicationలు
portable అయ్యేలా చేసే ప్రామాణిక లేదా
ajamanya సాంకేతికతతో కలిసి సరిహద్దులుగా
ఉంటాయి, ఇది ముఖ్యమైనది.
కాబట్టి, portability అనేదిData కు
మాత్రమే సంబంధించింది కాదు, నేను ఈ private,
public, community అన్ని కలిసి, రెండు
లేదా అంతకంటే ఎక్కువ Hybridizationను కలిగి ఉన్నపుడు,
intra operative అనే ఇతర అంశం
ఉంటుంది, మరో చోటు నుంచి మనము application
తీసుకున్నప్పుడు data అనేది బాగా
పని చేస్తుంది.
data మరియు కొన్నిtimes applicationలు రెండు
కూడా, మన application ఒక private cloud పై నడుస్తున్నది అనుకుందాం, ఇప్పుడు
మీరు ప్రధానంగా public domain కు వెళ్ళే
ఒక VM ను ప్రొవైడ్ చెయ్యొచ్చు.
ఇప్పుడు, కొన్ని రకాల application
లను, అనగా ఏ appప్లికటిన్కి size ను మార్చలో
లేదా ఆ application  యొక్క portability
కి సంభందించిన problemలు పరిశీలించవలసి వుంటుంది.
కాబట్టి, కొన్ని hybrid cloud ఉదాహరణలు, ప్రముఖ windows azure  hybrid cloud, VMware V cloud
యొక్క సామర్ధ్యం కలిగిన కొన్ని ఉన్నాయి;
మరియు ఈ రకమైన విషయాలను అందించే అనేక ఇతర
providerలు ఉన్నాయి.
కాబట్టి, hybrid cloud రెండు
లేదా అంతకన్నా ఎక్కువ private, public
ల Hybridizationతో కూడి ఉంటుంది, అవి hybrid
ను నిర్మించటానికి ఎంపిక చేయబడిన cloud
యొక్క రకాన్ని బట్టి Performance, reliability,
securityలో significant వైవిధ్యాలు ఉన్నాయి.
ఇది ఒక community cloud లేదా
public మొదలైనవి అయి ఉంటే దాని security
లక్షణాలు, వేర్వేరు performance
లో తేడా ఉంటుంది.
కాబట్టి, hybrid cloud చాలా
complexది, ఇది ప్రధానమైన వాటిలో
ఒకటి. మీ ప్రత్యేక application
జరుగుతుందని అనుకుందాం మరియు public
మరియు private cloud Hybridizationపై అమలు
కావాల్సి వస్తే, appపుడు మొత్తం నిర్మాణాత్మక
architecture  చాలా complexదిగా
ఉండవచ్చు, అందువల్ల మీ application
సజావుగా నడుస్తుంది.
కాబట్టి, కొన్నిtimes ఈ private cloud లు చాలా సంcomplexగా ఉంటాయి.
కాలక్రమేణా ఈ cloud లు అన్నీ కలిపి
ఒక hybrid cloud గా మారవచ్చు.
మీ స్వంత private cloud ని మరియు
మరో రెండు public cloudతో ఒక
hybrid cloud ని నిర్మించగలం.
ఇప్పుడు నిబంధనలు మరియు షరతుల ముగింపుల
ఆధారంగా public cloud  ని డిస్connect
చెయ్యొచ్చు, మీ public cloud  నుంచి
మారవచ్చు, వారు మళ్లీ membership పొందాలని
కోరుకోరు మరియు వారు వేరే Tier model
ను కలిగి ఉంటారు, కాబట్టి, ఆ సందర్భంలో,
అక్కడ చేరడం, వదిలివేయడం మరియు క్రొత్త విషయాలను
చేర్చుకోవడం లేదా కొన్నిtimes మీకు
మరింత resources  కు అవసరం కావచ్చు.
కాబట్టి, మీరు మరిన్ని public లేదా
community cloud లను చేర్చుతారు.
ఇది అంతా నిర్వహించ్డం అంటే చాలా సంcomplex
విషయం, అంటే, కాలక్రమేణా, అందులో ఉన్న cloudస్
వెళ్లిపోవచ్చు లేదా చేరవచ్చు మరియు మొత్తం
ప్రక్రియ సంcomplexగా తయారవుతుంది.
కాబట్టి ఇప్పుడు నేను ఏది ఎంచుకోవాలి?
నా deployమెంట్ model ఏమిటి
అనేది పెద్ద ప్రశ్న.
ఇది మీ అవసరం మీద completely ఆధారపడి
ఉంటుంది.
మనది చిన్న institutionను లేదా వ్యక్తులకు,
public cloud మంచి పరిష్కారంగా
ఉంటుంది.
కనుక, మన business ఎక్కువ కాలం appఫ్రంట్
 Tierను భరించలేక , ఒక సొంత private
cloud వెళ్ళడానికి ప్రోత్సహిస్తుంది.
here ఇతర constants , ఇంకొకరికి business
 చెయ్యడం, నేను కొన్ని ఇతర subscriber
 బేస్ లేదా client బేస్ కలిగి ఉండటం, ఇప్పుడు ఈ client, ఒక
storage  provider,Data storage provider కొరకు చూస్తూ ఉంటుంది.
ఇప్పుడు, నేను నా premisesలో ఈ అన్ని
storage లను కలిగి ఉండవచ్చు లేదా
నేను ఈ resources ను outsource
చేస్తాను లేదా ఇతర public cloud  ల నుండి ఈ resources ను అందిస్తారు.
ఇప్పుడు, ఇలా జరిగేది ఎందుకంటే clientస్
 mission complex వారు, అయినా clientస్
అనేవి ఆర్థిక రంగం లేదా రక్షణ రంగం
అయితే , appపుడు ఏమీ జరగదు, here అన్నీ
సొంత విషయంగా ఉండాలి.
కనుక, ఇవి అన్ని మనం చూసే మార్గం పై ఆధారపడి
ఉంటుంది.
నేను hybrid గురించి మాట్లాడినందున, నా
అవసరానికి అనుగుణంగా, private, public
మొదలైన వాటి Hybridizationను కలిగి ఉంటాను.
లేదా నా application  వేర్వేరుగా
, dataను వేర్వేరు వర్గాలుగా వర్గీకరించవచ్చు,
మరియు appపుడు నేను ఈ వర్గాన్ని private
 కు వెళ్లగలనని చెప్తాను, ఈ సమూహం
public కు వెళ్లవచ్చు, ఈ community 
ని community cloud కి వెళ్లవచ్చు.
కాబట్టి, అన్నింటిని నిర్వహించడం లేదా
institution లేదా institution కోసం నిర్వహించడానికి
మరొక పెద్ద సవాలు.
కాబట్టి, మేము ఈ lectureను ముగిస్తున్నాము.
తరువాతి చర్చలలో cloud computing యొక్క ఇతర అంశాలపై మా lecture కొనసాగుతుంది.
ధన్యవాదాలు.
లో మా తదుపరి lectureకు స్వాగతం.
మేము త్వరగా Virtualization  గురించి తెలుసుకుందాం.
మేము ఇప్పటికే మన మునుపటి ఉపన్యాసాలలో
ఈ అంశాలను కొన్ని చర్చించారు.
here కోర్  అంశాల పై మరికొన్ని Slideలు
వున్నాయి, అది ప్రధాన భావనలలో ఒకటి. అందువల్ల,
ఈ cloud computing యొక్క Virtualization
అనేది ప్రధాన అంశాలలో ఒకటి. ఇది cloud
computing ఉన్నప్పటి నుంచే
, Virtualization  ఉంది. కనుక
ఇది కొత్త విషయం కాదు. మనలో చాలామంది
Virtualization  ఉపయోగిస్తున్నారు.
LINUX సిస్టం మీద, ఒక విండో Systemపై మనం Virtualization  చేస్తాము.
కాబట్టి, నేను ఒక విధమైన virtual
రియలైజేషన్ కలిగి ఉన్నాను.
మరో వైపు చూస్తే, networking,
మొదలైనటువంటి వివిధ ఇతర రెsource 
లను ఉపయోగిస్తారు.
కాబట్టి, మనము బాగా ప్రసిద్ది చెందిన
virtual LAN లేదా VLAN ను కలిగి ఉంటాము,
అనగా virtual private network మొదలగునవి కలిగి ఉంటాము.
వర్చ్యులైజేషన్ ఉంది. మరియు ఈ cloud
computing నిర్మాణ సాంకేతికత,
cloud యొక్క వివిధ service
లు అందించడం కోసం ఈ లక్షణాన్ని ఉపయోగిస్తుంది.
కాబట్టి, దీనిని IaaS లేదా infrastructure
as ఆ service  గా చూసాము.
subscriber  దృష్టిలో, subscriber
 ఏమి పొందుతాడు.
అంటే, వర్చ్యువల్ computerలు, network access, వర్చ్యువల్ storage, firewall, network infrastructure
లో ఒక భాగం అయిన ఫైర్ వాల్  కాన్ఫిగరేషన్
 services , మొదలైనవి.
నేను ఒక subscriber  గా , virtual
మెషీన్  లేదా machine  సమితిని
access  చేయగలను.
ఆపై, నేను నిర్దిష్ట storage  మరియు
ఇతర  తో ప్రత్యేక machine కోరుతాను.
కానీ aది ఎక్కడ ఉందో, ఎలా కాన్ఫిగర్ 
అయ్యిందో తెలియదు.
కానీ నాకు ఈ ప్రత్యేకమైన interface ద్వారా
ఉండే; machine ల రకం. మన దగ్గర ప్రత్యేకమైన
network తో పాటు virtual మెషీన్
 Hybridizationను కలిగి ఉండడం సాధ్యమే, మరియు
మన ప్రయోజనం కోసం, ఒక నెట్ work
ను అవస్థాపన చేయడం కూడా సాధ్యమే.
కాబట్టి, ఇదే subscriber మన దగ్గర నుంచి తీసుకుని
మరియు ఎలా చెల్లించాలి, ఎలా ఉపయోగించాలి
అనేది చూస్తాం.
ప్రధానంగా , సాధారణంగా, CPU గంటకు, storage
dataకి GB, ఒక గంట ఆధారంగా చెల్లించవచ్చు.
ఒక నిర్దిష్ట rate లో వినియోగించిన
network బ్యాండ్విడ్త్, network infrastructure
 ఉపయోగించబడుతుంది.
ఎంత IP అడ్రెస్, అనగా ఏ రౌటెర్స్ మొదలైనవి
మరియు విలువ ఆధారిత services.
అనగా, ఆటోమేటిక్ scaling
పర్యవేక్షన మొదలైనవి విలువ ఆధారిత serviceలు.
providerలు theoretically వర్చ్యువల్
missionల సమితిని కలిగి ఉంటారు; అంటే,
నేను ఒక cloud Service provider ని, నా వద్ద ఈ రకమైన వర్చ్యువల్
missionలు లు ఉన్నాయి.
మీరు వర్చ్యువల్ mission యొక్క
సమితి కావాలనుకుంటే, appపుడు నేను దానిని
provision చేస్తాను.
సాధారణంగా ఇవి వివిధ రకాలు గా ఉంటాయి.
theoretically, నేను ఏ వర్చ్యువల్ mission కాన్ఫిగర్  చెయ్యగలిగినా, కానీ
ఆచరణాత్మక అర్ధంలో ఇది నిర్దిష్ట కాన్ఫిగర్
 మొదలైనవి కలిగి ఉంటుంది.
ఐ.ఐ.టి Kharagpur, మెగామాలా విషయంలో మాదిరిగా
చాలా తక్కువ సామర్ధ్యం ఉన్న VM కలిగి ఉంది.
here 3 రకాల వర్చ్యువల్ missionలు ఉన్నాయి,
వాటిలో ఒకటి IIT KGP VM లు, ఇది 4 GB RAM, 20 GB హార్డ్
డిస్క్ స్payస్ మరియు ఇతర processing
మొదలైనవి కలిగి ఉంది. రెండవది IIT KGP large,
ఇది ఇప్పటివరకు ఒక 8GB RAM కలిగి ఉంది. చివరిది
IIT KGP ఎక్స్ట్రా large , ఇది 60 GB RAM ను
కలిగి ఉంది; ఇప్పుడు, resource  లభ్యత
ఆధారంగా, వివిధ రకాల VM ల Hybridization మాత్రమే
కాక, ఏ VM కావాలనే అభ్యర్థన రకం మీద కూడా ఆధారపడి
ఉంటుంది.
స్మాల్  VM కు భారీ రెక్వెస్ట్ లను
కలిగి ఉన్నట్లయితే, హైయర్  VM కంటే ఆ
స్మాల్  VM ను కేటాయించాలని అనుకుంటాము.
ఈ పరిగణనలు ఉంటాయి.
కాబట్టి, ఈ సందర్భంలో client A కు
VM1 నుంచి VM2 కు access ఉంది. అయితే, B కు VM3
కు access ఉంది, here client C
VM4 నుంచి VM6 కు access ఉంటుంది.
providerలు ఇతర consumerలకు
VM7 నుంచి VMn వరకు అందిస్తారు.
కాబట్టి, అది ఒక modelగా ఉండవచ్చు మరియు ఆ
పనిని కొనసాగించవచ్చు మరియు ఇవి సాధారణంగా
అలాంటివి చేయబడతాయి.
మీరు IaaS కాంపొనెంట్ stack మరియు
నియంత్రణ పరిధిని చూస్తే.
IaaS యొక్క భాగాలు hardware, ఆపరేటింగ్ System, మిడిల్వేర్ మరియు application
లేయర్ లను కలిగి ఉంటాయి.
కనుక, ఇది విలక్షణమైన విషయం.
ఆపరేటింగ్ సిస్టం, 2 పొరలుగా నిర్మిచబడినది,
మొదటిది లోపలి ప్రివిలేజ్ లేయర్ .
కాబట్టి, ఆపరేటింగ్ System యొక్క
ఎక్కువ కోడ్ ను చూస్తే virtual
మెషీన్ మానిటర్  లేదా VMM చే ఆక్రమించబడతాయి,
దీనిని హైపర్విజర్  అని కూడా పిలుస్తారు.
గెస్ట్ ఆపరేటింగ్ సిస్టం
అని పిలువబడే VM లో నడుస్తున్న ఆపరేటింగ్
సిస్టం అధిక పొరను ఆక్రమించింది.
కాబట్టి, మేము ఈ సందర్భంలో మాదిరిగానే ఉన్నామని
చూసినట్లుగా, మధ్యలో మనం చూసినట్లైతే,
బేర్ మెటల్ hardware ఉంటుంది, ఇందులో
cloud providerలు మొత్తం నియంత్రణను
కలిగి ఉంటారు; ఆచరణాత్మకంగా, cloud subscriber కు తక్కువ నియంత్రణ ఉంది. దీని పై, మనం
ఒక హైపర్విజర్ లేదా VMM లేదా వర్చ్యువల్
mission మానిటర్ ను కలిగి ఉంటుంది.
cloud provider లేదా cloud subscriber యొక్క నిర్వాహక నియంత్రణ , ఒక VM మొదలైన
వాటి కోసం ప్రధానంగా ఈ హైపర్విజర్ 
కు రెక్వెస్ట్  పంపవచ్చు.
ఆపై Guest OS, మిడిల్వేర్, java మొదలైనటువంటి
ఇతర పొరలు ఉంటాయి, మెయిల్, CRM మరియు
ఇతర రకాలు వంటి application లు ఉంటాయి, ఒక Iaas విషయంలో
cloud subscriber మొత్తం నియంత్రణను
కలిగి ఉంటారు.
provider కు ఏ నియంత్రణ ఉండదు
లేదా provider దేనిని నియంత్రించదు.
కనుక, here ఈ విధంగా జఅరుగుతుంది.
కాబట్టి, మనము చూస్తే బయటి పొరలలో నియంత్రణ
రకం cloud subscriber లకు తరలించబడుతుంది
మరియు లోపలి పొరలలో నియంత్రణ రకం provider
వైపుకు తరలించబడతాయి.
IaaS cloud  లో, provider కు ఫిజికల్ hardware పై పూర్తి నియంత్రణ, మరియు హైపర్విజర్
 పొర మీద అడ్మిస్ట్రేటివ్ నియంత్రణ ఉంటుంది.
subscriber , గెస్ట్ OS, మిడిల్వేర్
మరియు application లేయర్ లను
నియంత్రిస్తుంది.
ఇవి subscriber  పై ఉంటాయి.
subscriber  అనునది ఏ సహాయ ఆపరేటింగ్
System load చేయుటకు provider
యొక్క utility నుండి ఉచితముగా ఉపయోగించును.
అందువల్ల, provider మద్దతునిచ్చినట్లయితే,
subscriber , గెస్ట్  OS ను load
చేయవచ్చు.
subscriber  సాధారణంగా ప్రతి
VM లో గెస్ట్ ఆపరేటింగ్ System
యొక్క operation పై పూర్తి నియంత్రణను
నిర్వహిస్తుంది.
కాబట్టి, subscriber  దీన్ని load
అయినప్పుడే అది గెస్ట్ OS పై మొత్తం నియంత్రణను
కలిగి ఉంటుంది, అనగా cloud provider నాకు కొంత లైనక్సు OS మరియు హైపర్విజర్
అందించినప్పుడు, నాకు లైనక్స్
లేదా windows, మొదలైనవాటిని load
చేయడానికి అనుమతిస్తుంది.
కాబట్టి, నేను లైనక్స్ యొక్క కొన్ని రకాలను
load చేస్తే, దాని పై నాకు పూర్తి నియంత్రణ
ఉంటుంది.
IaaS కాంపొనెంట్ stack మరియు ఇతర విషయం,
హైపర్విజర్  ఒకటి లేదా మరిన్ని
వర్చ్యువల్ missionలు  లేదా VM ల సంశ్లేషణకు
హార్డువేరు  లను ఉపయోగిస్తుంది.
ప్రతి VM ఒక సమర్థవంతమైన ఐసోలేటెడ్ డూప్లికేట్
real మెషీన్, subscriber ,
VM access ని రెంట్  కి తీసుకుంటుంది
,ఈ VM subscriber  కి నిర్వహించే
వాస్తవ computer hardware
గా కనిపిస్తుంది, ఇది ఆఫ్ on చేయబడుతుంది,
network ద్వారా పంpay కమాండ్స్
ద్వారా పెరిఫెరల్స్ కాన్ఫిగర్  చేస్తుంది,
ఎందుకంటే subscriber  గా provider
తో interface అయ్యి కమ్యూనికేట్
అవుతుంది.
మీరు ఒక సాధారణ architecture  ని చూస్తేప.
పైన ఉన్న అనేక భాగాలలో cloud మేనేజర్ ఒకటి. విభిన్న cluster మేనేజర్లు ఉన్నారు, ఇవి రెండో స్థాయిలో ఉన్న
విషయాలు మరియు దానికి దిగువన computer
మేనేజర్ లేదా CM ఉంటుంది.
ఇందులో CM ప్రధానంగా హైపర్విజర్స్
మరియు విభిన్న రకాలైన virtual మెషీన్
 అంశాలను కలిగి ఉంది. మనము cloud
మేనేజర్ మరియుData ఆబ్జెక్ట్ storage ను కలిగి ఉన్నాము, అనగా ఇది విషయాలను
పర్యవేక్షించే ముస్టర్Data బేస్.
ఇప్పుడు లోయర్ స్థాయి వద్ద వంటి పెర్సిస్టెంట్
లోకల్ storageని కలిగి ఉంటుంది;
అనగా, cloud provider లేనప్పుడు కూడా storage
 అలానే ఉంటుంది.
ఎప్పుడంటే VM లు ఉపయోగించబడకపోయినా లేదా షట్down
అయినప్పుడు.
ఆ 3 స్థాయిల హైరార్కీ లను చూస్తే, 1.
tap level, దీనికి cloud మేనేజర్
లాంటి సెంట్రల్ కంట్role  బాధ్యత ఉంటుంది.
2
మిడిల్ level,ఇది బహుశా పెద్ద
computer cluster యొక్క నిర్వహణకు
బాధ్యత వహిస్తుంది మరియు భౌgoళికంగా
ఒక దాని నుండి మరొక దానికి దూరం ఉంటుంది.
కాబట్టి, మీరు ఈ cluster మేనేజర్ ని
చూస్తే, ఈ భారీ cluster లను నిర్వహిస్తుంది,
ఇది భౌgoళికంగా వ్యాప్తి చెందుతుంది మరియు
మూడవది వర్చ్యువల్ mission లను
సృష్టించే host computing
system నడుపుటకు బాధ్యత వహిస్తుంది.
కాబట్టి, ఈ host computing
system నడుపుతున్నారు, here VM లు సృష్టించబడతాయి.
ఇది సాధారణంగా 3 లేయర్ ల నియంత్రణ, subscriberసాధారణంగా
వ్యాఖ్యానిస్తుంది.
క్వెరీస్  కి onసర్ ఇచ్చేటపుడు
tap నుంచి down కి పొరల ద్వారా ముందుకు
పంపబడతాయి.
IaaS cloud architecture లో cloud మేనేజర్ భౌgoళికంగా పంపిణీ చేయవచ్చు.
cluster మేనేజర్ లోపల, computer
మేనేజర్ అధిక వేగ network ద్వారా
అనుసంధానించబడి ఉంటుంది.
cluster నిర్వాహకుడిని చూస్తే, ఇవన్నీ అధిక
వేగ network ద్వారా connect
చేయబడతాయి.
ఇప్పుడు మీరు cloud మేనేజర్  operation
చూస్తే; tap  లో cloud మేనేజర్, తర్వాత cluster మేనేజర్, ఆ
తర్వాత వ్యక్తిగత విషయాలు నిర్వహించే
computer మేనేజర్  ఉంటాయి.
మీరు cloud మేనేజర్ విధి చూస్తే, ఇది
cloud యొక్క public access
పాయింట్.
కాబట్టి, ఎవరైనా cloud  ను public
లో access చేసినప్పుడు, subscriber,
అక్కౌంట్ ని నిర్వహించడానికి, cloud నుండి
రెంట్ కు తీసుకున్న resources  ని
నిర్వహించదానికి సైన్  చేస్తారు.
cloud మేనేజర్ subscriber
ని అతెంticket  కొరకు కొన్ని పద్దతులు
ఉంటాయి.మొదటిది అతెంticket  విధానాలు, VM
లతో కమ్యూనికేట్  అయ్యేటపుడు
subscriber ఉపయోగించే access
క్రెడెన్షియల్ ను రూపొందించడం
లేదా ధృవీకరించడం రెండవది.
ప్రధానంగా మొత్తం వ్యవస్థ యొక్క ఫ్రంటెండ్
అయినప్పుడు, మూడవది, ఉన్నత స్థాయి resources
నిర్వహణ.
subscriber అభ్యర్థన కోసం cloud
మేనేజర్, cloudలో తగినంత ఉచిత resources
ని గుర్తింస్తుంది.
కాబట్టి, cloud మేనేజర్ మెటాdata సమాచారాన్ని నిర్వహిస్తుంది.
కాబట్టి, ఒక నిర్దిష్ట VM లేదా cloud
లో అందుబాటులో లేని VM ల సెట్  కోసం నేను
అభ్యర్థిస్తే, cloud మేనేజర్కి
call చేయాల్సి వస్తుంది.
కనుక, అది subscriber ల చేత నిర్వహించబడుతుంది.
data ఆబ్జెక్ట్ storage లేదా DOS అని
పిలువబడే ఒక విషయం ఉంది. యూజర్ క్రెడిట్
ఆపరేటింగ్ సిస్టం మొదలైన
వాటి గురించి మాట్లాడుతున్నందున DOS సాధారణంగా చందాదారుల
మెటాdataను నిల్వ చేస్తుంది.
సాధారణంగా DOS service  cloud  కి
ఒకటే ఉంటుంది.
కాబట్టి, నిర్దిష్ట DOS service  అనేది
ఒక నిర్దిష్ట cloud కోసం అని చెబుతున్నాం.
కాబట్టి, ఇది మన మొత్తం రిజిస్ట్రీ లేదా
cloud జాబితా లేదా ఒక మెటాdata service ని నిర్వహిస్తుంది.
అందువల్ల, మొత్తం విషయం యొక్కByండింగ్
బ్లాక్, ఉచిత resources  అందుబాటులో
ఉన్నయా లేదా మొదలైన వాటిని అన్నింటిని
appడేడ్  చేయడం.
ఈ మిడిల్ లవేల్  cluster మేనేజర్ని చూస్తే.
హై స్పీడ్ లోకల్ ఏరియా network ద్వారా అనుసంధానించబడిన computerలు
సేకరణకు ఇది బాధ్యత వహిస్తుంది.
కాబట్టి, ఇది లో level  computerలను
నిర్వహిస్తుంది, cluster మేనేజర్ ఎగువన ఉన్న cloud మేనేజర్ నుండి
resource కేటాయింపు ఆదేశాలు మరియు ప్రశ్నలను
పొందుతుంది.
cluster  లోని computerల
యొక్క resources ను ఉపయోగించి కమాండ్ను
యొక్క పార్ట్  లేదా మొత్తాన్ని
సంతృప్తిపరచవచ్చో లెక్కిస్తుంది.
అనగా, cluster మేనేజర్ కి రెక్వెస్ట్
 అందినప్పుడు, cluster లో రెsourceవుందో,
లేదో తనిఖీ చేస్తుంది; ఇది విషయాలను సంతృప్తి
చేయగలదా మరియు అనుగుణంగా అది విషయాలకు తగిన
సిగ్నల్ను చెబుతుంది.
అలాగైతే, అది ఆమోదించవచ్చు లేదా ఆమోదించకపోవచ్చు
మొదలైనవి వుంటాయి.
cluster మేనేజర్ రెsource లభ్యతను
గుర్తించడానికి clusterలోని
computerల కోసం computer మేనేజర్ ని ప్రశ్నిస్తాడు, cloud మేనేజర్ కి సందేశాలను పంపుతాడు.
అనగా, అది computer మేనేజర్, cluster
మేనేజర్ మరియు cloud మేనేజర్ కి మధ్య మిడిల్ వేర్ లేదా ఏజెంట్
గా పనిచేస్తుంది.
మీరు operationను చూస్తే, అక్కడ cloud
మేనేజర్ కోసం దిశను నిర్దేశిస్తుంది.
మరియు ఆపై రెsource కేటాయింపు, రీ కాన్ఫిగరేషన్
, రెsource డి అల్లోకేషన్
మరియు ఇతర విషయాలను నిర్వహించడానికి
computer మేనేజర్ల ను నిర్దేశిస్తుంది.
cluster మేనేజర్ నిరంతర స్థానిక
storage కు అనుసంధానిస్తారు; cluster మేనేజర్ పెర్సిస్టంట్ storageకి
అనుసంధానించబడి ఉంటుంది.
అనగా ఇది కోట్ లేదా uncoated నోన్ వొలటైల్
storage.
నిర్దిష్ట వర్చ్యువల్ mission, షట్down అయినప్పుడు, లేమి లేదా కొన్ని problemలు
వస్తాయి.
సో, అది విషయాలు లోకి స్థానిక నిల్వ కలిగి.
కాబట్టి, ఈ PLS వర్చ్యువల్ mission కి storage
 వంటి పెర్సిస్టంట్  డిస్కును
అందిస్తుంది.
కాబట్టి, అదే నిరంతర డిస్క్ ఉన్నట్లయితే.
కాబట్టి, మీరు తర్వాతి సమయం లాగిన్  చేసినప్పుడు
data అందుబాటులో ఉంటుంది.
మేము cloud మేనేజర్ operation
చూస్తే.
సోపానక్రమంలో అత్యల్ప స్థాయిలో, ప్రతి
computer Systemలో రన్ అయ్యే cloud
మేనేజర్, subscriber కి virtual
machine అందించడానికి, Virtualization
 ని ఉపయోగిస్తుంది.
కాబట్టి, cloud మేనేజర్ ప్రాథమికంగా
VM లను అందిస్తుంది.
ఇది బాధ్యత వహించే VM లను అందించే subscriber
కి, computer మేనేజర్ ఎన్ని
వర్చ్యువల్ missionలు నడుపుతున్నారో
లాంటి స్థితి సమాచారాన్ని మొదలైనవి నిర్వహిస్తుంది.
కాబట్టి, అది ఎన్ని విర్జిషియల్ మెషీన్లు నడుపుతున్నాయనేదాని స్థితి సమాచారమును
నిర్వహిస్తుంది.
దీని తో పాటు cloud మేనేజర్ వర్చ్యువల్
missionల ను ప్రారంభించడానికి,
సస్పెండ్ మరియు పునఃనిర్మించటానికి
హైపర్విజర్ కు కమాండ్ interface
ను ఉపయోగిస్తుంది.
computer మేనేజర్ అవసరం ఉంటే అది
కూడా ఒకటే. hereంత మనం చూసేది, Virtualization
 యొక్క ముఖ్యమైన పాత్ర.
ఎలా ఈ Virtualization  తయారుచేస్తాం
మరియు దాని అంశాలు మొదలైనవి: వీటన్నిటి
గురించి తదుపరి Slideలలో త్వరగా చూడటానికి
ప్రయత్నిస్తాం.
కాబట్టి, వర్చ్యులైజేషన్  ఒక విస్తృత
పదం, ఇది ఒక వర్చ్యువల్ మెమొరీ కావచ్చు,
వర్చ్యువల్ network కావచ్చు, వర్చ్యువల్
storage, మొదలైనవి కావచ్చు.
దేన్నైనా మనం Virtualize  చేయగలిగితే
దాన్ని వర్చ్యులైజేషన్  అంశం అంటాం.
మా ప్రాధమికంగా వర్చ్యులైజేషన్  వేదిక కోసం
దృష్టి పెడుతున్నాం.
వర్చ్యులైజేషన్ ప్రాథమికంగా, ఒక
computer, ఒకే hardware 
resource  లను ఎక్కువ ఎన్విరాన్మెంట్
 లో పంచి, బహుళ computerల
యొక్క పనిని చేయడానికి అనుమతిస్తుంది.
కాబట్టి, ఇది ముఖ్యమైనది; దీని అర్ధం, నాకు
ఒక బేర్ మెటల్ ఉంది, నేను విభిన్న
machine లను లేదా వర్చ్యువల్ missionలను సృష్టించగలము.
కానీ బాక్ ఎండ్ లో, అదే బేర్ మెటల్ రన్ అవుతుంది.
ఇప్పుడు ఇది చాలా గమ్మత్తైనది.
మీరు ప్రత్యేక ఎన్విరాన్మెంట్  లో, మీ బేర్
మెటల్ ను కలిగి ఉన్నాం అనుకుందాం
మరియు మీరు Windows లో ఒక machine  రన్
 చేస్తున్నాం, Linux లో ఒక mission Guest
OS, లేదా ఇతర విషయాలు మొదలైనవి ఉపయోగించవచ్చు.
ఈ గెస్ట్ OS యొక్క ఇంస్ట్రక్షన్ సెట్
, hardwareలోఎలా అమలవుతుందనే problem
ఉంది. కాబట్టి, ఆ problemలనేవి ఉన్నాయి, application
 సిజింగ్  సమయాలు ఉన్నాయి.
VM కు ఎక్కువ resources  అవసరం అయినప్పుడు
లేదా ఇతర resources  ని విడుదల చేసినపుడు,
ఎలా నిర్వహించాలో మరియు అలా ఎలా కొనసాగించాలో
వాటికి సంబంధించి కొన్ని problemలు ఉన్నాయి.
కాబట్టి, మనము హార్డువేర్ చూద్దాం.
కాబట్టి, ఇది ఒక వర్చ్యులైజేషన్ లేకపోతే, ఒకే OS అన్ని
హార్డువేరు resource  లను నియంత్రిస్తుంది.
ఇది ఒక వర్చ్యులైజేషన్ ఒకే ఫిజికల్ platform
 పై బహుళ వర్చ్యువల్ కంటైనర్లను
నడపడం సాధ్యపడుతుంది.
కాబట్టి, మనము బహుళ virtual కంటైనర్లను కలిగి ఉంటాము, అవి ఒకే ఫిజికల్
platform  పై అమలు చేయవచ్చు
లేదా ప్లగ్ చేయబడతాయి.
ఈ వర్చ్యులైజేషన్తో మనకు కొంతవరకు అనుభవము
ఉంది. అందువల్ల, వర్చ్యులైజేషన్ ఒకే హార్డువేరు
నందు బహుళ ఆపరేటింగ్ System లను
మరియు యూజర్ application నడుపుటకు ఒక
మార్గం.
కాబట్టి, ఇది Virtualize  చేయబడుతుంది
. కాబట్టి, నేను ఒకేసారి machine పై 2 విభిన్న
ఆపరేటింగ్ Systemను కలిగి ఉండగలను.
అనగా, దీనిలో ఒక OS ని Virtualize
చేస్తాను, కాబట్టి, windows మరియు
లైనక్స్ రెండింటినీ ఇంకొక వైపు అమలు
చేస్తాము.
డబుల్ బూట్ కోసం ఇది ఎలా విభిన్నంగా
ఉంటుంది?
ఒకసారి windows లో చేయడం మొదలైనవి.
here Virtualization విషయంలో, ఈ వేర్వేరు
OS లేదా అన్ని OSలు ఒకేసారి లేదా ఒకే సమయంలో
కలిసి రన్ అవుతాయి.
OS లు ఒక దాని నుండి మరొకటి completely
వేరుచేయబడతాయి.
నిజమైన Virtualization  విషయంలో ఒకదానితో
ఒకటి completely వేరుచేయబడతాయి.
ఇందులోకి మరో ముఖ్యమైన అంశం వర్చ్యువల్
mission మానిటర్ లేదా హైపర్విజర్.
కాబట్టి, ఒక హైపర్విజర్ లేదా virtual
మెషీన్ మానిటర్, గెస్ట్ OSను CPU పై నేరుగా నడుపుతుంది.
అందువల్ల నేను ఒక అతిథి OS ను కలిగి
ఉన్నాను మరియు దానిని నా అక్కౌంట్ లో
చోటు చేసుకున్న లేదా subscriber 
ద్వారా ఇంస్టాల్  చేయబడుతుంది
లేదా అమలు చేయబడుతుంది లేదా client యొక్క
application లో ఉంటుంది.
ఆపై హైపర్విజర్, దీన్ని అమలు చేయడానికి
లేదా ఈ గెస్ట్ OS ను నేరుగా hardwareలో,
బాక్ ఎండ్ లో అమలు చేయబడుతుంది.
కాబట్టి, Guest OS, host OS ఒకే ఇంస్ట్రక్షన్
సెట్ ఉపయోగిస్తే పనిచేస్తుంది.
ఇది విభిన్న ఇంస్ట్రక్షన్ సెట్ ఉంటే,
appపుడు ఒక ఇంస్ట్రక్షన్ ట్రాన్స్లేషన్  ఉపయోగిస్తాము.
పోప్ కె మరియు goల్డ్బెర్గ్
వర్ణించిన అనేక problemలు ఉన్నాయి.
వర్చ్యువల్ mission architecture యొక్క 3 goల్స్ ఉన్నాయి: 1.
ఇక్వివలెన్స్ , అంతర్లీన hardware
నుండి VM లను వేరు చేయరాదు.
కనుక, వర్చ్యువల్ mission, హార్డువేరు
మీద నడుస్తుంటే.
దానిని మనము ఇక్వివలెన్స్  అంటాము.2, రెsource
కొంట్role , VM కి Virtualizeడ్
రెsource  పై అసంపూర్తి నియంత్రణ
ఉండాలి.
కాబట్టి, మీరు నాకు 4 GB machine, 30 GB లేదా
60 GB Hard Disk ఇస్తే, subscriber
గా వాటి పై పూర్తి నియంత్రణ ఉంటుంది.
మరియు 3.
ఎఫిషియెన్సీ , అధిక VM ఇంస్ట్రక్షన్లు
హైపర్విజర్తో సంబంధం లేకుండా అంతర్లీన
CPU పైన నేరుగా అమలు చేయాలి.
కాబట్టి, అది మరొక విషయం.
virtual మెషీన్ బోధన యొక్క అధికభాగం,
ఈ ఇతర ప్రమేయం హైపర్విజర్ యొక్క జోక్యం లేకుండా
నేరుగా CPU పై అమలు చేయగలగడం వలన సామర్థ్యం
పెరుగుతుంది.
అందువల్ల, మనము VM లను అనుకరించటానికి
అనుమతించే ప్రదేశంలో వర్చ్యువల్ mission
మానిటర్ లేదా హైపర్విజర్
వున్నప్పుడు, వీటిని పరిశీలించవలసిన
అంశాలు.
అదే work లో ఈ పొపెక్ మరియు
goల్డ్బెర్గ్ ను వివరించారు మరియు
ఈ లక్షణాలను జరిగేలా అనుమతించే CPU ల ఇంస్ట్రక్షన్ల
యొక్క అవసరాన్ని అందించిన ఒక అధికారిక
రుజువుని కూడా ఇస్తారు.
నిజంగా Virtualization IaaS స్థాయిలో జరిగేలా
చేయాలంటే, ప్రధానంగా , ఈ ఇంస్ట్రక్షన్
3 విభిన్న విషయాలగా వర్గీకరిస్తుంది.
అందులో ఒకటి ప్రివిలైజ్ద ఇంస్ట్రక్షన్ ,
ఇది యూసర్ మోడ్ లో ఎక్జిక్యూట్
 చేసినప్పుడు, ట్రాప్  జరగవచ్చు.
here సెన్సిటివ్ inస్ట్రక్షన్ ఉంది, ఇది అంతర్లీన రెsource ను
మారుస్తుంది, అది IO చేస్తోంది లేదా
గెస్ట్  OS, బార్  లో నడపబడుతున్న
వాస్తవాన్ని మారుస్తుంది; మొదటిది IO లేదా payజ్
టేబుల్స్ లను మార్చడం లేదా ప్రస్తుత
అధికార స్థాయిపై సమాచార సూచనలను గమనించడం.
మీరు మీ ప్రాథమిక architecture 
అంశాలను గుర్థిన్చినట్లైతే.
మనము వివిధ స్థాయి లో operation 
ను కలిగి ఉన్నాము, అవి level 0,level
 1 మొదలైన వేర్వేరు స్థాయి కార్యకలాపాలు.
మరింత తక్కువ level  వెళ్ళేకొద్ది,
బేర్ మెటల్కి మరింత దగ్గరగా వెళ్తాము.
ఇది అన్నిటిని నిర్వహించే Virtualization
పై ఆధారపడి ఉంటుంది.
మరింత పై level  వెళ్ళేకొద్ది
మరింత లాటెన్సి  వస్తుంది, మరియు
మరింత అనువాదం అవసరం అవుతుంది.
కాబట్టి, మనము ఏ level  operation లు
చేయాలనే విషయాన్ని పరిశీలిద్దాం; ప్రత్యేకంగా
మనము IaaS సంభందిత operation  లు చేస్తున్నప్పుడు.
సెన్సిటివ్  ఇంస్ట్రక్షన్
ల యొక్క మొదటి క్లాస్  ని కంట్role సెన్సిటివ్
 అని మరియు తర్వాతి క్లాస్ 
ని బెహెవీర్ సెన్సిటివ్ 
అని అంటాము.
Popek మరియు goల్డ్బెర్గ్ ఏమి చెబుతుందంటే,
ఈ 3 ఉపయోగపడే ప్రాపర్టీస్ ల తో Virtual machine
 రన్ చేస్తే సెన్సిటివ్ ఇంస్ట్రక్షన్
లు , ప్రివిలైజ్ద ఇంస్ట్రక్షన్ 
లకు సుబ్సెట్  గా ఉంటాయి.
వారి పనిలో వీటన్నిటిని చూపిస్థాయి, ఈ రకమైన
విషయాలు నిజమైనవి మరియు నిజమైన Virtual
machine  ని గుర్తించగలము.
ఇదే విషయం లేదా మనం చర్చించే ఏవైనా.
ఈ virtual machine మానిటర్ల పై ఈ VM లు మరియు ఈ హార్డువేరు
రన్ అవుతుంటాయి.
మరియు ఈ వేర్వేరు VM లను అనుకరించటానికి
ఇది అనుమతిస్తుంది.
కాబట్టి, ఇది మీదే కావచ్చు.
కొన్ని చోట్ల ఏదైనా గెస్ట్ OS, VM పై రన్
 అవుతుంటుంది.
కన్వర్ట్  చేయవలసిన ఇంస్ట్రక్షన్ ల
సమితి ఈ hardwareకు  అర్ధం చేసుకోగలగాలి.
కాబట్టి, అది మన బాటమ్ లైన్.
మొత్తం VMM మొత్తం అబ్స్త్రాక్సన్
 ను కలిగివుందా లేదా ఏదో ఒక విధమైన
ఒవెర్లప్పింగ్ ఉందా లేదా అనేది
దానిపై ఇంప్లిమెంటేషన్ పై ఆధారపడి ఉంటుంది.
కాబట్టి, Virtualization సాధారణ విధానాలకు
సమీపంలోని విధానాలను పరిశీలిస్తే.
మీరు ఈ Virtualization యొక్క పరిణామమును
చూసినట్లయితే, మనము మొదటిది ఫస్ట్ జెనెరేషన్ లేదా ఫుల్ Virtualization, దీనినేByనరీ
రీరైటింగ్ అంటాము.
కాబట్టి, ఇది Software ఆధారిత అంశం, VMware మరియు
microsoft దీనికి మద్దతిస్తుంది.
ఏ వర్చ్యువల్ missionలు, డైనమిక్ ట్రాన్స్లేటర్ను
 సృష్టించినా, అండర్ లైనింగ్ హార్డువేరుకు
రీరైట్ చేస్తాయి.
సెకండ్ జెనెరేషన్ లో: Virtualization
లేదా పరా వర్చురైజేషన్, కొ ఓపెరటివ్
 Virtualization.
ఇది అతిథి OS లేదా మోడిఫెడ్ గెస్ట్,VMware మరియు xen ల కొ ఓపెరటివ్  Virtualization.
కాబట్టి, మీరు here చూస్తే ప్రాథమికంగా
ఇది VM లోకి కొంచెం చొచ్చుకొచ్చింది;
అంటే, అంశాలపై సవరించబడింది.
ఒక మూడవ జనరేషన్ లేదా సిలికాన్ ఆధారిత
అంశం, hardware సహాయంతో Virtualization
వర్చ్యులైజేషన్ అవగాహన hardware
ప్లాట్ఫారమ్లో లో, on మోడిఫీడ్
గెస్ట్ , VMware మరియు xen ఉంటాయి, ఇప్పుడు
మీ hardware ప్లాట్ఫారమ్కు Virtualization
తెలుసు.
కాబట్టి, ఇది hardware asసిస్టెడ్ 
Virtualization.
ఈ సందర్భాలలో ఈ hardware ప్లాట్ఫారమ్లో లకు ఈ Virtualization గురించి తెలియదు.
ఈ మీ హైపర్విజర్ చేత ఏమి జరిగినా?
ఫుల్ Virtualization లో వివిధ అంశాలు
ఉన్నాయి, ఫస్ట్ జెనెరేషన్ ఫస్ట్ జెనెరేషన్ x86/x64 server ఫుల్ Virtualizationను అందిస్తుంది.
source కోడ్ యొక్క డైనమిక్Byనరీ
ట్రాన్స్లేషన్, మనము చూసినట్లుగా
అన్ని hardware లు CPU తో సహా ఎమ్యులేటెడ్
అయ్యి ఉంటాయి.
2 ప్రముఖ open source ఎమెల్యూటర్లు
 ఉన్నాయి, వాటిలో ఒకటి చాలామందికి
తెలిసిన QEMU మరియు రెండవది Bochs . ఇవి రెండు
open source ను మార్చే ప్రముఖ
ఎమెల్యూటర్లు .
పూర్తి Virtualization, ఎమ్యులేషన్ లేయర్
 యొక్క ప్రయోజనాలు ఉన్నాయి.
మొత్తం VM portability, నేను VM ను ఒకదాని
నుండి మరొకదానిలో ఉంచగలము.
కాబట్టి, మొత్తం portabilityని
ఉపయోగిస్తాము, ఎందుకంటే VMM మాత్రమే, మనకు అర్థం
అవుతుంది.
ఈ hardware ఎమ్యులేషన్స్ performance  Tierతో పాటు వస్తుంది.
ఇది ఇందులోని ఒక లోపం.
మీరు ట్రడిషనల్ x86 architecture
లో హార్డువేర్ performance Tierను అనుకరించాలనుకున్నప్పుడు,
OS కెర్నెల్ లు ప్రత్యేక హక్కు ప్రివిలేజ్
రింగ్0 లో రన్ అవుతుందని అనుకుంటున్నాం.
ఇప్పుడు మీరు వాటిని అధిక level  లో
అమలు చేయాలనుకుంటే, ఎక్కువ లాటెన్సి
ఉండాలి మరియు ఇతర విషయాలను కూడా పరిశీలించాలి.
కాబట్టి, మనం దాని కోసం pay  చెయ్యాల్సిన
అవసరం ఉంది లేదా performance 
Tier మనకు అవసరం.
పారా వర్చురైజేషన్ విషయంలో, గెస్ట్
OS సవరించబడింది మరియు రింగ్ 1 లేదా రింగ్
3 వద్ద కెర్నల్ level  ఆపరేటింగ్
System ను అమలు చేస్తుంది.
ఇది అధిక level  గెస్ట్ గా ఉంటుంది,
ఇది ప్రివిలేజ్ ఇంస్ట్రక్షన్  ను ఎలా ప్రాసెస్
చేయాలో తెలుసుకోగలదు.
VMM కు అనువదించబడిన ప్రివిలేజ్ 
ఇంస్ట్రక్షన్  ఇకపై అవసరం లేదు.
గెస్ట్ నిర్వహణ వ్యవస్థలు ప్రత్యేక
API ను VMM తో కమ్యూనికేట్ అవడానికి ఉపయోగిస్తాయి.
కాబట్టి, ఇది పారా; దీని అర్థం, మీ VMM,
కొన్ని రకాలైన VM లను ఉపయోగించడానికి
చొచ్చుకుపోతుంది.
కనుక, ఇప్పుడు అది పూర్తి అనువాదం కాదు,
కానీ ఒక పారా వర్చురైజేషన్ performance
 పెరుగుతుంది మరియు ఈ విషయం బాగా
ప్రజాదరణ పొందుతోంది.
పారా వర్చురైజేషన్ విషయంలో, OS
కెర్నెల్ను రి కంపైల్ చేయాల్సిన
అవసరము ఉంది, దీనిని ఉపయోగించాలంటే, పారా
Virtualizeడ్ డ్రైవర్ల
యొక్క inస్టలేషన్  అవసరం.
ఇది, గెస్ట్ OS లెవేల్ లో జాగ్రత్తలు తీసుకుంటుంది.
మూడవది, hardware asసిస్టెడ్ వర్చురైజేషన్, గెస్ట్ OS రింగ్ 0 లో రన్
 అవుతుంది.
VMM, ఇంటెల్ VT లేదా AMD V లలో ఉన్నట్లుగా
Processor ఎక్స్టెంషన్స్  లను ఉపయోగిస్తుంది
మరియు గెస్ట్  లో ఉన్న ప్రివిలైజెడ్
 operation  లను inర్సెప్ట్
 చేస్తుంది.
హార్డువేర్ సహాయంతో Virtualization
అనేది, ఒక VMM ను వ్రాసేటప్పుడు జరిగే అనేక problemలను
తొలగిస్తుంది, అది ఒక పెద్ద సవాలు.
ఇది hardware అసిస్టెంట్; అనగా, మీరు నేరుగా
పొందగలిగితే అది completely కంపైల్
 అయి ఉంటుంది.
ఇలా చేయడం వల్ల, మీరు VM ల యొక్క పోర్టబిలిటిని
కోల్పోతారు, ఇది గమ్మత్తైన problemగా
మారుతుంది, ఎందుకంటే hardwareని
అర్థం చేసుకునే machine కి మీరు మైగ్rate
అవ్వాలి.ఉపయోగం, అది అన్మోడిఫైడ్
OS ని రన్ చేయడానికి అనుమతిస్తుంది, మీరు
OS లు మార్చల్సిన అవసరం లేదు; లోపం, స్పీడ్
 మరియు ఫ్లెక్సిబిలిటీ  ల problem ఉంది.
మైగ్రేషన్ జరిగినప్పుడు మీరు ఫ్లెక్సిబిలిటీ
 కోల్పోతారు మరియు స్పీడ్ ,
మైగ్రేషన్ పై ఆధారపడి ఉంటుంది.
మనం నెట్ work Virtualization యొక్క కొన్ని అంశాలపై
మనము చర్చించుకుందాం.
ఇప్పటి వరకు మనము హార్డువేర్ level
 లో చూసాము, ఇప్పుడు మనం network
level  లో చూద్దాం; అంటే, ఇచ్చిన networkలోని
ఒక వర్చ్యువల్ నెట్ work పై నెట్
work ను అనుకరించాల్సిన అవసరం ఉంది.
network టెక్నాలజీలో మనం చూసే విలక్షణ
విధానాలు అంటే ఐపి బేస్ లేదా ఎటిఎమ్
బేస్ లేయర్ .
వర్చ్యులైజేషన్ యొక్క ఏ లేయర్
లో ఆర్చిటెక్చురల్ domain ఉంటుంది,దీనిలో
network వనరుల ajamanyaాలు, స్పానింగ్
 networkలు ఉంటాయి, వర్చ్యులైజేషన్
level  లో,Node level  లేదా ఫుల్ వర్చ్యులైజేషన్ వంటివి ఉన్నాయి.
మనం ఈ network కలిగి ఉన్నాం అనుకుందాం.
appపుడు మనం ఇలాంటి network ను
ఎమ్యులెట్చేస్తాం, కనుక, ఇది నా బేస్
network.
మనము 2 రకాల వర్చ్యువల్ network
లను దీని పైన కలిగివున్నాము.
ఒక virtual networkను మనము ఎమ్యులెట్
చేశాము, వాస్తవంగా ఎందుకు మనము విర్చువలైజ్
 కి వెళ్ళాలి అంటే మన స్వంత networking
పారాడిగ్మ్లో internet స్తంభించడం
మాత్రమే కాకుండా, స్payస్  ఎక్కువ
ఉండదు.
ఒన్ size ఫిట్స్ అల్  architecture
 ని తీసుకుని రావడం చాలా కష్టం.
మనము network కాన్ఫిగరేషన్ ని కలిగి ఉంటాము
మరియు ప్రతిఒక్కరికీ సరిపోతుంది.
ఎందుకు మనం వివిధ సినారియో  లకు
అన్నీ create  చేయడానికి బదులుగా
అన్నిటికి సరిపోయేవిధంగా ఒకే రకం create
 చేయకూడదు.
ఇదే మనం చేయాలనుకుంటున్నాం.
కాబట్టి, భవిష్యత్ network architectureల మరియు ప్రోటోcallలు కోసం టెస్ట్ బెడ్
లు ఉన్నాయి.
కనుక, మనము ఒక విధమైన Virtualize network కలిగి ఉంటాము.
మరియు ఇది అకస్మాత్తుగా ఇందులోకి రాలేదు,
ఇది ఇప్పటికే ఒక virtual private
network , ప్రోగ్రామబుల్
network, మరియు ఓవర్లే networkలు మొదలైనవి ఇప్పటికే చాలా ఉన్నాయి.
ఇది వాటిపై ఎమ్యులేట్ చేయబడుతోంది.
మనము here చూసినట్లైతే, వివిధ అంశాలు,అనగా
business model ,business
architecture , డిజైన్ ప్రిన్సిపుల్స్ మరియు డిజైన్ goల్స్  ఉన్నాయి.
మరియు infrastructure providerస్, Service provider, ఎండ్ యుసెర్స్
, మరియు బ్రోకర్లు వంటి వివిధ అంశాలు
ఉన్నాయి.
ఇవి వేర్వేరు ప్లాయెర్స్  మరియు వారి మధ్య
చాలా complex సంబంధం ఉంటుంది.
మరియు business model , ఈ network
Virtualization కు మాత్రమే
సరిపోదు, అది Virtualization యొక్క ఇతర అంశాలకి
కూడా సరిపోతుంది .
కాబట్టి, నేను ఆ infrastructure providerని కలిగి ఉంటే, appపుడు నేను ఒక
Service provider 1 ను కలిగి ఉండి,
ఒక విధమైన Virtualize network
ను కలిగి ఉంటాను.
దీని నుండి ఎమ్యులెట్ చేసినవి, కొన్ని
networkలను ఆక్టివేట్ చెయ్యడం
మదలైనవి.
మనము ఇతర రకాలైన Service provider 2, SP2 ఇతర రకాలైన networkలులను
కూడా ఎమ్యులెట్ చేయడం, కనుక, నేను
ఒక ప్రాథమిక అంతర్లీన network లో
వివిధ రకాల network లను ఎమ్యులెట్
చేస్తుంది.
కాబట్టి, మనము వివిధ రకాల networkలులను
ఏర్పరచవచ్చు.
కాబట్టి, ఇవి చాలా ప్రజాదరణ పొందాయి.
serverలు మాత్రమే కలిగి వుండకుండా
భౌgoళిక స్payస్ అంతటా ఒక నిర్దిష్ట
పరీక్ష నిర్వహించాలని అనుకుంటాను.
కాబట్టి, నేను ఈ serverలను తీసుకురావడం మాత్రమే
కాకుండా నేను ఒక నిర్దిష్ట network
infrastructure కావాలి అనుకుంటాను.
ఇలా చెయ్యాలి అంటే appపుడు IASS స్థాయి
లేదా server స్థాయి Virtualization మాత్రమే
ఉంటే సరిపోదు, network level Virtualization కూడా కావాలి మరియు ఈ మొత్తాన్ని
నేను ఒక వాస్తవిక ఐపి infrastructure
స్థానంగా పొందగలగాలి.
కాబట్టి, మా చర్చలు మా తదుపరి ఉపన్యాసాలలో
మేము కొనసాగిస్తాము.
ధన్యవాదాలు.
లో మా తదుపరి lectureకు స్వాగతం.
మేము త్వరగా Virtualization  గురించి తెలుసుకుందాం.
మేము ఇప్పటికే మన మునుపటి ఉపన్యాసాలలో
ఈ అంశాలను కొన్ని చర్చించారు.
here కోర్  అంశాల పై మరికొన్ని Slideలు
వున్నాయి, అది ప్రధాన భావనలలో ఒకటి. అందువల్ల,
ఈ cloud computing యొక్క Virtualization
అనేది ప్రధాన అంశాలలో ఒకటి. ఇది cloud
computing ఉన్నప్పటి నుంచే
, Virtualization  ఉంది. కనుక
ఇది కొత్త విషయం కాదు. మనలో చాలామంది
Virtualization  ఉపయోగిస్తున్నారు.
LINUX సిస్టం మీద, ఒక విండో Systemపై మనం Virtualization  చేస్తాము.
కాబట్టి, నేను ఒక విధమైన virtual
రియలైజేషన్ కలిగి ఉన్నాను.
మరో వైపు చూస్తే, networking,
మొదలైనటువంటి వివిధ ఇతర రెsource 
లను ఉపయోగిస్తారు.
కాబట్టి, మనము బాగా ప్రసిద్ది చెందిన
virtual LAN లేదా VLAN ను కలిగి ఉంటాము,
అనగా virtual private network మొదలగునవి కలిగి ఉంటాము.
వర్చ్యులైజేషన్ ఉంది. మరియు ఈ cloud
computing నిర్మాణ సాంకేతికత,
cloud యొక్క వివిధ service
లు అందించడం కోసం ఈ లక్షణాన్ని ఉపయోగిస్తుంది.
కాబట్టి, దీనిని IaaS లేదా infrastructure
as ఆ service  గా చూసాము.
subscriber  దృష్టిలో, subscriber
 ఏమి పొందుతాడు.
అంటే, వర్చ్యువల్ computerలు, network access, వర్చ్యువల్ storage, firewall, network infrastructure
లో ఒక భాగం అయిన ఫైర్ వాల్  కాన్ఫిగరేషన్
 services , మొదలైనవి.
నేను ఒక subscriber  గా , virtual
మెషీన్  లేదా machine  సమితిని
access  చేయగలను.
ఆపై, నేను నిర్దిష్ట storage  మరియు
ఇతర  తో ప్రత్యేక machine కోరుతాను.
కానీ aది ఎక్కడ ఉందో, ఎలా కాన్ఫిగర్ 
అయ్యిందో తెలియదు.
కానీ నాకు ఈ ప్రత్యేకమైన interface ద్వారా
ఉండే; machine ల రకం. మన దగ్గర ప్రత్యేకమైన
network తో పాటు virtual మెషీన్
 Hybridizationను కలిగి ఉండడం సాధ్యమే, మరియు
మన ప్రయోజనం కోసం, ఒక నెట్ work
ను అవస్థాపన చేయడం కూడా సాధ్యమే.
కాబట్టి, ఇదే subscriber మన దగ్గర నుంచి తీసుకుని
మరియు ఎలా చెల్లించాలి, ఎలా ఉపయోగించాలి
అనేది చూస్తాం.
ప్రధానంగా , సాధారణంగా, CPU గంటకు, storage
dataకి GB, ఒక గంట ఆధారంగా చెల్లించవచ్చు.
ఒక నిర్దిష్ట rate లో వినియోగించిన
network బ్యాండ్విడ్త్, network infrastructure
 ఉపయోగించబడుతుంది.
ఎంత IP అడ్రెస్, అనగా ఏ రౌటెర్స్ మొదలైనవి
మరియు విలువ ఆధారిత services.
అనగా, ఆటోమేటిక్ scaling
పర్యవేక్షన మొదలైనవి విలువ ఆధారిత serviceలు.
providerలు theoretically వర్చ్యువల్
missionల సమితిని కలిగి ఉంటారు; అంటే,
నేను ఒక cloud Service provider ని, నా వద్ద ఈ రకమైన వర్చ్యువల్
missionలు లు ఉన్నాయి.
మీరు వర్చ్యువల్ mission యొక్క
సమితి కావాలనుకుంటే, appపుడు నేను దానిని
provision చేస్తాను.
సాధారణంగా ఇవి వివిధ రకాలు గా ఉంటాయి.
theoretically, నేను ఏ వర్చ్యువల్ mission కాన్ఫిగర్  చెయ్యగలిగినా, కానీ
ఆచరణాత్మక అర్ధంలో ఇది నిర్దిష్ట కాన్ఫిగర్
 మొదలైనవి కలిగి ఉంటుంది.
ఐ.ఐ.టి Kharagpur, మెగామాలా విషయంలో మాదిరిగా
చాలా తక్కువ సామర్ధ్యం ఉన్న VM కలిగి ఉంది.
here 3 రకాల వర్చ్యువల్ missionలు ఉన్నాయి,
వాటిలో ఒకటి IIT KGP VM లు, ఇది 4 GB RAM, 20 GB హార్డ్
డిస్క్ స్payస్ మరియు ఇతర processing
మొదలైనవి కలిగి ఉంది. రెండవది IIT KGP large,
ఇది ఇప్పటివరకు ఒక 8GB RAM కలిగి ఉంది. చివరిది
IIT KGP ఎక్స్ట్రా large , ఇది 60 GB RAM ను
కలిగి ఉంది; ఇప్పుడు, resource  లభ్యత
ఆధారంగా, వివిధ రకాల VM ల Hybridization మాత్రమే
కాక, ఏ VM కావాలనే అభ్యర్థన రకం మీద కూడా ఆధారపడి
ఉంటుంది.
స్మాల్  VM కు భారీ రెక్వెస్ట్ లను
కలిగి ఉన్నట్లయితే, హైయర్  VM కంటే ఆ
స్మాల్  VM ను కేటాయించాలని అనుకుంటాము.
ఈ పరిగణనలు ఉంటాయి.
కాబట్టి, ఈ సందర్భంలో client A కు
VM1 నుంచి VM2 కు access ఉంది. అయితే, B కు VM3
కు access ఉంది, here client C
VM4 నుంచి VM6 కు access ఉంటుంది.
providerలు ఇతర consumerలకు
VM7 నుంచి VMn వరకు అందిస్తారు.
కాబట్టి, అది ఒక modelగా ఉండవచ్చు మరియు ఆ
పనిని కొనసాగించవచ్చు మరియు ఇవి సాధారణంగా
అలాంటివి చేయబడతాయి.
మీరు IaaS కాంపొనెంట్ stack మరియు
నియంత్రణ పరిధిని చూస్తే.
IaaS యొక్క భాగాలు hardware, ఆపరేటింగ్ System, మిడిల్వేర్ మరియు application
లేయర్ లను కలిగి ఉంటాయి.
కనుక, ఇది విలక్షణమైన విషయం.
ఆపరేటింగ్ సిస్టం, 2 పొరలుగా నిర్మిచబడినది,
మొదటిది లోపలి ప్రివిలేజ్ లేయర్ .
కాబట్టి, ఆపరేటింగ్ System యొక్క
ఎక్కువ కోడ్ ను చూస్తే virtual
మెషీన్ మానిటర్  లేదా VMM చే ఆక్రమించబడతాయి,
దీనిని హైపర్విజర్  అని కూడా పిలుస్తారు.
గెస్ట్ ఆపరేటింగ్ సిస్టం
అని పిలువబడే VM లో నడుస్తున్న ఆపరేటింగ్
సిస్టం అధిక పొరను ఆక్రమించింది.
కాబట్టి, మేము ఈ సందర్భంలో మాదిరిగానే ఉన్నామని
చూసినట్లుగా, మధ్యలో మనం చూసినట్లైతే,
బేర్ మెటల్ hardware ఉంటుంది, ఇందులో
cloud providerలు మొత్తం నియంత్రణను
కలిగి ఉంటారు; ఆచరణాత్మకంగా, cloud subscriber కు తక్కువ నియంత్రణ ఉంది. దీని పై, మనం
ఒక హైపర్విజర్ లేదా VMM లేదా వర్చ్యువల్
mission మానిటర్ ను కలిగి ఉంటుంది.
cloud provider లేదా cloud subscriber యొక్క నిర్వాహక నియంత్రణ , ఒక VM మొదలైన
వాటి కోసం ప్రధానంగా ఈ హైపర్విజర్ 
కు రెక్వెస్ట్  పంపవచ్చు.
ఆపై Guest OS, మిడిల్వేర్, java మొదలైనటువంటి
ఇతర పొరలు ఉంటాయి, మెయిల్, CRM మరియు
ఇతర రకాలు వంటి application లు ఉంటాయి, ఒక Iaas విషయంలో
cloud subscriber మొత్తం నియంత్రణను
కలిగి ఉంటారు.
provider కు ఏ నియంత్రణ ఉండదు
లేదా provider దేనిని నియంత్రించదు.
కనుక, here ఈ విధంగా జఅరుగుతుంది.
కాబట్టి, మనము చూస్తే బయటి పొరలలో నియంత్రణ
రకం cloud subscriber లకు తరలించబడుతుంది
మరియు లోపలి పొరలలో నియంత్రణ రకం provider
వైపుకు తరలించబడతాయి.
IaaS cloud  లో, provider కు ఫిజికల్ hardware పై పూర్తి నియంత్రణ, మరియు హైపర్విజర్
 పొర మీద అడ్మిస్ట్రేటివ్ నియంత్రణ ఉంటుంది.
subscriber , గెస్ట్ OS, మిడిల్వేర్
మరియు application లేయర్ లను
నియంత్రిస్తుంది.
ఇవి subscriber  పై ఉంటాయి.
subscriber  అనునది ఏ సహాయ ఆపరేటింగ్
System load చేయుటకు provider
యొక్క utility నుండి ఉచితముగా ఉపయోగించును.
అందువల్ల, provider మద్దతునిచ్చినట్లయితే,
subscriber , గెస్ట్  OS ను load
చేయవచ్చు.
subscriber  సాధారణంగా ప్రతి
VM లో గెస్ట్ ఆపరేటింగ్ System
యొక్క operation పై పూర్తి నియంత్రణను
నిర్వహిస్తుంది.
కాబట్టి, subscriber  దీన్ని load
అయినప్పుడే అది గెస్ట్ OS పై మొత్తం నియంత్రణను
కలిగి ఉంటుంది, అనగా cloud provider నాకు కొంత లైనక్సు OS మరియు హైపర్విజర్
అందించినప్పుడు, నాకు లైనక్స్
లేదా windows, మొదలైనవాటిని load
చేయడానికి అనుమతిస్తుంది.
కాబట్టి, నేను లైనక్స్ యొక్క కొన్ని రకాలను
load చేస్తే, దాని పై నాకు పూర్తి నియంత్రణ
ఉంటుంది.
IaaS కాంపొనెంట్ stack మరియు ఇతర విషయం,
హైపర్విజర్  ఒకటి లేదా మరిన్ని
వర్చ్యువల్ missionలు  లేదా VM ల సంశ్లేషణకు
హార్డువేరు  లను ఉపయోగిస్తుంది.
ప్రతి VM ఒక సమర్థవంతమైన ఐసోలేటెడ్ డూప్లికేట్
real మెషీన్, subscriber ,
VM access ని రెంట్  కి తీసుకుంటుంది
,ఈ VM subscriber  కి నిర్వహించే
వాస్తవ computer hardware
గా కనిపిస్తుంది, ఇది ఆఫ్ on చేయబడుతుంది,
network ద్వారా పంpay కమాండ్స్
ద్వారా పెరిఫెరల్స్ కాన్ఫిగర్  చేస్తుంది,
ఎందుకంటే subscriber  గా provider
తో interface అయ్యి కమ్యూనికేట్
అవుతుంది.
మీరు ఒక సాధారణ architecture  ని చూస్తేప.
పైన ఉన్న అనేక భాగాలలో cloud మేనేజర్ ఒకటి. విభిన్న cluster మేనేజర్లు ఉన్నారు, ఇవి రెండో స్థాయిలో ఉన్న
విషయాలు మరియు దానికి దిగువన computer
మేనేజర్ లేదా CM ఉంటుంది.
ఇందులో CM ప్రధానంగా హైపర్విజర్స్
మరియు విభిన్న రకాలైన virtual మెషీన్
 అంశాలను కలిగి ఉంది. మనము cloud
మేనేజర్ మరియుData ఆబ్జెక్ట్ storage ను కలిగి ఉన్నాము, అనగా ఇది విషయాలను
పర్యవేక్షించే ముస్టర్Data బేస్.
ఇప్పుడు లోయర్ స్థాయి వద్ద వంటి పెర్సిస్టెంట్
లోకల్ storageని కలిగి ఉంటుంది;
అనగా, cloud provider లేనప్పుడు కూడా storage
 అలానే ఉంటుంది.
ఎప్పుడంటే VM లు ఉపయోగించబడకపోయినా లేదా షట్down
అయినప్పుడు.
ఆ 3 స్థాయిల హైరార్కీ లను చూస్తే, 1.
tap level, దీనికి cloud మేనేజర్
లాంటి సెంట్రల్ కంట్role  బాధ్యత ఉంటుంది.
2
మిడిల్ level,ఇది బహుశా పెద్ద
computer cluster యొక్క నిర్వహణకు
బాధ్యత వహిస్తుంది మరియు భౌgoళికంగా
ఒక దాని నుండి మరొక దానికి దూరం ఉంటుంది.
కాబట్టి, మీరు ఈ cluster మేనేజర్ ని
చూస్తే, ఈ భారీ cluster లను నిర్వహిస్తుంది,
ఇది భౌgoళికంగా వ్యాప్తి చెందుతుంది మరియు
మూడవది వర్చ్యువల్ mission లను
సృష్టించే host computing
system నడుపుటకు బాధ్యత వహిస్తుంది.
కాబట్టి, ఈ host computing
system నడుపుతున్నారు, here VM లు సృష్టించబడతాయి.
ఇది సాధారణంగా 3 లేయర్ ల నియంత్రణ, subscriberసాధారణంగా
వ్యాఖ్యానిస్తుంది.
క్వెరీస్  కి onసర్ ఇచ్చేటపుడు
tap నుంచి down కి పొరల ద్వారా ముందుకు
పంపబడతాయి.
IaaS cloud architecture లో cloud మేనేజర్ భౌgoళికంగా పంపిణీ చేయవచ్చు.
cluster మేనేజర్ లోపల, computer
మేనేజర్ అధిక వేగ network ద్వారా
అనుసంధానించబడి ఉంటుంది.
cluster నిర్వాహకుడిని చూస్తే, ఇవన్నీ అధిక
వేగ network ద్వారా connect
చేయబడతాయి.
ఇప్పుడు మీరు cloud మేనేజర్  operation
చూస్తే; tap  లో cloud మేనేజర్, తర్వాత cluster మేనేజర్, ఆ
తర్వాత వ్యక్తిగత విషయాలు నిర్వహించే
computer మేనేజర్  ఉంటాయి.
మీరు cloud మేనేజర్ విధి చూస్తే, ఇది
cloud యొక్క public access
పాయింట్.
కాబట్టి, ఎవరైనా cloud  ను public
లో access చేసినప్పుడు, subscriber,
అక్కౌంట్ ని నిర్వహించడానికి, cloud నుండి
రెంట్ కు తీసుకున్న resources  ని
నిర్వహించదానికి సైన్  చేస్తారు.
cloud మేనేజర్ subscriber
ని అతెంticket  కొరకు కొన్ని పద్దతులు
ఉంటాయి.మొదటిది అతెంticket  విధానాలు, VM
లతో కమ్యూనికేట్  అయ్యేటపుడు
subscriber ఉపయోగించే access
క్రెడెన్షియల్ ను రూపొందించడం
లేదా ధృవీకరించడం రెండవది.
ప్రధానంగా మొత్తం వ్యవస్థ యొక్క ఫ్రంటెండ్
అయినప్పుడు, మూడవది, ఉన్నత స్థాయి resources
నిర్వహణ.
subscriber అభ్యర్థన కోసం cloud
మేనేజర్, cloudలో తగినంత ఉచిత resources
ని గుర్తింస్తుంది.
కాబట్టి, cloud మేనేజర్ మెటాdata సమాచారాన్ని నిర్వహిస్తుంది.
కాబట్టి, ఒక నిర్దిష్ట VM లేదా cloud
లో అందుబాటులో లేని VM ల సెట్  కోసం నేను
అభ్యర్థిస్తే, cloud మేనేజర్కి
call చేయాల్సి వస్తుంది.
కనుక, అది subscriber ల చేత నిర్వహించబడుతుంది.
data ఆబ్జెక్ట్ storage లేదా DOS అని
పిలువబడే ఒక విషయం ఉంది. యూజర్ క్రెడిట్
ఆపరేటింగ్ సిస్టం మొదలైన
వాటి గురించి మాట్లాడుతున్నందున DOS సాధారణంగా చందాదారుల
మెటాdataను నిల్వ చేస్తుంది.
సాధారణంగా DOS service  cloud  కి
ఒకటే ఉంటుంది.
కాబట్టి, నిర్దిష్ట DOS service  అనేది
ఒక నిర్దిష్ట cloud కోసం అని చెబుతున్నాం.
కాబట్టి, ఇది మన మొత్తం రిజిస్ట్రీ లేదా
cloud జాబితా లేదా ఒక మెటాdata service ని నిర్వహిస్తుంది.
అందువల్ల, మొత్తం విషయం యొక్కByండింగ్
బ్లాక్, ఉచిత resources  అందుబాటులో
ఉన్నయా లేదా మొదలైన వాటిని అన్నింటిని
appడేడ్  చేయడం.
ఈ మిడిల్ లవేల్  cluster మేనేజర్ని చూస్తే.
హై స్పీడ్ లోకల్ ఏరియా network ద్వారా అనుసంధానించబడిన computerలు
సేకరణకు ఇది బాధ్యత వహిస్తుంది.
కాబట్టి, ఇది లో level  computerలను
నిర్వహిస్తుంది, cluster మేనేజర్ ఎగువన ఉన్న cloud మేనేజర్ నుండి
resource కేటాయింపు ఆదేశాలు మరియు ప్రశ్నలను
పొందుతుంది.
cluster  లోని computerల
యొక్క resources ను ఉపయోగించి కమాండ్ను
యొక్క పార్ట్  లేదా మొత్తాన్ని
సంతృప్తిపరచవచ్చో లెక్కిస్తుంది.
అనగా, cluster మేనేజర్ కి రెక్వెస్ట్
 అందినప్పుడు, cluster లో రెsourceవుందో,
లేదో తనిఖీ చేస్తుంది; ఇది విషయాలను సంతృప్తి
చేయగలదా మరియు అనుగుణంగా అది విషయాలకు తగిన
సిగ్నల్ను చెబుతుంది.
అలాగైతే, అది ఆమోదించవచ్చు లేదా ఆమోదించకపోవచ్చు
మొదలైనవి వుంటాయి.
cluster మేనేజర్ రెsource లభ్యతను
గుర్తించడానికి clusterలోని
computerల కోసం computer మేనేజర్ ని ప్రశ్నిస్తాడు, cloud మేనేజర్ కి సందేశాలను పంపుతాడు.
అనగా, అది computer మేనేజర్, cluster
మేనేజర్ మరియు cloud మేనేజర్ కి మధ్య మిడిల్ వేర్ లేదా ఏజెంట్
గా పనిచేస్తుంది.
మీరు operationను చూస్తే, అక్కడ cloud
మేనేజర్ కోసం దిశను నిర్దేశిస్తుంది.
మరియు ఆపై రెsource కేటాయింపు, రీ కాన్ఫిగరేషన్
, రెsource డి అల్లోకేషన్
మరియు ఇతర విషయాలను నిర్వహించడానికి
computer మేనేజర్ల ను నిర్దేశిస్తుంది.
cluster మేనేజర్ నిరంతర స్థానిక
storage కు అనుసంధానిస్తారు; cluster మేనేజర్ పెర్సిస్టంట్ storageకి
అనుసంధానించబడి ఉంటుంది.
అనగా ఇది కోట్ లేదా uncoated నోన్ వొలటైల్
storage.
నిర్దిష్ట వర్చ్యువల్ mission, షట్down అయినప్పుడు, లేమి లేదా కొన్ని problemలు
వస్తాయి.
సో, అది విషయాలు లోకి స్థానిక నిల్వ కలిగి.
కాబట్టి, ఈ PLS వర్చ్యువల్ mission కి storage
 వంటి పెర్సిస్టంట్  డిస్కును
అందిస్తుంది.
కాబట్టి, అదే నిరంతర డిస్క్ ఉన్నట్లయితే.
కాబట్టి, మీరు తర్వాతి సమయం లాగిన్  చేసినప్పుడు
data అందుబాటులో ఉంటుంది.
మేము cloud మేనేజర్ operation
చూస్తే.
సోపానక్రమంలో అత్యల్ప స్థాయిలో, ప్రతి
computer Systemలో రన్ అయ్యే cloud
మేనేజర్, subscriber కి virtual
machine అందించడానికి, Virtualization
 ని ఉపయోగిస్తుంది.
కాబట్టి, cloud మేనేజర్ ప్రాథమికంగా
VM లను అందిస్తుంది.
ఇది బాధ్యత వహించే VM లను అందించే subscriber
కి, computer మేనేజర్ ఎన్ని
వర్చ్యువల్ missionలు నడుపుతున్నారో
లాంటి స్థితి సమాచారాన్ని మొదలైనవి నిర్వహిస్తుంది.
కాబట్టి, అది ఎన్ని విర్జిషియల్ మెషీన్లు నడుపుతున్నాయనేదాని స్థితి సమాచారమును
నిర్వహిస్తుంది.
దీని తో పాటు cloud మేనేజర్ వర్చ్యువల్
missionల ను ప్రారంభించడానికి,
సస్పెండ్ మరియు పునఃనిర్మించటానికి
హైపర్విజర్ కు కమాండ్ interface
ను ఉపయోగిస్తుంది.
computer మేనేజర్ అవసరం ఉంటే అది
కూడా ఒకటే. hereంత మనం చూసేది, Virtualization
 యొక్క ముఖ్యమైన పాత్ర.
ఎలా ఈ Virtualization  తయారుచేస్తాం
మరియు దాని అంశాలు మొదలైనవి: వీటన్నిటి
గురించి తదుపరి Slideలలో త్వరగా చూడటానికి
ప్రయత్నిస్తాం.
కాబట్టి, వర్చ్యులైజేషన్  ఒక విస్తృత
పదం, ఇది ఒక వర్చ్యువల్ మెమొరీ కావచ్చు,
వర్చ్యువల్ network కావచ్చు, వర్చ్యువల్
storage, మొదలైనవి కావచ్చు.
దేన్నైనా మనం Virtualize  చేయగలిగితే
దాన్ని వర్చ్యులైజేషన్  అంశం అంటాం.
మా ప్రాధమికంగా వర్చ్యులైజేషన్  వేదిక కోసం
దృష్టి పెడుతున్నాం.
వర్చ్యులైజేషన్ ప్రాథమికంగా, ఒక
computer, ఒకే hardware 
resource  లను ఎక్కువ ఎన్విరాన్మెంట్
 లో పంచి, బహుళ computerల
యొక్క పనిని చేయడానికి అనుమతిస్తుంది.
కాబట్టి, ఇది ముఖ్యమైనది; దీని అర్ధం, నాకు
ఒక బేర్ మెటల్ ఉంది, నేను విభిన్న
machine లను లేదా వర్చ్యువల్ missionలను సృష్టించగలము.
కానీ బాక్ ఎండ్ లో, అదే బేర్ మెటల్ రన్ అవుతుంది.
ఇప్పుడు ఇది చాలా గమ్మత్తైనది.
మీరు ప్రత్యేక ఎన్విరాన్మెంట్  లో, మీ బేర్
మెటల్ ను కలిగి ఉన్నాం అనుకుందాం
మరియు మీరు Windows లో ఒక machine  రన్
 చేస్తున్నాం, Linux లో ఒక mission Guest
OS, లేదా ఇతర విషయాలు మొదలైనవి ఉపయోగించవచ్చు.
ఈ గెస్ట్ OS యొక్క ఇంస్ట్రక్షన్ సెట్
, hardwareలోఎలా అమలవుతుందనే problem
ఉంది. కాబట్టి, ఆ problemలనేవి ఉన్నాయి, application
 సిజింగ్  సమయాలు ఉన్నాయి.
VM కు ఎక్కువ resources  అవసరం అయినప్పుడు
లేదా ఇతర resources  ని విడుదల చేసినపుడు,
ఎలా నిర్వహించాలో మరియు అలా ఎలా కొనసాగించాలో
వాటికి సంబంధించి కొన్ని problemలు ఉన్నాయి.
కాబట్టి, మనము హార్డువేర్ చూద్దాం.
కాబట్టి, ఇది ఒక వర్చ్యులైజేషన్ లేకపోతే, ఒకే OS అన్ని
హార్డువేరు resource  లను నియంత్రిస్తుంది.
ఇది ఒక వర్చ్యులైజేషన్ ఒకే ఫిజికల్ platform
 పై బహుళ వర్చ్యువల్ కంటైనర్లను
నడపడం సాధ్యపడుతుంది.
కాబట్టి, మనము బహుళ virtual కంటైనర్లను కలిగి ఉంటాము, అవి ఒకే ఫిజికల్
platform  పై అమలు చేయవచ్చు
లేదా ప్లగ్ చేయబడతాయి.
ఈ వర్చ్యులైజేషన్తో మనకు కొంతవరకు అనుభవము
ఉంది. అందువల్ల, వర్చ్యులైజేషన్ ఒకే హార్డువేరు
నందు బహుళ ఆపరేటింగ్ System లను
మరియు యూజర్ application నడుపుటకు ఒక
మార్గం.
కాబట్టి, ఇది Virtualize  చేయబడుతుంది
. కాబట్టి, నేను ఒకేసారి machine పై 2 విభిన్న
ఆపరేటింగ్ Systemను కలిగి ఉండగలను.
అనగా, దీనిలో ఒక OS ని Virtualize
చేస్తాను, కాబట్టి, windows మరియు
లైనక్స్ రెండింటినీ ఇంకొక వైపు అమలు
చేస్తాము.
డబుల్ బూట్ కోసం ఇది ఎలా విభిన్నంగా
ఉంటుంది?
ఒకసారి windows లో చేయడం మొదలైనవి.
here Virtualization విషయంలో, ఈ వేర్వేరు
OS లేదా అన్ని OSలు ఒకేసారి లేదా ఒకే సమయంలో
కలిసి రన్ అవుతాయి.
OS లు ఒక దాని నుండి మరొకటి completely
వేరుచేయబడతాయి.
నిజమైన Virtualization  విషయంలో ఒకదానితో
ఒకటి completely వేరుచేయబడతాయి.
ఇందులోకి మరో ముఖ్యమైన అంశం వర్చ్యువల్
mission మానిటర్ లేదా హైపర్విజర్.
కాబట్టి, ఒక హైపర్విజర్ లేదా virtual
మెషీన్ మానిటర్, గెస్ట్ OSను CPU పై నేరుగా నడుపుతుంది.
అందువల్ల నేను ఒక అతిథి OS ను కలిగి
ఉన్నాను మరియు దానిని నా అక్కౌంట్ లో
చోటు చేసుకున్న లేదా subscriber 
ద్వారా ఇంస్టాల్  చేయబడుతుంది
లేదా అమలు చేయబడుతుంది లేదా client యొక్క
application లో ఉంటుంది.
ఆపై హైపర్విజర్, దీన్ని అమలు చేయడానికి
లేదా ఈ గెస్ట్ OS ను నేరుగా hardwareలో,
బాక్ ఎండ్ లో అమలు చేయబడుతుంది.
కాబట్టి, Guest OS, host OS ఒకే ఇంస్ట్రక్షన్
సెట్ ఉపయోగిస్తే పనిచేస్తుంది.
ఇది విభిన్న ఇంస్ట్రక్షన్ సెట్ ఉంటే,
appపుడు ఒక ఇంస్ట్రక్షన్ ట్రాన్స్లేషన్  ఉపయోగిస్తాము.
పోప్ కె మరియు goల్డ్బెర్గ్
వర్ణించిన అనేక problemలు ఉన్నాయి.
వర్చ్యువల్ mission architecture యొక్క 3 goల్స్ ఉన్నాయి: 1.
ఇక్వివలెన్స్ , అంతర్లీన hardware
నుండి VM లను వేరు చేయరాదు.
కనుక, వర్చ్యువల్ mission, హార్డువేరు
మీద నడుస్తుంటే.
దానిని మనము ఇక్వివలెన్స్  అంటాము.2, రెsource
కొంట్role , VM కి Virtualizeడ్
రెsource  పై అసంపూర్తి నియంత్రణ
ఉండాలి.
కాబట్టి, మీరు నాకు 4 GB machine, 30 GB లేదా
60 GB Hard Disk ఇస్తే, subscriber
గా వాటి పై పూర్తి నియంత్రణ ఉంటుంది.
మరియు 3.
ఎఫిషియెన్సీ , అధిక VM ఇంస్ట్రక్షన్లు
హైపర్విజర్తో సంబంధం లేకుండా అంతర్లీన
CPU పైన నేరుగా అమలు చేయాలి.
కాబట్టి, అది మరొక విషయం.
virtual మెషీన్ బోధన యొక్క అధికభాగం,
ఈ ఇతర ప్రమేయం హైపర్విజర్ యొక్క జోక్యం లేకుండా
నేరుగా CPU పై అమలు చేయగలగడం వలన సామర్థ్యం
పెరుగుతుంది.
అందువల్ల, మనము VM లను అనుకరించటానికి
అనుమతించే ప్రదేశంలో వర్చ్యువల్ mission
మానిటర్ లేదా హైపర్విజర్
వున్నప్పుడు, వీటిని పరిశీలించవలసిన
అంశాలు.
అదే work లో ఈ పొపెక్ మరియు
goల్డ్బెర్గ్ ను వివరించారు మరియు
ఈ లక్షణాలను జరిగేలా అనుమతించే CPU ల ఇంస్ట్రక్షన్ల
యొక్క అవసరాన్ని అందించిన ఒక అధికారిక
రుజువుని కూడా ఇస్తారు.
నిజంగా Virtualization IaaS స్థాయిలో జరిగేలా
చేయాలంటే, ప్రధానంగా , ఈ ఇంస్ట్రక్షన్
3 విభిన్న విషయాలగా వర్గీకరిస్తుంది.
అందులో ఒకటి ప్రివిలైజ్ద ఇంస్ట్రక్షన్ ,
ఇది యూసర్ మోడ్ లో ఎక్జిక్యూట్
 చేసినప్పుడు, ట్రాప్  జరగవచ్చు.
here సెన్సిటివ్ inస్ట్రక్షన్ ఉంది, ఇది అంతర్లీన రెsource ను
మారుస్తుంది, అది IO చేస్తోంది లేదా
గెస్ట్  OS, బార్  లో నడపబడుతున్న
వాస్తవాన్ని మారుస్తుంది; మొదటిది IO లేదా payజ్
టేబుల్స్ లను మార్చడం లేదా ప్రస్తుత
అధికార స్థాయిపై సమాచార సూచనలను గమనించడం.
మీరు మీ ప్రాథమిక architecture 
అంశాలను గుర్థిన్చినట్లైతే.
మనము వివిధ స్థాయి లో operation 
ను కలిగి ఉన్నాము, అవి level 0,level
 1 మొదలైన వేర్వేరు స్థాయి కార్యకలాపాలు.
మరింత తక్కువ level  వెళ్ళేకొద్ది,
బేర్ మెటల్కి మరింత దగ్గరగా వెళ్తాము.
ఇది అన్నిటిని నిర్వహించే Virtualization
పై ఆధారపడి ఉంటుంది.
మరింత పై level  వెళ్ళేకొద్ది
మరింత లాటెన్సి  వస్తుంది, మరియు
మరింత అనువాదం అవసరం అవుతుంది.
కాబట్టి, మనము ఏ level  operation లు
చేయాలనే విషయాన్ని పరిశీలిద్దాం; ప్రత్యేకంగా
మనము IaaS సంభందిత operation  లు చేస్తున్నప్పుడు.
సెన్సిటివ్  ఇంస్ట్రక్షన్
ల యొక్క మొదటి క్లాస్  ని కంట్role సెన్సిటివ్
 అని మరియు తర్వాతి క్లాస్ 
ని బెహెవీర్ సెన్సిటివ్ 
అని అంటాము.
Popek మరియు goల్డ్బెర్గ్ ఏమి చెబుతుందంటే,
ఈ 3 ఉపయోగపడే ప్రాపర్టీస్ ల తో Virtual machine
 రన్ చేస్తే సెన్సిటివ్ ఇంస్ట్రక్షన్
లు , ప్రివిలైజ్ద ఇంస్ట్రక్షన్ 
లకు సుబ్సెట్  గా ఉంటాయి.
వారి పనిలో వీటన్నిటిని చూపిస్థాయి, ఈ రకమైన
విషయాలు నిజమైనవి మరియు నిజమైన Virtual
machine  ని గుర్తించగలము.
ఇదే విషయం లేదా మనం చర్చించే ఏవైనా.
ఈ virtual machine మానిటర్ల పై ఈ VM లు మరియు ఈ హార్డువేరు
రన్ అవుతుంటాయి.
మరియు ఈ వేర్వేరు VM లను అనుకరించటానికి
ఇది అనుమతిస్తుంది.
కాబట్టి, ఇది మీదే కావచ్చు.
కొన్ని చోట్ల ఏదైనా గెస్ట్ OS, VM పై రన్
 అవుతుంటుంది.
కన్వర్ట్  చేయవలసిన ఇంస్ట్రక్షన్ ల
సమితి ఈ hardwareకు  అర్ధం చేసుకోగలగాలి.
కాబట్టి, అది మన బాటమ్ లైన్.
మొత్తం VMM మొత్తం అబ్స్త్రాక్సన్
 ను కలిగివుందా లేదా ఏదో ఒక విధమైన
ఒవెర్లప్పింగ్ ఉందా లేదా అనేది
దానిపై ఇంప్లిమెంటేషన్ పై ఆధారపడి ఉంటుంది.
కాబట్టి, Virtualization సాధారణ విధానాలకు
సమీపంలోని విధానాలను పరిశీలిస్తే.
మీరు ఈ Virtualization యొక్క పరిణామమును
చూసినట్లయితే, మనము మొదటిది ఫస్ట్ జెనెరేషన్ లేదా ఫుల్ Virtualization, దీనినేByనరీ
రీరైటింగ్ అంటాము.
కాబట్టి, ఇది Software ఆధారిత అంశం, VMware మరియు
microsoft దీనికి మద్దతిస్తుంది.
ఏ వర్చ్యువల్ missionలు, డైనమిక్ ట్రాన్స్లేటర్ను
 సృష్టించినా, అండర్ లైనింగ్ హార్డువేరుకు
రీరైట్ చేస్తాయి.
సెకండ్ జెనెరేషన్ లో: Virtualization
లేదా పరా వర్చురైజేషన్, కొ ఓపెరటివ్
 Virtualization.
ఇది అతిథి OS లేదా మోడిఫెడ్ గెస్ట్,VMware మరియు xen ల కొ ఓపెరటివ్  Virtualization.
కాబట్టి, మీరు here చూస్తే ప్రాథమికంగా
ఇది VM లోకి కొంచెం చొచ్చుకొచ్చింది;
అంటే, అంశాలపై సవరించబడింది.
ఒక మూడవ జనరేషన్ లేదా సిలికాన్ ఆధారిత
అంశం, hardware సహాయంతో Virtualization
వర్చ్యులైజేషన్ అవగాహన hardware
ప్లాట్ఫారమ్లో లో, on మోడిఫీడ్
గెస్ట్ , VMware మరియు xen ఉంటాయి, ఇప్పుడు
మీ hardware ప్లాట్ఫారమ్కు Virtualization
తెలుసు.
కాబట్టి, ఇది hardware asసిస్టెడ్ 
Virtualization.
ఈ సందర్భాలలో ఈ hardware ప్లాట్ఫారమ్లో లకు ఈ Virtualization గురించి తెలియదు.
ఈ మీ హైపర్విజర్ చేత ఏమి జరిగినా?
ఫుల్ Virtualization లో వివిధ అంశాలు
ఉన్నాయి, ఫస్ట్ జెనెరేషన్ ఫస్ట్ జెనెరేషన్ x86/x64 server ఫుల్ Virtualizationను అందిస్తుంది.
source కోడ్ యొక్క డైనమిక్Byనరీ
ట్రాన్స్లేషన్, మనము చూసినట్లుగా
అన్ని hardware లు CPU తో సహా ఎమ్యులేటెడ్
అయ్యి ఉంటాయి.
2 ప్రముఖ open source ఎమెల్యూటర్లు
 ఉన్నాయి, వాటిలో ఒకటి చాలామందికి
తెలిసిన QEMU మరియు రెండవది Bochs . ఇవి రెండు
open source ను మార్చే ప్రముఖ
ఎమెల్యూటర్లు .
పూర్తి Virtualization, ఎమ్యులేషన్ లేయర్
 యొక్క ప్రయోజనాలు ఉన్నాయి.
మొత్తం VM portability, నేను VM ను ఒకదాని
నుండి మరొకదానిలో ఉంచగలము.
కాబట్టి, మొత్తం portabilityని
ఉపయోగిస్తాము, ఎందుకంటే VMM మాత్రమే, మనకు అర్థం
అవుతుంది.
ఈ hardware ఎమ్యులేషన్స్ performance  Tierతో పాటు వస్తుంది.
ఇది ఇందులోని ఒక లోపం.
మీరు ట్రడిషనల్ x86 architecture
లో హార్డువేర్ performance Tierను అనుకరించాలనుకున్నప్పుడు,
OS కెర్నెల్ లు ప్రత్యేక హక్కు ప్రివిలేజ్
రింగ్0 లో రన్ అవుతుందని అనుకుంటున్నాం.
ఇప్పుడు మీరు వాటిని అధిక level  లో
అమలు చేయాలనుకుంటే, ఎక్కువ లాటెన్సి
ఉండాలి మరియు ఇతర విషయాలను కూడా పరిశీలించాలి.
కాబట్టి, మనం దాని కోసం pay  చెయ్యాల్సిన
అవసరం ఉంది లేదా performance 
Tier మనకు అవసరం.
పారా వర్చురైజేషన్ విషయంలో, గెస్ట్
OS సవరించబడింది మరియు రింగ్ 1 లేదా రింగ్
3 వద్ద కెర్నల్ level  ఆపరేటింగ్
System ను అమలు చేస్తుంది.
ఇది అధిక level  గెస్ట్ గా ఉంటుంది,
ఇది ప్రివిలేజ్ ఇంస్ట్రక్షన్  ను ఎలా ప్రాసెస్
చేయాలో తెలుసుకోగలదు.
VMM కు అనువదించబడిన ప్రివిలేజ్ 
ఇంస్ట్రక్షన్  ఇకపై అవసరం లేదు.
గెస్ట్ నిర్వహణ వ్యవస్థలు ప్రత్యేక
API ను VMM తో కమ్యూనికేట్ అవడానికి ఉపయోగిస్తాయి.
కాబట్టి, ఇది పారా; దీని అర్థం, మీ VMM,
కొన్ని రకాలైన VM లను ఉపయోగించడానికి
చొచ్చుకుపోతుంది.
కనుక, ఇప్పుడు అది పూర్తి అనువాదం కాదు,
కానీ ఒక పారా వర్చురైజేషన్ performance
 పెరుగుతుంది మరియు ఈ విషయం బాగా
ప్రజాదరణ పొందుతోంది.
పారా వర్చురైజేషన్ విషయంలో, OS
కెర్నెల్ను రి కంపైల్ చేయాల్సిన
అవసరము ఉంది, దీనిని ఉపయోగించాలంటే, పారా
Virtualizeడ్ డ్రైవర్ల
యొక్క inస్టలేషన్  అవసరం.
ఇది, గెస్ట్ OS లెవేల్ లో జాగ్రత్తలు తీసుకుంటుంది.
మూడవది, hardware asసిస్టెడ్ వర్చురైజేషన్, గెస్ట్ OS రింగ్ 0 లో రన్
 అవుతుంది.
VMM, ఇంటెల్ VT లేదా AMD V లలో ఉన్నట్లుగా
Processor ఎక్స్టెంషన్స్  లను ఉపయోగిస్తుంది
మరియు గెస్ట్  లో ఉన్న ప్రివిలైజెడ్
 operation  లను inర్సెప్ట్
 చేస్తుంది.
హార్డువేర్ సహాయంతో Virtualization
అనేది, ఒక VMM ను వ్రాసేటప్పుడు జరిగే అనేక problemలను
తొలగిస్తుంది, అది ఒక పెద్ద సవాలు.
ఇది hardware అసిస్టెంట్; అనగా, మీరు నేరుగా
పొందగలిగితే అది completely కంపైల్
 అయి ఉంటుంది.
ఇలా చేయడం వల్ల, మీరు VM ల యొక్క పోర్టబిలిటిని
కోల్పోతారు, ఇది గమ్మత్తైన problemగా
మారుతుంది, ఎందుకంటే hardwareని
అర్థం చేసుకునే machine కి మీరు మైగ్rate
అవ్వాలి.ఉపయోగం, అది అన్మోడిఫైడ్
OS ని రన్ చేయడానికి అనుమతిస్తుంది, మీరు
OS లు మార్చల్సిన అవసరం లేదు; లోపం, స్పీడ్
 మరియు ఫ్లెక్సిబిలిటీ  ల problem ఉంది.
మైగ్రేషన్ జరిగినప్పుడు మీరు ఫ్లెక్సిబిలిటీ
 కోల్పోతారు మరియు స్పీడ్ ,
మైగ్రేషన్ పై ఆధారపడి ఉంటుంది.
మనం నెట్ work Virtualization యొక్క కొన్ని అంశాలపై
మనము చర్చించుకుందాం.
ఇప్పటి వరకు మనము హార్డువేర్ level
 లో చూసాము, ఇప్పుడు మనం network
level  లో చూద్దాం; అంటే, ఇచ్చిన networkలోని
ఒక వర్చ్యువల్ నెట్ work పై నెట్
work ను అనుకరించాల్సిన అవసరం ఉంది.
network టెక్నాలజీలో మనం చూసే విలక్షణ
విధానాలు అంటే ఐపి బేస్ లేదా ఎటిఎమ్
బేస్ లేయర్ .
వర్చ్యులైజేషన్ యొక్క ఏ లేయర్
లో ఆర్చిటెక్చురల్ domain ఉంటుంది,దీనిలో
network వనరుల ajamanyaాలు, స్పానింగ్
 networkలు ఉంటాయి, వర్చ్యులైజేషన్
level  లో,Node level  లేదా ఫుల్ వర్చ్యులైజేషన్ వంటివి ఉన్నాయి.
మనం ఈ network కలిగి ఉన్నాం అనుకుందాం.
appపుడు మనం ఇలాంటి network ను
ఎమ్యులెట్చేస్తాం, కనుక, ఇది నా బేస్
network.
మనము 2 రకాల వర్చ్యువల్ network
లను దీని పైన కలిగివున్నాము.
ఒక virtual networkను మనము ఎమ్యులెట్
చేశాము, వాస్తవంగా ఎందుకు మనము విర్చువలైజ్
 కి వెళ్ళాలి అంటే మన స్వంత networking
పారాడిగ్మ్లో internet స్తంభించడం
మాత్రమే కాకుండా, స్payస్  ఎక్కువ
ఉండదు.
ఒన్ size ఫిట్స్ అల్  architecture
 ని తీసుకుని రావడం చాలా కష్టం.
మనము network కాన్ఫిగరేషన్ ని కలిగి ఉంటాము
మరియు ప్రతిఒక్కరికీ సరిపోతుంది.
ఎందుకు మనం వివిధ సినారియో  లకు
అన్నీ create  చేయడానికి బదులుగా
అన్నిటికి సరిపోయేవిధంగా ఒకే రకం create
 చేయకూడదు.
ఇదే మనం చేయాలనుకుంటున్నాం.
కాబట్టి, భవిష్యత్ network architectureల మరియు ప్రోటోcallలు కోసం టెస్ట్ బెడ్
లు ఉన్నాయి.
కనుక, మనము ఒక విధమైన Virtualize network కలిగి ఉంటాము.
మరియు ఇది అకస్మాత్తుగా ఇందులోకి రాలేదు,
ఇది ఇప్పటికే ఒక virtual private
network , ప్రోగ్రామబుల్
network, మరియు ఓవర్లే networkలు మొదలైనవి ఇప్పటికే చాలా ఉన్నాయి.
ఇది వాటిపై ఎమ్యులేట్ చేయబడుతోంది.
మనము here చూసినట్లైతే, వివిధ అంశాలు,అనగా
business model ,business
architecture , డిజైన్ ప్రిన్సిపుల్స్ మరియు డిజైన్ goల్స్  ఉన్నాయి.
మరియు infrastructure providerస్, Service provider, ఎండ్ యుసెర్స్
, మరియు బ్రోకర్లు వంటి వివిధ అంశాలు
ఉన్నాయి.
ఇవి వేర్వేరు ప్లాయెర్స్  మరియు వారి మధ్య
చాలా complex సంబంధం ఉంటుంది.
మరియు business model , ఈ network
Virtualization కు మాత్రమే
సరిపోదు, అది Virtualization యొక్క ఇతర అంశాలకి
కూడా సరిపోతుంది .
కాబట్టి, నేను ఆ infrastructure providerని కలిగి ఉంటే, appపుడు నేను ఒక
Service provider 1 ను కలిగి ఉండి,
ఒక విధమైన Virtualize network
ను కలిగి ఉంటాను.
దీని నుండి ఎమ్యులెట్ చేసినవి, కొన్ని
networkలను ఆక్టివేట్ చెయ్యడం
మదలైనవి.
మనము ఇతర రకాలైన Service provider 2, SP2 ఇతర రకాలైన networkలులను
కూడా ఎమ్యులెట్ చేయడం, కనుక, నేను
ఒక ప్రాథమిక అంతర్లీన network లో
వివిధ రకాల network లను ఎమ్యులెట్
చేస్తుంది.
కాబట్టి, మనము వివిధ రకాల networkలులను
ఏర్పరచవచ్చు.
కాబట్టి, ఇవి చాలా ప్రజాదరణ పొందాయి.
serverలు మాత్రమే కలిగి వుండకుండా
భౌgoళిక స్payస్ అంతటా ఒక నిర్దిష్ట
పరీక్ష నిర్వహించాలని అనుకుంటాను.
కాబట్టి, నేను ఈ serverలను తీసుకురావడం మాత్రమే
కాకుండా నేను ఒక నిర్దిష్ట network
infrastructure కావాలి అనుకుంటాను.
ఇలా చెయ్యాలి అంటే appపుడు IASS స్థాయి
లేదా server స్థాయి Virtualization మాత్రమే
ఉంటే సరిపోదు, network level Virtualization కూడా కావాలి మరియు ఈ మొత్తాన్ని
నేను ఒక వాస్తవిక ఐపి infrastructure
స్థానంగా పొందగలగాలి.
కాబట్టి, మా చర్చలు మా తదుపరి ఉపన్యాసాలలో
మేము కొనసాగిస్తాము.
ధన్యవాదాలు.
స్వాగతం.
నేడు, మన cloud architecture పై కొంత చర్చ
కొనసాగుతుంది మరియు ఒక cloud యొక్క
కొన్ని ప్రత్యేకమైన అంశాలను, అందులో
ఒకటి Virtualization  చూద్దాం.
మునుపటి Lecture  లలో మనము వివిధ
రకాలైన Service modelస్ పై చర్చించాం
, అలాగే cloudలో వివిధ రకాలైన deployమెంట్
modelలు,అయిన public , private ,
hybrid మరియు community cloud లు ఉన్నాయి.
వేర్వేరు అంశాలు మరియు అన్ని రకాలైన
serviceలు వేర్వేరు రకాలైన మోహరింపు modelలలో
host చేయబడతాయి, సరియైనవి.
ఒక public cloud, payరులో
సూచించినట్లుగానే ఇది ఎక్కువ మందికి
అందుబాటులో ఉంటుంది.
కనుక, దీన్ని ఎవరైనా purchase చేయవచ్చు
మరియు ఇది internet అంతటా అందుబాటులో
ఉంటుంది.
చాలా ప్రసిద్ధ ఉదాహరణలలో కొన్ని Google app Engine, microsoft azure, IBM cloud,
amazon EC2 మొదలనవి, అనేక ఇతర cloud
 లు ఉన్నాయి.
ఈ public cloud ని ఒక institution లేదా
వ్యక్తిగత అవసరాలకు Subscribe 
చెయ్యొచ్చు.
internetలో ఈ public cloud సబ్స్క్రిప్షన్  మరియు దాని
services  గురించిన వివరాలు ఉంటాయి.
కాబట్టి, ఈ cloud  infrastructure
 లు సామాన్య ప్రజానీకం, institutionలు
, enterprise  లు మరియు ఎవరైతే
చెల్లించి , ఉపయోగించగలరో వారి కోసం కేటాయించబడతాయి,
ఇందులో ఖచ్చితంగా కొన్ని చట్టపరమైన
విధాన problemలు ఉన్నాయి.
కాబట్టి, ఇది వ్యాపారం, విద్యావేత్తలు, ప్రభుత్వ
institution లేదా వాటి యొక్క కొన్ని Hybridizationల
ద్వారా నిర్వహించబడుతుంది.
ఇది cloud provider యొక్క అదీనంలో
ఉంటుంది.
కాబట్టి, భౌతికంగా ఇది CSP యొక్క ఆవరణలో
లేదా premisesలో ఉంటుంది, అందుచే
computing infrastructure, storage
infrastructure మరియు ఇతర
రకాలైనవి CSP లు లేదా cloud provider
premisesలో ఉంటాయి, అంతేకాని private
లేదా consumerల అదీనంలో ఉండవు, కాబట్టి
ఇది ఒక అంశం.
మరియు public అమరికలో, provider
యొక్క computing మరియు storage 
resources  అధిక మొత్తంలో సమర్థవంతంగా
ఉంటాయి , కాబట్టి ఇది అందరికీ ఉపయోగపడుతుంది.
Communication లింకు లు ,public
internet , service ల మీద
అమలు చేయబడతాయి; మరియు cloud service
 అనేది అన్ని client  యొక్క
ఒక విభిన్న సమూహం పై పనిచేస్తుంది
మరియు వాటిలో అందరూ విశ్వాసకులుగా ఉండకపోవచ్చు,
వారిలో కొనదారు హానిపరులు,హాకర్లు మొదలైనవాళ్లు ఉండవచ్చు.
కాబట్టి, ఇది సాధారణంగా ఒక service provider
ను కలిగి అందరికీ , ఎవరైతే Subscribe
 చేసుకుంటారో వారందరికి ఉపయోగకరంగా
ఉంటుంది.
ఇందులో విభిన్న రకాల consumerలు ఉంటారు.
విలక్షణమైన లక్షణాలలో ఒకటి workload
స్థానాలు client కు తెలియవు , ఇది ప్రధానమైన
వాటిలో ఒకటి consumerనిగా మన virtual machine మరియు మన వాస్తవికData ఎక్కడ ఉంటుందో
అంటే ఏ server లో లేదా ఏ virtual
machine  లో ఉంటుందో మనకు తెలియదు,
కాబట్టి, security మరియు ఇతర అంశాల గురించి
చట్టపరమైన మరియు విధానపరమైన అంశంపై
మీరు కఠినంగా లేకుంటే, మీరు శ్రద్ధ వహించకపోతే,
చాలా కాలం ఉండే మన servicesకి.
multi tens నుంచి ప్రమాదం ఉంటుంది;
అనగా, మన computing మరియు storage 
ఎక్కడ ఉంటుందో అక్కడ ఇతర consumerల
data కూడా ఉంటుంది.
ఇది తార్కికంగా లేదా theoretically సాధ్యం
అవుతుంది.
ఇప్పుడు, కొన్ని institutionలకు చెందిన
వ్యక్తులు లేదా మరికొందరు విశ్వాసం లేనివారు
వుంటే అది మనకు సౌకర్యవంతమైన కాదు, ఇద్దరు వేర్వేరు
consumerలు ఇద్దరూ ఇదే విషయాల్లో పనిచేయగలరు.
కాబట్టి, ఇతర అర్ధంలో here ప్రమాదం ఉంది;
ముందు మనం చూసిన multi-tenancy వలన కూడా నష్టాలు ఉన్నాయి, ఎందుకంటే
అక్కడ services  ఎక్కడ ఉన్నాయో
మనకు తెలియదు,Data servicesని
మరియు ఇతర రకాలైన resources  ని
access చేయడానికి ఒక నిర్ధేశిత channel
ఉన్నదా లేదా అనేది తెలియదు, కనుక, ఈ multi-tenancy వలన ప్రమాదం ఉంది. అందువల్ల, ఒకే machine
లు అన్నీ work load లకు , subscriber
 లకు share చేస్తారు.
ఈ work load లు పోటీదారు work
load లు అన్నీ కలిపి ఒకేచోట ఉంటాయి,
కాబట్టి ఇది reliability మరియు security ప్రమాదం
రెండింటిని పరిచయం చేస్తుంది.
onsite public cloud వినియోగాన్ని
పరిగణనలోకి తీసుకున్న institution network
dependency ని పరిగణించాలి.
ఎప్పుడైనా IIT Kharagpurలో lab ల్లో కొన్ని
public cloud లు నడుపుతున్నాము,
తద్వారా మా మొత్తం నిర్వహణ వ్యయం లేదా
నిర్వహణ load మొత్తం మీద తగ్గుతుంది.
ఇప్పుడు, మొదటి dependency network.
అందువల్ల, network connectivity ఎల్లప్పుడూ వరకు అందుబాటులో
ఉండాలి.
కనుక, ఇది ఒక dependency .
securityకు సంబంధించినDataపై limited
దృశ్యమానత మరియు నియంత్రణ ఉన్నాయి.
కాబట్టి, మనంData యొక్క limited దృశ్యమానతను
కలిగి ఉన్నాము.
data  ఎక్కడ ఉందో మనకు తెలియౌ మరియు
అది ఎలాంటి securityను కలిగి ఉన్నదో తెలియదు,
కేవలం ఒక విధమైన SLA లేదా ఒక provider
 తో మనం కుదుర్చుకున్న ఒక విధమైన ఒప్పనడం
లాంటి MOU మాత్రమే ఉంటుంది.
elasticity ; అlimited resources
 లభ్యత యొక్క స్థితిస్థాపకత లేదా
భ్రాంతి problem ఉంది. కాబట్టి, మీరు public
cloud ని ఉపయోగించినప్పుడు ఇది చాలా బాగా ఉపయోగకరంగా
ఉంటుంది, ఎందుకంటే సిద్దాంత పరంగా మనకు
మరింత computing శక్తి అవసరమైతే elasticity
 ని విడుదల చెయ్యొచ్చు.
ఆ విషయాలు సాధ్యమయ్యేవి.
అందువల్ల, theoretically అనంతమైన scaling
app , scaling down కు అవకాశం
ఉంది.
cloud లోకి మైగ్rate  అయ్యేటప్పుడు
తక్కువ app-ఫ్రంట్  cost  ఉంటుంది.
ఇది మరొక ముఖ్యమైన విషయం.
కాబట్టి, మీరు మీ సొంత private cloud ని నిర్మించాలనుకుంటే, మీరు resources ని
purchase చేసి వాటిని provision  కు
ఉంచాలి, Softwareను install చేయడం
మొదలైనవి అన్నీ ఉంటాయి; here maintenance
problemలను ఎదుర్కోవాలి.
క్కడ చాలా తక్కువ app ఫ్రంట్ ఖర్చు
ఉంటుంది , మీరు చెల్లించి దాన్ని ఉపయోగించుకోండి.
నియంత్రిత డిfault SLA లు ఉంటాయి, కాబట్టి
ఏదో ఒక resource  ని purchase
చేసినప్పుడు అది ప్రామాణికమైనదా
లేదా అని నిర్ధారించేందుకు, provider మరియు
consumerల మధ్య నిర్ధిష్ట service
level agreements  ఉంటాయి.
కాబట్టి, చాలా సందర్భాలలో ప్రత్యేకమైన నిబంధనలను
అనుసరించాల్సిన అవసరం ఉంది, వాటిలో
కొన్ని provider  ఏది ప్రొవైడ్
 చేస్తున్నారు, large scale deployమెంట్
 అనగా ప్రత్యేక రేటుతో, ప్రత్యేకమైన
SLA తో చర్చలు జరిపి తీసుకుంటామో.
కానీ సాధారణంగా ఒక చిన్న institution మరియు
ప్రజలకు ఏది అందించబడుతుందో అది మేము ధృవీకరించాల్సిన
అవసరం ఉంది.
మరొక అంశం private cloud .
మీరు మీ సొంత cloud  ని కలిగి ఉంటారు
మరియు దానిపై పనిచేసే అన్నీ resources
 ని కలిగి ఉంటాము.
కనుక, cloud infrastructure  అనేది ఒకే
institutionకు limitedమై ఉంటుంది.
ఆ institutionకు సంభందించిన అనేక consumerలు
లేదా వ్యాపార విభాగాలు వాటి ప్రత్యేక ఉపయోగం
కోసం దీన్ని వినియోగిస్తారు.
IIT KGP private cloud  resources
 ని, IIT  విభాగాలు, section  లు మొదలైన
వాటిలో అన్నింటిని కేటాయిస్తుంది.
దీని నిర్వహణ అనేది స్వయంగా ఉండచ్చు
లేదా institution ajamanyaంది కావచ్చు లేదా here
మూడవ party management resources 
ని outsource చేయవచ్చు, కానీ ఇది
మీ పరిధిలో, మీ network నియంత్రణలో మరియు
మీ premisesలో ఉంటుంది.
ఇది premises లోపల లేదా బయట కూడా ఉండవచ్చు.
ఇది సాధారణంగా, premisesలో ఉంటాయి లేదా private
సమూహాలు గా ఉంటాయి లేదా private cloud
ని outsource చెయ్యొచ్చు.
here నేను office premisesలోనే ఉన్నాను,
అయితే అది అధికార పరిధి లేదా నా పాలసీ
నియమ నిబంధనలను లేదా institution నియమాలను నిర్వహిస్తుంది.
కనుక, కొన్ని open source మరియు
ఇతర public cloud లో ఒకటి ప్రజాదరణ
పొందిన eucalyptus , open stack, ubuntu enterprise cloud, amazon
VPC - virtual private cloud,
VMware cloud infrastructureస్ suite, microsoft
ECIData centers మొదలైనవి.
private cloud లో అనేక విషయాలు
ఉన్నాయి.
ప్రముఖ నమ్మకానికి విరుద్ధంగా, private
cloud premisesలో ఉండకుండా, మూడవ పక్షం
ద్వారా నిర్వహించబడవచ్చు.
బాధ్యత తీసుకోవడమే కాకుండా, ప్రధానంగా
మొత్తం మీద నియంత్రణను కొనసాగించాలని కోరుకుంటున్నాను,
కానీ నేను ప్రాధమికంగా ఆవరణలో ఉన్నాను లేదా
నేను ఒక మూడవ పక్షం సహాయంతో కూడా ఒక
ప్రత్యేకమైన resources  ని install
చేసుకోవచ్చు.
అందువలన, రెండు private cloud scenarios
 ఉన్నాయి.
అందులో ఒకటి on site private cloud
, ఇది వాస్తవంగా ఉంది లేదా customer
premisesలో అమలు చేయబడిన private
cloud లకు వర్తిస్తుంది, ఇది privateగా ఉన్న
దాని గురించి మాట్లాడుతున్నప్పుడు మనకు గుర్తుకు వస్తుంది.
customer  premisesలో లో private cloud
 ను implement  చేస్తుంది.
మరొకటి out sourced private cloud
, ఇది private అయినా premises
దాటి Outsource చేస్తుంది.
అందువల్ల, private cloudకు వర్తిస్తుంది,
అక్కడ server side  ను
hosting company కి outsource
చేయబడుతుంది.
on site private cloud
విషయంలో, security అనేది రెండింటి subscriberస్
on site resources మరియు private
cloud resources రెండింటినీ
విస్తరించి ఉంటుంది.
security లేదా మీ చట్టపరమైన నియంత్రణ ప్రాథమికంగా
private cloud ని కలిగి ఉంటుంది.
security perimeter private cloud
resources పై నియంత్రణకు
haami (Not an English word but included for context) ఇవ్వదు, కానీ subscriberస్
ఇతర వనరులపై నియంత్రణను కలిగి ఉంటారు.
అదే on site అయితే, అక్కడ ఏ private
cloud ఉన్నా, దాని యొక్క మొత్తం
resources పై మనం మొత్తం నియంత్రణను
కలిగి ఉంటాము.
కొన్ని అంశాలు client యొక్కon site private
cloud ని నిర్వహించడంలో కొన్ని
అనుకూల లక్షణాలను మరియు ప్రతికూల లక్షణాలు
కలిగి ఉంటాయి, వీటిలో ఒకటి network dependency on site private.
ఇది మీ internet network
పై ఆధారపడి ఉంటుంది.
ఒక institution దాని సొంత cloud నిర్వహించడానికి
లేదా institution సొంత cloud నిర్వహించడానికి
subscriber కి IT నైపుణ్యం అవసరం.
కాబట్టి, దానిని నిర్వహించడానికి
ఒక విధమైన నైపుణ్యం ఉండాలి.
work load  స్థావరాలు client కు తెలియవు.
వివిధ client  లు వేర్వేరు సబ్
unit  లో ఉన్నప్పటికి, work load  స్థావరాలు
client కు తెలియవు.
premisesలో లేదా on site private
cloud లో ఉన్నకూడా, నిజానికి
cloud నుండి inఫ్రాసృక్టురే  ని దాచి పెడుతుంది,
ఎక్కడైతే ఆ institution client  గా లేదా
institution client మరో వైపు ఉంటాయి.
multi-tenancy నుంచి వచ్చే ప్రమాదం
మరో అంశం . ఇంకొక సమయData దిగుమతి egumati
మరియు పనితీరు limitedులు.
hereData దిగుమతి egumati సంభందించిన
problemలు ఉంటాయి ఎందుకంటే చాలాDataను పెరుగుతూ,
తగ్గుతూ ఉంటుంది.
కనుక, on site private cloud network సామర్థ్యం వలన on డిమాండ్
 data  దిగుమతి egumati limitedంగా
ఉంటుంది మరియు real time లేదా complex
processing ఈ networking 
లోపల వలన problemాత్మకంగా మారవచ్చు.
external threat ల నుండి బలమైన security,
ఇది మన network సరిహద్దులోని ఒక
private cloud  అయితే మన network
యొక్క అన్ని ఇతర features వస్తాయి.
మన ముందు lectureలో కొన్నింటిని ప్రస్తావించినట్లుగా,
IIT, Kharagpur దాని పరిశోధన ప్రయోజనం
కోసం ఒక private cloud ని development
చేసింది, దాని payరు Meghamala, అది ఆ network
పరిధిలోనే ఉంది. కాబట్టి, IIT, Kharagpur
కు ఏయే network security limitedులు
లేదా లక్షణాలు ఉన్నాయో , అవన్నీ కూడా ఈ infrastructure
కు వర్తించబడుతుంది.
అందువల్ల, ఇది powerful బలమైన security లక్షణాలను
కలిగి ఉంటుంది.
cloud లోకి మైగ్rate  అవ్వటానికి అధిక
app ఫ్రంట్ cost అవుతుంది.
ఇది మరొక problem.
మన దగ్గర ఒక private cloud ఉన్నట్లైతే.
దానిని install చేసి నిర్వహించడానికి
మరియు private cloud లోకి మైగ్rate
అవ్వడానికి significant ఖర్చు అవుతుంది.
ఇందులో, limited resources  ఉంటాయి, కనుక
కొన్ని times మనం purchase చేయవలసిన
అవసరం రావచ్చు, అది ఇప్పటికే ఉన్న విషయాలతో
సరిగా అనుసంధానం కావాలి.
కొన్ని times, scalable resourceలు
ఉన్నప్పుడు ఈ resources  ఆవసరం పెరగడం,
reduce జరగవచ్చు.
ఏ నిర్దిష్ట సమయం లో అయినా on site
private cloud లో ఊహించిన
work load  మరియు ఖర్చు అనుగుణంగా,
ఒక స్థిర computing మరియు storage 
సామర్ధ్యం కలిగి ఉంటుంది.
మనం ఒక private cloud ని install
చెయ్యాలనుకున్న, storage , computing,
మొదలైనవాటిని అంచనా వేయాలి.
తర్వాత ఒక సదుపాయం, ఒక partnership దీన్ని
x amount purchase చేసి , 1.5 total install
చేస్తే , దాని యొక్క limitedి 1.5x అవుతుంది.
ఇది నేను privateగా ఉపయోగిస్తున్న వాటిలో
ఇంకొక వైవిధ్యమైనది here చర్చిస్తాము,
కానీ నేను దానిని outsource
చేస్తాను, అనగా నిర్వహణ, management మొదలైనవి,
నా objective, institution protection తీసుకోదు
అని కాదు, కానీ అది outsource
చేస్తుంది, కాబట్టి source  లేకుండా
outsource చెయ్యడం.
outsource private cloud
రెండు security limitedులను కలిగి ఉంటుంది,అందులో
ఒకటి cloud లో ఉన్న subscriberఅమలు
చేసేది ,మరియు provider చే అమలు చేయబడేది.
కాబట్టి, ఇది ఒక perimeter.
here ఏమి జరుగుతుందంటే ఒక విధమైన ఛానల్,
ఇతర premisesలో outsource చేయబడిన private
cloudకి లేదా కొన్ని cloud Service
provider యొక్క ఉపసమితి
కి కలుపుతుంది.
కాబట్టి, వీటన్నిటిని కలపడానికి నేను ఒక
ఛానల్ కలిగి ఉంటాను, కానీ చివరికి మొత్తం
private గా ఉంటుంది.
కాబట్టి, outsource private cloud లో నిర్వహించేData మరియు processing
యొక్క security, security limitedుల మరియు సురక్షిత
Communication యొక్క బలం మరియు
లభ్యత పై ఆధారపడి ఉంటుంది.
కాబట్టి, external విషయాల్లో మన infrastructure
 భద్రపరచబడాలని కోరుతున్నాము, మన
కమ్యూనికేట్  అయ్యే ఛానల్ లేదా
network connection లింక్ ఒక
నిర్ధిష్ట స్థాయి వరకు securityను పాటిస్తూ
సురక్షితమై ఉండాలి.
out sourced private cloud 
ఉపయోగించుకోవడంలో ఉన్న ప్రయోజనాలు
మరియు appరయోజనాలు చూద్దాం.
అందులో ఒకటి network dependency  అనగా మనం ముందు చర్చించుకున్నట్లుగా
అన్నీ ఎలా connect చేయబడ్డాయి అనే దాని
పై ఆధారపడటం.
workload స్థానాలను clientకు తెలియకుండా
ఉంచడం లాంటి problemలు.
multi tenancy  problemలు అనగా,
మనం మన private cloud ని ఎక్కడ
hosting చేస్తున్నామో, అక్కడ ఇతర వ్యక్తులు
కూడా private cloud ని host చేయవచ్చు.
data దిగుమతి, egumati మరియు పనితీరు limitedి
అదే problemలు ఉన్నాయి.
external threatస్  నుండి బలమైన
security అవసరం.
ఎందువలన అనగా ఇప్పటికీ మన వ్యక్తిగత విషయాలు
ఉన్నాయి, ఇది completely public కాదు
మరియు అందరూ వ్యక్తులు మన cloud లోకి
రాలేరు, అయితే మీరు బహుశా infrastructure
ని పంచుకోవడం మరింత తక్కువ స్థాయిలో
ఉంటుంది.
కానీ ఉన్నత స్థాయిలో మీరు ఎవరికీ విషయాలు
పంచడానికి లేదు.
cloud లో కి మైగ్rate  అవ్వడానికి Tierలు
మధ్యరకం నుంచి గరిష్టంగా ఉంటాయి ఇవ్వన్ని
కూడా ముందుగా చెప్పుకున్నవే.
మరియు ఎక్కువ సంTier్భాలలో , మనకు ఈ cloud అందించే
provider  లేదా మూడవ party అందించే
provider తో SLA పరంగా చర్చలు అవసరం.
విస్తృతమైన resource లభ్యత బహుశా ఒక ప్రయోజనం,
ఎందుకంటే ఇది limitedం కాదు. నేను ఒక అవకాశాన్ని
తీసుకుంటాను, సాధ్యమైనంత resource లభ్యత
ను పెంచడానికి అభ్యర్థిస్తాను.
provider resource  లేకుండా ఉండరు,
సాధారణంగా వారి దగ్గర resourceలు
ఉంటాయి.
కాబట్టి, ఒక వైపు private cloud
 మరో వైపు public cloud  ఉన్నాయి,
ఇవే కాకుండా మరొక సాధారణ cloud
community cloud ఉంది. కాబట్టి,
మనం ముందుగా చర్చించుకున్నట్లుగా ప్రధానంగా ఇది ఒక
ప్రత్యేక community కి services
ని అందిస్తుంది.
ఇది సాధారణంగా ఒక public మరియు private
రెండింటిలో పనిచేయగలదు మరియు ఇది ప్రాథమికంగా
ఒక ప్రత్యేకమైన ప్రత్యేక community కి
services ని అందిస్తుంది.
ఏదైతే దాని operation కి ఒకే domain లేదా
ఒకే లక్ష్యం కలిగిన interoperating
ఉంటుందో దానికి.
అందువల్ల cloud infrastructure
ని, institution యొక్క ప్రత్యేకమైన community యొక్క
ప్రత్యేకమైన ఉపయోగం కోసం ఉద్దేశించబడ్డాయి,
అంటే వాటికి సంబంధించిన విషయాలు, ఆ community
 యొక్క mission , security అవసరాలు,
పాలసీ సమ్మతి పరిశీలన, మొదలైనవి ఉండవచ్చు,
దీనిని ఆ community లో ఉన్న ఒకటి లేదా
అంతకంటే ఎక్కువ institutionలు నిర్వహించవచ్చు.
కాబట్టి, థర్డ్ party  లేదా వారి Hybridizationతో
అది premisesలో ఉండి ఉండవచ్చు లేదా బయట
ఉండవచ్చు.
అందువల్ల అది premises లోపల లేదా premises
భయట ఉండవచ్చు, అనేక community cloud లు వేర్వేరు service provider
ద్వారా అందించబడుతున్నాయి.
here A, B, C అనే institutionలు మరియు అనేక X, Y, Z institutionలు
ఉన్నాయి.
వాటిని ABC, XYZ వంటి విభిన్న Hybridizationలను ఏర్పరచగలవు
అది ఒక community కావచ్చు; X, Y తో ఏ కలిసి
మరొక community గా ఈవిధంగా వేర్వేరు
community  లు గా ఏర్పడవచ్చు.
అన్నిటిని కలిసి తీసుకురావడానికి
అవకాశం ఉంది. ఒక community కొంత సమయం వరకు ఉండవచ్చు
లేదా ఇతర సమయాలలో ఇది ఉనికిలో ఉండకపోవచ్చు,
రోజువారీ జీవితం లో ఒక institution కు ఒకటి
కంటే ఎక్కువ community  లు ఉండవచ్చు.
మనం మన office లో ఒక భాగమే కావచ్చు.
దానితో పాటు నివాస community  లో
కూడా భాగంగా ఉంటాము.
కాబట్టి, విభిన్న విధానాలు ఉండవచ్చు
మరియు ఇతర విషయాలు కూడా ఉన్నాయి, కానీ
ప్రధాన objective ఏమిటంటే, ఒకే రకమైన
సంబంధిత లేదా work flow  ఉంటుంది.
ఒకే రకమైన వాటిని ఒకే community 
లో తయారుచేయడానికి మరియు ఉత్పాదకతకు
ఈ సంఘం సహాయపడుతుంది.
here మరలా దీని లక్షణాలు ,లాభాలు
మరియు నష్టాలు మొదైలన వాటి గురించి తెలుసుకుందాం.
భాగస్వామ్య institutionలు సరిహద్దు నియంత్రికల
మధ్య ఒక అనుసంధానముతో కలుపబడి ఉంటాయి,
మరియు firewall విధానాలు లేదా సరిహద్దు
విధానాల వంటి వాటి security పారామితుల
ద్వారా access  ను అనుమతించును.
community cloud యొక్క access 
విధానం సంcomplexగా ఉండవచ్చు ఎందుకంటే
ఇందులో ఎక్కువ community  లు ఉంటాయి.
అందువల్ల, access  చేయలేని data
 ను ఏ విధానం లో access  చేస్తున్నాం,
ఎదైనా community  సమాచారాన్ని
మరొక community  కి పంపడం, లాంటివి
limitedం చేయాలి.
వీటికి role  ఆధారిత access నియంత్రణ,
లక్షణం ఆధారిత access నియంత్రణ వంటి విధాన
వివరణ పద్ధతులు ఉన్నాయి; నా role  ఆధారంగా
నేను కొంతDataను access చేస్తున్నాను.
మరియు విస్తరణ modelల యొక్క ఇతర రూపం వలె,
here కూడా మేము network dependency ని కలిగి ఉన్నాము.
subscriber  కి ఇప్పటికీ కొన్ని
IT నైపుణ్యాలు అవసరం ఎందుకంటే, ఇది వివిధ
community విషయాలు నిర్వహించడానికి
అవసరం.
workload స్థానాలు client నుండి
మళ్లీ దాచబడతాయి.
data దిగుమతి egumati మరియు performance
limitedులు, community  ల మధ్య, community
 లోపల ఎక్కువ subscriber 
లు ఉనప్పుడు data  కు సంభందించిన
problemలు ఉన్నాయి.
చాలా సంధార్భాలలో community 
లు చాలా loosely coupled గా ఉంటాయ, తద్వారా
బలమైన securityను నిర్వహించడం, మరింత complexగా
మారుతుంది, ఎందుకంటే మీరు ఇప్పటికీ ఒక
community లో ఉన్నారు, తద్వారా
మీ community విధానాల ఆధారంగా
మరియు మీ సొంత విధానంతో external threatస్ కు మంచి ప్రతిఘటన ఉంటుంది.
cloud కు మైగ్rate  అవ్వడానికి అయ్యే
అధిక స్థిరత్వం లేని app-ఫ్రంట్ ఖర్చులు,
నిజమైన private cloud విషయంలో
మనము చూసినట్లుగా, cloud కు మైగ్rate
 అవ్వడానికి అధిక app-ఫ్రంట్ ఖర్చులు
ఉంటాయి, ఎందుకంటే ఇది public  గా
లభించదు.
కాబట్టి, వీటిని మనం create 
చేసుకోవాలి.
విభిన్న విధానాలు, అంటే కొన్ని institutionలు
కలసి అక్కడ కొన్ని సరిహద్దు నియంత్రికతో
ఏర్పరుస్తాయి.
ఇది private subscriber  మరియు దాని
అంశాలతో కూడుకుని ఉంటుంది.
community cloud అనేది on ప్రిమేసిస్లో లేదా off-premisesలో అయినా ఉంటుంది.
అనగా, ఒక private cloud విషయంలో
మనం చూసినట్లుగా community cloud కూడా outsource చెయ్యవచ్చు.
కాబట్టి, ఒకసారి మేము network dependencyని outsource చేస్తే, work
స్థానాలు clients  కి తెలియదు.
multi-tenancy,Data దిగుమతి
egumati మరియు performance  limitedి problemల
నుండి వచ్చే అపాయం, ఇది మనం చెప్పిన
విధంగా external threatస్ 
ల నుండి powerful security ఉంటుంది.
మోడrate-నుంచి-అధిక app ఫ్రంట్ వ్యయం,
ఒక సొంస్థ లో outsource చేస్తే చాలా load
లు తీసుకుంటుంది.
కాబట్టి, మొత్తం loading మనం in
premise కొనసాగితే, మొత్తం ఖర్చు తక్కువగా
ఉంటుంది.
మరియు theoretically, మీరు outsourcing చేస్తే విస్తృతమైన resource లభ్యత
సాధ్యమే.
మనం theoretically చూసినా లేదా ఆచరణాత్మకంగా
చూసినా నేను ఆ cloud అనేది అన్నిటి Hybridization.
మనం private, public, community
cloud లను కలిగి ఉంటాము.
ప్రత్యేకంగా private cloud , public
cloud  లా కాకుండా ఇది ఒకటి కంటే ఎక్కువ
రకాలైన modelల Hybridizationతో ఉంటుంది.
cloud infrastructure అనేది రెండు విభిన్న
cloud infrastructure  private,
community లేదా public cloud
 ల యొక్క Hybridization.
కాబట్టి, here మూడు రకాలైన అంశాలు ఉన్నాయి,
మరియు ఈ మూడు అంశాల Hybridizationతో ఉన్న cloud
ని ఉపయోగించాలనుకుంటున్నాం.
ఎందుకు, ఇది ముఖ్యం అంటే, అంటే మొదటిది
ఏ విధమైన model ఉపయోగిస్తున్నాం అనేదానిపై ఆధారపడి
ఉంటుంది.
మన దగ్గర ఉన్న కొన్ని consumerల modelలు,
ఏవైతే private గా చెయ్యాలనుకుంటున్నామో
అవి security threatస్ కి మరింత
complexగా లేదా ప్రమాదకరమైనవిగా
ఉంటాయి.
నేను తగిన network సరిహద్దు లేదా network
చుట్టుకొలత securityను కలిగి ఉండాలని అనుకోవడం
లేదు. here కొన్ని resource లో
కొన్ని చాలా secure కావని నేను కోరుకోకపోవచ్చు
లేదా అన్ని విషయాలలోని అన్ని security గురించి
నేను పట్టించుకోను మరియు కొన్నిటిని
public గా తయారు చేయవచ్చు.
విద్యార్థులకు computing labs కోసం
practice sessions ఉంటాయి, అందువల్ల
security స్థాయి విద్యార్థి రికార్డులు లేదా
విద్యార్థుల పరీక్షా విషయాలు మొదలైనవాటిని
ఉంచినప్పుడికంటే చాలా తక్కువగా ఉంటుంది.
కాబట్టి, అదే రకమైన కార్యకలాపాలను కలిగి
ఉండవచ్చు, కానీ కొన్నింటిని మాత్రం బయట కలిగి
ఉంటాను మరియు దానిని outsource
చేయడం మరియు public cloud కి పంపవచ్చు.
మరియు మరొకొన్నింటిని ఆర్థికంగా ఉన్నప్పటికీ,
నా వ్యక్తిగత విషయాలను నేను private
గా ఉంచాలని అనుకుంటున్నాను.
ఇప్పుడు, నేను ఒక private Hybridizationలు
కలిగిన cloud ని తీసుకుంటాను.
సందర్భానుసారంగా, కొన్ని times మీరు
private గా ఏదో ఒకటి చేస్తారనేది
జరుగుతుంది, మరియు మీరు కొన్ని రిసోర్సెస్
ఆకస్మిక పెరుగుదల కారణంగా ఏర్పాటు
చేయవలసి ఉంటుంది.
appపుడు అకస్మాత్తుగా private cloud లో resource provisioning లేదా purchase
చేయడం మొదలైనవి sudeergh ప్రక్రియ.
కనుక, మీరు ఒక స్వల్ప కాలానికి ఒక public
cloud లో resourceని purchase చేయవచ్చు.
అందువల్ల, infrastructure community  ఏకైక institutionలను అలాగే ఉంచుతుంది.
కానీData మరియు applicationలు
portable అయ్యేలా చేసే ప్రామాణిక లేదా
ajamanya సాంకేతికతతో కలిసి సరిహద్దులుగా
ఉంటాయి, ఇది ముఖ్యమైనది.
కాబట్టి, portability అనేదిData కు
మాత్రమే సంబంధించింది కాదు, నేను ఈ private,
public, community అన్ని కలిసి, రెండు
లేదా అంతకంటే ఎక్కువ Hybridizationను కలిగి ఉన్నపుడు,
intra operative అనే ఇతర అంశం
ఉంటుంది, మరో చోటు నుంచి మనము application
తీసుకున్నప్పుడు data అనేది బాగా
పని చేస్తుంది.
data మరియు కొన్నిtimes applicationలు రెండు
కూడా, మన application ఒక private cloud పై నడుస్తున్నది అనుకుందాం, ఇప్పుడు
మీరు ప్రధానంగా public domain కు వెళ్ళే
ఒక VM ను ప్రొవైడ్ చెయ్యొచ్చు.
ఇప్పుడు, కొన్ని రకాల application
లను, అనగా ఏ appప్లికటిన్కి size ను మార్చలో
లేదా ఆ application  యొక్క portability
కి సంభందించిన problemలు పరిశీలించవలసి వుంటుంది.
కాబట్టి, కొన్ని hybrid cloud ఉదాహరణలు, ప్రముఖ windows azure  hybrid cloud, VMware V cloud
యొక్క సామర్ధ్యం కలిగిన కొన్ని ఉన్నాయి;
మరియు ఈ రకమైన విషయాలను అందించే అనేక ఇతర
providerలు ఉన్నాయి.
కాబట్టి, hybrid cloud రెండు
లేదా అంతకన్నా ఎక్కువ private, public
ల Hybridizationతో కూడి ఉంటుంది, అవి hybrid
ను నిర్మించటానికి ఎంపిక చేయబడిన cloud
యొక్క రకాన్ని బట్టి Performance, reliability,
securityలో significant వైవిధ్యాలు ఉన్నాయి.
ఇది ఒక community cloud లేదా
public మొదలైనవి అయి ఉంటే దాని security
లక్షణాలు, వేర్వేరు performance
లో తేడా ఉంటుంది.
కాబట్టి, hybrid cloud చాలా
complexది, ఇది ప్రధానమైన వాటిలో
ఒకటి. మీ ప్రత్యేక application
జరుగుతుందని అనుకుందాం మరియు public
మరియు private cloud Hybridizationపై అమలు
కావాల్సి వస్తే, appపుడు మొత్తం నిర్మాణాత్మక
architecture  చాలా complexదిగా
ఉండవచ్చు, అందువల్ల మీ application
సజావుగా నడుస్తుంది.
కాబట్టి, కొన్నిtimes ఈ private cloud లు చాలా సంcomplexగా ఉంటాయి.
కాలక్రమేణా ఈ cloud లు అన్నీ కలిపి
ఒక hybrid cloud గా మారవచ్చు.
మీ స్వంత private cloud ని మరియు
మరో రెండు public cloudతో ఒక
hybrid cloud ని నిర్మించగలం.
ఇప్పుడు నిబంధనలు మరియు షరతుల ముగింపుల
ఆధారంగా public cloud  ని డిస్connect
చెయ్యొచ్చు, మీ public cloud  నుంచి
మారవచ్చు, వారు మళ్లీ membership పొందాలని
కోరుకోరు మరియు వారు వేరే Tier model
ను కలిగి ఉంటారు, కాబట్టి, ఆ సందర్భంలో,
అక్కడ చేరడం, వదిలివేయడం మరియు క్రొత్త విషయాలను
చేర్చుకోవడం లేదా కొన్నిtimes మీకు
మరింత resources  కు అవసరం కావచ్చు.
కాబట్టి, మీరు మరిన్ని public లేదా
community cloud లను చేర్చుతారు.
ఇది అంతా నిర్వహించ్డం అంటే చాలా సంcomplex
విషయం, అంటే, కాలక్రమేణా, అందులో ఉన్న cloudస్
వెళ్లిపోవచ్చు లేదా చేరవచ్చు మరియు మొత్తం
ప్రక్రియ సంcomplexగా తయారవుతుంది.
కాబట్టి ఇప్పుడు నేను ఏది ఎంచుకోవాలి?
నా deployమెంట్ model ఏమిటి
అనేది పెద్ద ప్రశ్న.
ఇది మీ అవసరం మీద completely ఆధారపడి
ఉంటుంది.
మనది చిన్న institutionను లేదా వ్యక్తులకు,
public cloud మంచి పరిష్కారంగా
ఉంటుంది.
కనుక, మన business ఎక్కువ కాలం appఫ్రంట్
 Tierను భరించలేక , ఒక సొంత private
cloud వెళ్ళడానికి ప్రోత్సహిస్తుంది.
here ఇతర constants , ఇంకొకరికి business
 చెయ్యడం, నేను కొన్ని ఇతర subscriber
 బేస్ లేదా client బేస్ కలిగి ఉండటం, ఇప్పుడు ఈ client, ఒక
storage  provider,Data storage provider కొరకు చూస్తూ ఉంటుంది.
ఇప్పుడు, నేను నా premisesలో ఈ అన్ని
storage లను కలిగి ఉండవచ్చు లేదా
నేను ఈ resources ను outsource
చేస్తాను లేదా ఇతర public cloud  ల నుండి ఈ resources ను అందిస్తారు.
ఇప్పుడు, ఇలా జరిగేది ఎందుకంటే clientస్
 mission complex వారు, అయినా clientస్
అనేవి ఆర్థిక రంగం లేదా రక్షణ రంగం
అయితే , appపుడు ఏమీ జరగదు, here అన్నీ
సొంత విషయంగా ఉండాలి.
కనుక, ఇవి అన్ని మనం చూసే మార్గం పై ఆధారపడి
ఉంటుంది.
నేను hybrid గురించి మాట్లాడినందున, నా
అవసరానికి అనుగుణంగా, private, public
మొదలైన వాటి Hybridizationను కలిగి ఉంటాను.
లేదా నా application  వేర్వేరుగా
, dataను వేర్వేరు వర్గాలుగా వర్గీకరించవచ్చు,
మరియు appపుడు నేను ఈ వర్గాన్ని private
 కు వెళ్లగలనని చెప్తాను, ఈ సమూహం
public కు వెళ్లవచ్చు, ఈ community 
ని community cloud కి వెళ్లవచ్చు.
కాబట్టి, అన్నింటిని నిర్వహించడం లేదా
institution లేదా institution కోసం నిర్వహించడానికి
మరొక పెద్ద సవాలు.
కాబట్టి, మేము ఈ lectureను ముగిస్తున్నాము.
తరువాతి చర్చలలో cloud computing యొక్క ఇతర అంశాలపై మా lecture కొనసాగుతుంది.
ధన్యవాదాలు.
లో మా తదుపరి lectureకు స్వాగతం.
మేము త్వరగా Virtualization  గురించి తెలుసుకుందాం.
మేము ఇప్పటికే మన మునుపటి ఉపన్యాసాలలో
ఈ అంశాలను కొన్ని చర్చించారు.
here కోర్  అంశాల పై మరికొన్ని Slideలు
వున్నాయి, అది ప్రధాన భావనలలో ఒకటి. అందువల్ల,
ఈ cloud computing యొక్క Virtualization
అనేది ప్రధాన అంశాలలో ఒకటి. ఇది cloud
computing ఉన్నప్పటి నుంచే
, Virtualization  ఉంది. కనుక
ఇది కొత్త విషయం కాదు. మనలో చాలామంది
Virtualization  ఉపయోగిస్తున్నారు.
LINUX సిస్టం మీద, ఒక విండో Systemపై మనం Virtualization  చేస్తాము.
కాబట్టి, నేను ఒక విధమైన virtual
రియలైజేషన్ కలిగి ఉన్నాను.
మరో వైపు చూస్తే, networking,
మొదలైనటువంటి వివిధ ఇతర రెsource 
లను ఉపయోగిస్తారు.
కాబట్టి, మనము బాగా ప్రసిద్ది చెందిన
virtual LAN లేదా VLAN ను కలిగి ఉంటాము,
అనగా virtual private network మొదలగునవి కలిగి ఉంటాము.
వర్చ్యులైజేషన్ ఉంది. మరియు ఈ cloud
computing నిర్మాణ సాంకేతికత,
cloud యొక్క వివిధ service
లు అందించడం కోసం ఈ లక్షణాన్ని ఉపయోగిస్తుంది.
కాబట్టి, దీనిని IaaS లేదా infrastructure
as ఆ service  గా చూసాము.
subscriber  దృష్టిలో, subscriber
 ఏమి పొందుతాడు.
అంటే, వర్చ్యువల్ computerలు, network access, వర్చ్యువల్ storage, firewall, network infrastructure
లో ఒక భాగం అయిన ఫైర్ వాల్  కాన్ఫిగరేషన్
 services , మొదలైనవి.
నేను ఒక subscriber  గా , virtual
మెషీన్  లేదా machine  సమితిని
access  చేయగలను.
ఆపై, నేను నిర్దిష్ట storage  మరియు
ఇతర  తో ప్రత్యేక machine కోరుతాను.
కానీ aది ఎక్కడ ఉందో, ఎలా కాన్ఫిగర్ 
అయ్యిందో తెలియదు.
కానీ నాకు ఈ ప్రత్యేకమైన interface ద్వారా
ఉండే; machine ల రకం. మన దగ్గర ప్రత్యేకమైన
network తో పాటు virtual మెషీన్
 Hybridizationను కలిగి ఉండడం సాధ్యమే, మరియు
మన ప్రయోజనం కోసం, ఒక నెట్ work
ను అవస్థాపన చేయడం కూడా సాధ్యమే.
కాబట్టి, ఇదే subscriber మన దగ్గర నుంచి తీసుకుని
మరియు ఎలా చెల్లించాలి, ఎలా ఉపయోగించాలి
అనేది చూస్తాం.
ప్రధానంగా , సాధారణంగా, CPU గంటకు, storage
dataకి GB, ఒక గంట ఆధారంగా చెల్లించవచ్చు.
ఒక నిర్దిష్ట rate లో వినియోగించిన
network బ్యాండ్విడ్త్, network infrastructure
 ఉపయోగించబడుతుంది.
ఎంత IP అడ్రెస్, అనగా ఏ రౌటెర్స్ మొదలైనవి
మరియు విలువ ఆధారిత services.
అనగా, ఆటోమేటిక్ scaling
పర్యవేక్షన మొదలైనవి విలువ ఆధారిత serviceలు.
providerలు theoretically వర్చ్యువల్
missionల సమితిని కలిగి ఉంటారు; అంటే,
నేను ఒక cloud Service provider ని, నా వద్ద ఈ రకమైన వర్చ్యువల్
missionలు లు ఉన్నాయి.
మీరు వర్చ్యువల్ mission యొక్క
సమితి కావాలనుకుంటే, appపుడు నేను దానిని
provision చేస్తాను.
సాధారణంగా ఇవి వివిధ రకాలు గా ఉంటాయి.
theoretically, నేను ఏ వర్చ్యువల్ mission కాన్ఫిగర్  చెయ్యగలిగినా, కానీ
ఆచరణాత్మక అర్ధంలో ఇది నిర్దిష్ట కాన్ఫిగర్
 మొదలైనవి కలిగి ఉంటుంది.
ఐ.ఐ.టి Kharagpur, మెగామాలా విషయంలో మాదిరిగా
చాలా తక్కువ సామర్ధ్యం ఉన్న VM కలిగి ఉంది.
here 3 రకాల వర్చ్యువల్ missionలు ఉన్నాయి,
వాటిలో ఒకటి IIT KGP VM లు, ఇది 4 GB RAM, 20 GB హార్డ్
డిస్క్ స్payస్ మరియు ఇతర processing
మొదలైనవి కలిగి ఉంది. రెండవది IIT KGP large,
ఇది ఇప్పటివరకు ఒక 8GB RAM కలిగి ఉంది. చివరిది
IIT KGP ఎక్స్ట్రా large , ఇది 60 GB RAM ను
కలిగి ఉంది; ఇప్పుడు, resource  లభ్యత
ఆధారంగా, వివిధ రకాల VM ల Hybridization మాత్రమే
కాక, ఏ VM కావాలనే అభ్యర్థన రకం మీద కూడా ఆధారపడి
ఉంటుంది.
స్మాల్  VM కు భారీ రెక్వెస్ట్ లను
కలిగి ఉన్నట్లయితే, హైయర్  VM కంటే ఆ
స్మాల్  VM ను కేటాయించాలని అనుకుంటాము.
ఈ పరిగణనలు ఉంటాయి.
కాబట్టి, ఈ సందర్భంలో client A కు
VM1 నుంచి VM2 కు access ఉంది. అయితే, B కు VM3
కు access ఉంది, here client C
VM4 నుంచి VM6 కు access ఉంటుంది.
providerలు ఇతర consumerలకు
VM7 నుంచి VMn వరకు అందిస్తారు.
కాబట్టి, అది ఒక modelగా ఉండవచ్చు మరియు ఆ
పనిని కొనసాగించవచ్చు మరియు ఇవి సాధారణంగా
అలాంటివి చేయబడతాయి.
మీరు IaaS కాంపొనెంట్ stack మరియు
నియంత్రణ పరిధిని చూస్తే.
IaaS యొక్క భాగాలు hardware, ఆపరేటింగ్ System, మిడిల్వేర్ మరియు application
లేయర్ లను కలిగి ఉంటాయి.
కనుక, ఇది విలక్షణమైన విషయం.
ఆపరేటింగ్ సిస్టం, 2 పొరలుగా నిర్మిచబడినది,
మొదటిది లోపలి ప్రివిలేజ్ లేయర్ .
కాబట్టి, ఆపరేటింగ్ System యొక్క
ఎక్కువ కోడ్ ను చూస్తే virtual
మెషీన్ మానిటర్  లేదా VMM చే ఆక్రమించబడతాయి,
దీనిని హైపర్విజర్  అని కూడా పిలుస్తారు.
గెస్ట్ ఆపరేటింగ్ సిస్టం
అని పిలువబడే VM లో నడుస్తున్న ఆపరేటింగ్
సిస్టం అధిక పొరను ఆక్రమించింది.
కాబట్టి, మేము ఈ సందర్భంలో మాదిరిగానే ఉన్నామని
చూసినట్లుగా, మధ్యలో మనం చూసినట్లైతే,
బేర్ మెటల్ hardware ఉంటుంది, ఇందులో
cloud providerలు మొత్తం నియంత్రణను
కలిగి ఉంటారు; ఆచరణాత్మకంగా, cloud subscriber కు తక్కువ నియంత్రణ ఉంది. దీని పై, మనం
ఒక హైపర్విజర్ లేదా VMM లేదా వర్చ్యువల్
mission మానిటర్ ను కలిగి ఉంటుంది.
cloud provider లేదా cloud subscriber యొక్క నిర్వాహక నియంత్రణ , ఒక VM మొదలైన
వాటి కోసం ప్రధానంగా ఈ హైపర్విజర్ 
కు రెక్వెస్ట్  పంపవచ్చు.
ఆపై Guest OS, మిడిల్వేర్, java మొదలైనటువంటి
ఇతర పొరలు ఉంటాయి, మెయిల్, CRM మరియు
ఇతర రకాలు వంటి application లు ఉంటాయి, ఒక Iaas విషయంలో
cloud subscriber మొత్తం నియంత్రణను
కలిగి ఉంటారు.
provider కు ఏ నియంత్రణ ఉండదు
లేదా provider దేనిని నియంత్రించదు.
కనుక, here ఈ విధంగా జఅరుగుతుంది.
కాబట్టి, మనము చూస్తే బయటి పొరలలో నియంత్రణ
రకం cloud subscriber లకు తరలించబడుతుంది
మరియు లోపలి పొరలలో నియంత్రణ రకం provider
వైపుకు తరలించబడతాయి.
IaaS cloud  లో, provider కు ఫిజికల్ hardware పై పూర్తి నియంత్రణ, మరియు హైపర్విజర్
 పొర మీద అడ్మిస్ట్రేటివ్ నియంత్రణ ఉంటుంది.
subscriber , గెస్ట్ OS, మిడిల్వేర్
మరియు application లేయర్ లను
నియంత్రిస్తుంది.
ఇవి subscriber  పై ఉంటాయి.
subscriber  అనునది ఏ సహాయ ఆపరేటింగ్
System load చేయుటకు provider
యొక్క utility నుండి ఉచితముగా ఉపయోగించును.
అందువల్ల, provider మద్దతునిచ్చినట్లయితే,
subscriber , గెస్ట్  OS ను load
చేయవచ్చు.
subscriber  సాధారణంగా ప్రతి
VM లో గెస్ట్ ఆపరేటింగ్ System
యొక్క operation పై పూర్తి నియంత్రణను
నిర్వహిస్తుంది.
కాబట్టి, subscriber  దీన్ని load
అయినప్పుడే అది గెస్ట్ OS పై మొత్తం నియంత్రణను
కలిగి ఉంటుంది, అనగా cloud provider నాకు కొంత లైనక్సు OS మరియు హైపర్విజర్
అందించినప్పుడు, నాకు లైనక్స్
లేదా windows, మొదలైనవాటిని load
చేయడానికి అనుమతిస్తుంది.
కాబట్టి, నేను లైనక్స్ యొక్క కొన్ని రకాలను
load చేస్తే, దాని పై నాకు పూర్తి నియంత్రణ
ఉంటుంది.
IaaS కాంపొనెంట్ stack మరియు ఇతర విషయం,
హైపర్విజర్  ఒకటి లేదా మరిన్ని
వర్చ్యువల్ missionలు  లేదా VM ల సంశ్లేషణకు
హార్డువేరు  లను ఉపయోగిస్తుంది.
ప్రతి VM ఒక సమర్థవంతమైన ఐసోలేటెడ్ డూప్లికేట్
real మెషీన్, subscriber ,
VM access ని రెంట్  కి తీసుకుంటుంది
,ఈ VM subscriber  కి నిర్వహించే
వాస్తవ computer hardware
గా కనిపిస్తుంది, ఇది ఆఫ్ on చేయబడుతుంది,
network ద్వారా పంpay కమాండ్స్
ద్వారా పెరిఫెరల్స్ కాన్ఫిగర్  చేస్తుంది,
ఎందుకంటే subscriber  గా provider
తో interface అయ్యి కమ్యూనికేట్
అవుతుంది.
మీరు ఒక సాధారణ architecture  ని చూస్తేప.
పైన ఉన్న అనేక భాగాలలో cloud మేనేజర్ ఒకటి. విభిన్న cluster మేనేజర్లు ఉన్నారు, ఇవి రెండో స్థాయిలో ఉన్న
విషయాలు మరియు దానికి దిగువన computer
మేనేజర్ లేదా CM ఉంటుంది.
ఇందులో CM ప్రధానంగా హైపర్విజర్స్
మరియు విభిన్న రకాలైన virtual మెషీన్
 అంశాలను కలిగి ఉంది. మనము cloud
మేనేజర్ మరియుData ఆబ్జెక్ట్ storage ను కలిగి ఉన్నాము, అనగా ఇది విషయాలను
పర్యవేక్షించే ముస్టర్Data బేస్.
ఇప్పుడు లోయర్ స్థాయి వద్ద వంటి పెర్సిస్టెంట్
లోకల్ storageని కలిగి ఉంటుంది;
అనగా, cloud provider లేనప్పుడు కూడా storage
 అలానే ఉంటుంది.
ఎప్పుడంటే VM లు ఉపయోగించబడకపోయినా లేదా షట్down
అయినప్పుడు.
ఆ 3 స్థాయిల హైరార్కీ లను చూస్తే, 1.
tap level, దీనికి cloud మేనేజర్
లాంటి సెంట్రల్ కంట్role  బాధ్యత ఉంటుంది.
2
మిడిల్ level,ఇది బహుశా పెద్ద
computer cluster యొక్క నిర్వహణకు
బాధ్యత వహిస్తుంది మరియు భౌgoళికంగా
ఒక దాని నుండి మరొక దానికి దూరం ఉంటుంది.
కాబట్టి, మీరు ఈ cluster మేనేజర్ ని
చూస్తే, ఈ భారీ cluster లను నిర్వహిస్తుంది,
ఇది భౌgoళికంగా వ్యాప్తి చెందుతుంది మరియు
మూడవది వర్చ్యువల్ mission లను
సృష్టించే host computing
system నడుపుటకు బాధ్యత వహిస్తుంది.
కాబట్టి, ఈ host computing
system నడుపుతున్నారు, here VM లు సృష్టించబడతాయి.
ఇది సాధారణంగా 3 లేయర్ ల నియంత్రణ, subscriberసాధారణంగా
వ్యాఖ్యానిస్తుంది.
క్వెరీస్  కి onసర్ ఇచ్చేటపుడు
tap నుంచి down కి పొరల ద్వారా ముందుకు
పంపబడతాయి.
IaaS cloud architecture లో cloud మేనేజర్ భౌgoళికంగా పంపిణీ చేయవచ్చు.
cluster మేనేజర్ లోపల, computer
మేనేజర్ అధిక వేగ network ద్వారా
అనుసంధానించబడి ఉంటుంది.
cluster నిర్వాహకుడిని చూస్తే, ఇవన్నీ అధిక
వేగ network ద్వారా connect
చేయబడతాయి.
ఇప్పుడు మీరు cloud మేనేజర్  operation
చూస్తే; tap  లో cloud మేనేజర్, తర్వాత cluster మేనేజర్, ఆ
తర్వాత వ్యక్తిగత విషయాలు నిర్వహించే
computer మేనేజర్  ఉంటాయి.
మీరు cloud మేనేజర్ విధి చూస్తే, ఇది
cloud యొక్క public access
పాయింట్.
కాబట్టి, ఎవరైనా cloud  ను public
లో access చేసినప్పుడు, subscriber,
అక్కౌంట్ ని నిర్వహించడానికి, cloud నుండి
రెంట్ కు తీసుకున్న resources  ని
నిర్వహించదానికి సైన్  చేస్తారు.
cloud మేనేజర్ subscriber
ని అతెంticket  కొరకు కొన్ని పద్దతులు
ఉంటాయి.మొదటిది అతెంticket  విధానాలు, VM
లతో కమ్యూనికేట్  అయ్యేటపుడు
subscriber ఉపయోగించే access
క్రెడెన్షియల్ ను రూపొందించడం
లేదా ధృవీకరించడం రెండవది.
ప్రధానంగా మొత్తం వ్యవస్థ యొక్క ఫ్రంటెండ్
అయినప్పుడు, మూడవది, ఉన్నత స్థాయి resources
నిర్వహణ.
subscriber అభ్యర్థన కోసం cloud
మేనేజర్, cloudలో తగినంత ఉచిత resources
ని గుర్తింస్తుంది.
కాబట్టి, cloud మేనేజర్ మెటాdata సమాచారాన్ని నిర్వహిస్తుంది.
కాబట్టి, ఒక నిర్దిష్ట VM లేదా cloud
లో అందుబాటులో లేని VM ల సెట్  కోసం నేను
అభ్యర్థిస్తే, cloud మేనేజర్కి
call చేయాల్సి వస్తుంది.
కనుక, అది subscriber ల చేత నిర్వహించబడుతుంది.
data ఆబ్జెక్ట్ storage లేదా DOS అని
పిలువబడే ఒక విషయం ఉంది. యూజర్ క్రెడిట్
ఆపరేటింగ్ సిస్టం మొదలైన
వాటి గురించి మాట్లాడుతున్నందున DOS సాధారణంగా చందాదారుల
మెటాdataను నిల్వ చేస్తుంది.
సాధారణంగా DOS service  cloud  కి
ఒకటే ఉంటుంది.
కాబట్టి, నిర్దిష్ట DOS service  అనేది
ఒక నిర్దిష్ట cloud కోసం అని చెబుతున్నాం.
కాబట్టి, ఇది మన మొత్తం రిజిస్ట్రీ లేదా
cloud జాబితా లేదా ఒక మెటాdata service ని నిర్వహిస్తుంది.
అందువల్ల, మొత్తం విషయం యొక్కByండింగ్
బ్లాక్, ఉచిత resources  అందుబాటులో
ఉన్నయా లేదా మొదలైన వాటిని అన్నింటిని
appడేడ్  చేయడం.
ఈ మిడిల్ లవేల్  cluster మేనేజర్ని చూస్తే.
హై స్పీడ్ లోకల్ ఏరియా network ద్వారా అనుసంధానించబడిన computerలు
సేకరణకు ఇది బాధ్యత వహిస్తుంది.
కాబట్టి, ఇది లో level  computerలను
నిర్వహిస్తుంది, cluster మేనేజర్ ఎగువన ఉన్న cloud మేనేజర్ నుండి
resource కేటాయింపు ఆదేశాలు మరియు ప్రశ్నలను
పొందుతుంది.
cluster  లోని computerల
యొక్క resources ను ఉపయోగించి కమాండ్ను
యొక్క పార్ట్  లేదా మొత్తాన్ని
సంతృప్తిపరచవచ్చో లెక్కిస్తుంది.
అనగా, cluster మేనేజర్ కి రెక్వెస్ట్
 అందినప్పుడు, cluster లో రెsourceవుందో,
లేదో తనిఖీ చేస్తుంది; ఇది విషయాలను సంతృప్తి
చేయగలదా మరియు అనుగుణంగా అది విషయాలకు తగిన
సిగ్నల్ను చెబుతుంది.
అలాగైతే, అది ఆమోదించవచ్చు లేదా ఆమోదించకపోవచ్చు
మొదలైనవి వుంటాయి.
cluster మేనేజర్ రెsource లభ్యతను
గుర్తించడానికి clusterలోని
computerల కోసం computer మేనేజర్ ని ప్రశ్నిస్తాడు, cloud మేనేజర్ కి సందేశాలను పంపుతాడు.
అనగా, అది computer మేనేజర్, cluster
మేనేజర్ మరియు cloud మేనేజర్ కి మధ్య మిడిల్ వేర్ లేదా ఏజెంట్
గా పనిచేస్తుంది.
మీరు operationను చూస్తే, అక్కడ cloud
మేనేజర్ కోసం దిశను నిర్దేశిస్తుంది.
మరియు ఆపై రెsource కేటాయింపు, రీ కాన్ఫిగరేషన్
, రెsource డి అల్లోకేషన్
మరియు ఇతర విషయాలను నిర్వహించడానికి
computer మేనేజర్ల ను నిర్దేశిస్తుంది.
cluster మేనేజర్ నిరంతర స్థానిక
storage కు అనుసంధానిస్తారు; cluster మేనేజర్ పెర్సిస్టంట్ storageకి
అనుసంధానించబడి ఉంటుంది.
అనగా ఇది కోట్ లేదా uncoated నోన్ వొలటైల్
storage.
నిర్దిష్ట వర్చ్యువల్ mission, షట్down అయినప్పుడు, లేమి లేదా కొన్ని problemలు
వస్తాయి.
సో, అది విషయాలు లోకి స్థానిక నిల్వ కలిగి.
కాబట్టి, ఈ PLS వర్చ్యువల్ mission కి storage
 వంటి పెర్సిస్టంట్  డిస్కును
అందిస్తుంది.
కాబట్టి, అదే నిరంతర డిస్క్ ఉన్నట్లయితే.
కాబట్టి, మీరు తర్వాతి సమయం లాగిన్  చేసినప్పుడు
data అందుబాటులో ఉంటుంది.
మేము cloud మేనేజర్ operation
చూస్తే.
సోపానక్రమంలో అత్యల్ప స్థాయిలో, ప్రతి
computer Systemలో రన్ అయ్యే cloud
మేనేజర్, subscriber కి virtual
machine అందించడానికి, Virtualization
 ని ఉపయోగిస్తుంది.
కాబట్టి, cloud మేనేజర్ ప్రాథమికంగా
VM లను అందిస్తుంది.
ఇది బాధ్యత వహించే VM లను అందించే subscriber
కి, computer మేనేజర్ ఎన్ని
వర్చ్యువల్ missionలు నడుపుతున్నారో
లాంటి స్థితి సమాచారాన్ని మొదలైనవి నిర్వహిస్తుంది.
కాబట్టి, అది ఎన్ని విర్జిషియల్ మెషీన్లు నడుపుతున్నాయనేదాని స్థితి సమాచారమును
నిర్వహిస్తుంది.
దీని తో పాటు cloud మేనేజర్ వర్చ్యువల్
missionల ను ప్రారంభించడానికి,
సస్పెండ్ మరియు పునఃనిర్మించటానికి
హైపర్విజర్ కు కమాండ్ interface
ను ఉపయోగిస్తుంది.
computer మేనేజర్ అవసరం ఉంటే అది
కూడా ఒకటే. hereంత మనం చూసేది, Virtualization
 యొక్క ముఖ్యమైన పాత్ర.
ఎలా ఈ Virtualization  తయారుచేస్తాం
మరియు దాని అంశాలు మొదలైనవి: వీటన్నిటి
గురించి తదుపరి Slideలలో త్వరగా చూడటానికి
ప్రయత్నిస్తాం.
కాబట్టి, వర్చ్యులైజేషన్  ఒక విస్తృత
పదం, ఇది ఒక వర్చ్యువల్ మెమొరీ కావచ్చు,
వర్చ్యువల్ network కావచ్చు, వర్చ్యువల్
storage, మొదలైనవి కావచ్చు.
దేన్నైనా మనం Virtualize  చేయగలిగితే
దాన్ని వర్చ్యులైజేషన్  అంశం అంటాం.
మా ప్రాధమికంగా వర్చ్యులైజేషన్  వేదిక కోసం
దృష్టి పెడుతున్నాం.
వర్చ్యులైజేషన్ ప్రాథమికంగా, ఒక
computer, ఒకే hardware 
resource  లను ఎక్కువ ఎన్విరాన్మెంట్
 లో పంచి, బహుళ computerల
యొక్క పనిని చేయడానికి అనుమతిస్తుంది.
కాబట్టి, ఇది ముఖ్యమైనది; దీని అర్ధం, నాకు
ఒక బేర్ మెటల్ ఉంది, నేను విభిన్న
machine లను లేదా వర్చ్యువల్ missionలను సృష్టించగలము.
కానీ బాక్ ఎండ్ లో, అదే బేర్ మెటల్ రన్ అవుతుంది.
ఇప్పుడు ఇది చాలా గమ్మత్తైనది.
మీరు ప్రత్యేక ఎన్విరాన్మెంట్  లో, మీ బేర్
మెటల్ ను కలిగి ఉన్నాం అనుకుందాం
మరియు మీరు Windows లో ఒక machine  రన్
 చేస్తున్నాం, Linux లో ఒక mission Guest
OS, లేదా ఇతర విషయాలు మొదలైనవి ఉపయోగించవచ్చు.
ఈ గెస్ట్ OS యొక్క ఇంస్ట్రక్షన్ సెట్
, hardwareలోఎలా అమలవుతుందనే problem
ఉంది. కాబట్టి, ఆ problemలనేవి ఉన్నాయి, application
 సిజింగ్  సమయాలు ఉన్నాయి.
VM కు ఎక్కువ resources  అవసరం అయినప్పుడు
లేదా ఇతర resources  ని విడుదల చేసినపుడు,
ఎలా నిర్వహించాలో మరియు అలా ఎలా కొనసాగించాలో
వాటికి సంబంధించి కొన్ని problemలు ఉన్నాయి.
కాబట్టి, మనము హార్డువేర్ చూద్దాం.
కాబట్టి, ఇది ఒక వర్చ్యులైజేషన్ లేకపోతే, ఒకే OS అన్ని
హార్డువేరు resource  లను నియంత్రిస్తుంది.
ఇది ఒక వర్చ్యులైజేషన్ ఒకే ఫిజికల్ platform
 పై బహుళ వర్చ్యువల్ కంటైనర్లను
నడపడం సాధ్యపడుతుంది.
కాబట్టి, మనము బహుళ virtual కంటైనర్లను కలిగి ఉంటాము, అవి ఒకే ఫిజికల్
platform  పై అమలు చేయవచ్చు
లేదా ప్లగ్ చేయబడతాయి.
ఈ వర్చ్యులైజేషన్తో మనకు కొంతవరకు అనుభవము
ఉంది. అందువల్ల, వర్చ్యులైజేషన్ ఒకే హార్డువేరు
నందు బహుళ ఆపరేటింగ్ System లను
మరియు యూజర్ application నడుపుటకు ఒక
మార్గం.
కాబట్టి, ఇది Virtualize  చేయబడుతుంది
. కాబట్టి, నేను ఒకేసారి machine పై 2 విభిన్న
ఆపరేటింగ్ Systemను కలిగి ఉండగలను.
అనగా, దీనిలో ఒక OS ని Virtualize
చేస్తాను, కాబట్టి, windows మరియు
లైనక్స్ రెండింటినీ ఇంకొక వైపు అమలు
చేస్తాము.
డబుల్ బూట్ కోసం ఇది ఎలా విభిన్నంగా
ఉంటుంది?
ఒకసారి windows లో చేయడం మొదలైనవి.
here Virtualization విషయంలో, ఈ వేర్వేరు
OS లేదా అన్ని OSలు ఒకేసారి లేదా ఒకే సమయంలో
కలిసి రన్ అవుతాయి.
OS లు ఒక దాని నుండి మరొకటి completely
వేరుచేయబడతాయి.
నిజమైన Virtualization  విషయంలో ఒకదానితో
ఒకటి completely వేరుచేయబడతాయి.
ఇందులోకి మరో ముఖ్యమైన అంశం వర్చ్యువల్
mission మానిటర్ లేదా హైపర్విజర్.
కాబట్టి, ఒక హైపర్విజర్ లేదా virtual
మెషీన్ మానిటర్, గెస్ట్ OSను CPU పై నేరుగా నడుపుతుంది.
అందువల్ల నేను ఒక అతిథి OS ను కలిగి
ఉన్నాను మరియు దానిని నా అక్కౌంట్ లో
చోటు చేసుకున్న లేదా subscriber 
ద్వారా ఇంస్టాల్  చేయబడుతుంది
లేదా అమలు చేయబడుతుంది లేదా client యొక్క
application లో ఉంటుంది.
ఆపై హైపర్విజర్, దీన్ని అమలు చేయడానికి
లేదా ఈ గెస్ట్ OS ను నేరుగా hardwareలో,
బాక్ ఎండ్ లో అమలు చేయబడుతుంది.
కాబట్టి, Guest OS, host OS ఒకే ఇంస్ట్రక్షన్
సెట్ ఉపయోగిస్తే పనిచేస్తుంది.
ఇది విభిన్న ఇంస్ట్రక్షన్ సెట్ ఉంటే,
appపుడు ఒక ఇంస్ట్రక్షన్ ట్రాన్స్లేషన్  ఉపయోగిస్తాము.
పోప్ కె మరియు goల్డ్బెర్గ్
వర్ణించిన అనేక problemలు ఉన్నాయి.
వర్చ్యువల్ mission architecture యొక్క 3 goల్స్ ఉన్నాయి: 1.
ఇక్వివలెన్స్ , అంతర్లీన hardware
నుండి VM లను వేరు చేయరాదు.
కనుక, వర్చ్యువల్ mission, హార్డువేరు
మీద నడుస్తుంటే.
దానిని మనము ఇక్వివలెన్స్  అంటాము.2, రెsource
కొంట్role , VM కి Virtualizeడ్
రెsource  పై అసంపూర్తి నియంత్రణ
ఉండాలి.
కాబట్టి, మీరు నాకు 4 GB machine, 30 GB లేదా
60 GB Hard Disk ఇస్తే, subscriber
గా వాటి పై పూర్తి నియంత్రణ ఉంటుంది.
మరియు 3.
ఎఫిషియెన్సీ , అధిక VM ఇంస్ట్రక్షన్లు
హైపర్విజర్తో సంబంధం లేకుండా అంతర్లీన
CPU పైన నేరుగా అమలు చేయాలి.
కాబట్టి, అది మరొక విషయం.
virtual మెషీన్ బోధన యొక్క అధికభాగం,
ఈ ఇతర ప్రమేయం హైపర్విజర్ యొక్క జోక్యం లేకుండా
నేరుగా CPU పై అమలు చేయగలగడం వలన సామర్థ్యం
పెరుగుతుంది.
అందువల్ల, మనము VM లను అనుకరించటానికి
అనుమతించే ప్రదేశంలో వర్చ్యువల్ mission
మానిటర్ లేదా హైపర్విజర్
వున్నప్పుడు, వీటిని పరిశీలించవలసిన
అంశాలు.
అదే work లో ఈ పొపెక్ మరియు
goల్డ్బెర్గ్ ను వివరించారు మరియు
ఈ లక్షణాలను జరిగేలా అనుమతించే CPU ల ఇంస్ట్రక్షన్ల
యొక్క అవసరాన్ని అందించిన ఒక అధికారిక
రుజువుని కూడా ఇస్తారు.
నిజంగా Virtualization IaaS స్థాయిలో జరిగేలా
చేయాలంటే, ప్రధానంగా , ఈ ఇంస్ట్రక్షన్
3 విభిన్న విషయాలగా వర్గీకరిస్తుంది.
అందులో ఒకటి ప్రివిలైజ్ద ఇంస్ట్రక్షన్ ,
ఇది యూసర్ మోడ్ లో ఎక్జిక్యూట్
 చేసినప్పుడు, ట్రాప్  జరగవచ్చు.
here సెన్సిటివ్ inస్ట్రక్షన్ ఉంది, ఇది అంతర్లీన రెsource ను
మారుస్తుంది, అది IO చేస్తోంది లేదా
గెస్ట్  OS, బార్  లో నడపబడుతున్న
వాస్తవాన్ని మారుస్తుంది; మొదటిది IO లేదా payజ్
టేబుల్స్ లను మార్చడం లేదా ప్రస్తుత
అధికార స్థాయిపై సమాచార సూచనలను గమనించడం.
మీరు మీ ప్రాథమిక architecture 
అంశాలను గుర్థిన్చినట్లైతే.
మనము వివిధ స్థాయి లో operation 
ను కలిగి ఉన్నాము, అవి level 0,level
 1 మొదలైన వేర్వేరు స్థాయి కార్యకలాపాలు.
మరింత తక్కువ level  వెళ్ళేకొద్ది,
బేర్ మెటల్కి మరింత దగ్గరగా వెళ్తాము.
ఇది అన్నిటిని నిర్వహించే Virtualization
పై ఆధారపడి ఉంటుంది.
మరింత పై level  వెళ్ళేకొద్ది
మరింత లాటెన్సి  వస్తుంది, మరియు
మరింత అనువాదం అవసరం అవుతుంది.
కాబట్టి, మనము ఏ level  operation లు
చేయాలనే విషయాన్ని పరిశీలిద్దాం; ప్రత్యేకంగా
మనము IaaS సంభందిత operation  లు చేస్తున్నప్పుడు.
సెన్సిటివ్  ఇంస్ట్రక్షన్
ల యొక్క మొదటి క్లాస్  ని కంట్role సెన్సిటివ్
 అని మరియు తర్వాతి క్లాస్ 
ని బెహెవీర్ సెన్సిటివ్ 
అని అంటాము.
Popek మరియు goల్డ్బెర్గ్ ఏమి చెబుతుందంటే,
ఈ 3 ఉపయోగపడే ప్రాపర్టీస్ ల తో Virtual machine
 రన్ చేస్తే సెన్సిటివ్ ఇంస్ట్రక్షన్
లు , ప్రివిలైజ్ద ఇంస్ట్రక్షన్ 
లకు సుబ్సెట్  గా ఉంటాయి.
వారి పనిలో వీటన్నిటిని చూపిస్థాయి, ఈ రకమైన
విషయాలు నిజమైనవి మరియు నిజమైన Virtual
machine  ని గుర్తించగలము.
ఇదే విషయం లేదా మనం చర్చించే ఏవైనా.
ఈ virtual machine మానిటర్ల పై ఈ VM లు మరియు ఈ హార్డువేరు
రన్ అవుతుంటాయి.
మరియు ఈ వేర్వేరు VM లను అనుకరించటానికి
ఇది అనుమతిస్తుంది.
కాబట్టి, ఇది మీదే కావచ్చు.
కొన్ని చోట్ల ఏదైనా గెస్ట్ OS, VM పై రన్
 అవుతుంటుంది.
కన్వర్ట్  చేయవలసిన ఇంస్ట్రక్షన్ ల
సమితి ఈ hardwareకు  అర్ధం చేసుకోగలగాలి.
కాబట్టి, అది మన బాటమ్ లైన్.
మొత్తం VMM మొత్తం అబ్స్త్రాక్సన్
 ను కలిగివుందా లేదా ఏదో ఒక విధమైన
ఒవెర్లప్పింగ్ ఉందా లేదా అనేది
దానిపై ఇంప్లిమెంటేషన్ పై ఆధారపడి ఉంటుంది.
కాబట్టి, Virtualization సాధారణ విధానాలకు
సమీపంలోని విధానాలను పరిశీలిస్తే.
మీరు ఈ Virtualization యొక్క పరిణామమును
చూసినట్లయితే, మనము మొదటిది ఫస్ట్ జెనెరేషన్ లేదా ఫుల్ Virtualization, దీనినేByనరీ
రీరైటింగ్ అంటాము.
కాబట్టి, ఇది Software ఆధారిత అంశం, VMware మరియు
microsoft దీనికి మద్దతిస్తుంది.
ఏ వర్చ్యువల్ missionలు, డైనమిక్ ట్రాన్స్లేటర్ను
 సృష్టించినా, అండర్ లైనింగ్ హార్డువేరుకు
రీరైట్ చేస్తాయి.
సెకండ్ జెనెరేషన్ లో: Virtualization
లేదా పరా వర్చురైజేషన్, కొ ఓపెరటివ్
 Virtualization.
ఇది అతిథి OS లేదా మోడిఫెడ్ గెస్ట్,VMware మరియు xen ల కొ ఓపెరటివ్  Virtualization.
కాబట్టి, మీరు here చూస్తే ప్రాథమికంగా
ఇది VM లోకి కొంచెం చొచ్చుకొచ్చింది;
అంటే, అంశాలపై సవరించబడింది.
ఒక మూడవ జనరేషన్ లేదా సిలికాన్ ఆధారిత
అంశం, hardware సహాయంతో Virtualization
వర్చ్యులైజేషన్ అవగాహన hardware
ప్లాట్ఫారమ్లో లో, on మోడిఫీడ్
గెస్ట్ , VMware మరియు xen ఉంటాయి, ఇప్పుడు
మీ hardware ప్లాట్ఫారమ్కు Virtualization
తెలుసు.
కాబట్టి, ఇది hardware asసిస్టెడ్ 
Virtualization.
ఈ సందర్భాలలో ఈ hardware ప్లాట్ఫారమ్లో లకు ఈ Virtualization గురించి తెలియదు.
ఈ మీ హైపర్విజర్ చేత ఏమి జరిగినా?
ఫుల్ Virtualization లో వివిధ అంశాలు
ఉన్నాయి, ఫస్ట్ జెనెరేషన్ ఫస్ట్ జెనెరేషన్ x86/x64 server ఫుల్ Virtualizationను అందిస్తుంది.
source కోడ్ యొక్క డైనమిక్Byనరీ
ట్రాన్స్లేషన్, మనము చూసినట్లుగా
అన్ని hardware లు CPU తో సహా ఎమ్యులేటెడ్
అయ్యి ఉంటాయి.
2 ప్రముఖ open source ఎమెల్యూటర్లు
 ఉన్నాయి, వాటిలో ఒకటి చాలామందికి
తెలిసిన QEMU మరియు రెండవది Bochs . ఇవి రెండు
open source ను మార్చే ప్రముఖ
ఎమెల్యూటర్లు .
పూర్తి Virtualization, ఎమ్యులేషన్ లేయర్
 యొక్క ప్రయోజనాలు ఉన్నాయి.
మొత్తం VM portability, నేను VM ను ఒకదాని
నుండి మరొకదానిలో ఉంచగలము.
కాబట్టి, మొత్తం portabilityని
ఉపయోగిస్తాము, ఎందుకంటే VMM మాత్రమే, మనకు అర్థం
అవుతుంది.
ఈ hardware ఎమ్యులేషన్స్ performance  Tierతో పాటు వస్తుంది.
ఇది ఇందులోని ఒక లోపం.
మీరు ట్రడిషనల్ x86 architecture
లో హార్డువేర్ performance Tierను అనుకరించాలనుకున్నప్పుడు,
OS కెర్నెల్ లు ప్రత్యేక హక్కు ప్రివిలేజ్
రింగ్0 లో రన్ అవుతుందని అనుకుంటున్నాం.
ఇప్పుడు మీరు వాటిని అధిక level  లో
అమలు చేయాలనుకుంటే, ఎక్కువ లాటెన్సి
ఉండాలి మరియు ఇతర విషయాలను కూడా పరిశీలించాలి.
కాబట్టి, మనం దాని కోసం pay  చెయ్యాల్సిన
అవసరం ఉంది లేదా performance 
Tier మనకు అవసరం.
పారా వర్చురైజేషన్ విషయంలో, గెస్ట్
OS సవరించబడింది మరియు రింగ్ 1 లేదా రింగ్
3 వద్ద కెర్నల్ level  ఆపరేటింగ్
System ను అమలు చేస్తుంది.
ఇది అధిక level  గెస్ట్ గా ఉంటుంది,
ఇది ప్రివిలేజ్ ఇంస్ట్రక్షన్  ను ఎలా ప్రాసెస్
చేయాలో తెలుసుకోగలదు.
VMM కు అనువదించబడిన ప్రివిలేజ్ 
ఇంస్ట్రక్షన్  ఇకపై అవసరం లేదు.
గెస్ట్ నిర్వహణ వ్యవస్థలు ప్రత్యేక
API ను VMM తో కమ్యూనికేట్ అవడానికి ఉపయోగిస్తాయి.
కాబట్టి, ఇది పారా; దీని అర్థం, మీ VMM,
కొన్ని రకాలైన VM లను ఉపయోగించడానికి
చొచ్చుకుపోతుంది.
కనుక, ఇప్పుడు అది పూర్తి అనువాదం కాదు,
కానీ ఒక పారా వర్చురైజేషన్ performance
 పెరుగుతుంది మరియు ఈ విషయం బాగా
ప్రజాదరణ పొందుతోంది.
పారా వర్చురైజేషన్ విషయంలో, OS
కెర్నెల్ను రి కంపైల్ చేయాల్సిన
అవసరము ఉంది, దీనిని ఉపయోగించాలంటే, పారా
Virtualizeడ్ డ్రైవర్ల
యొక్క inస్టలేషన్  అవసరం.
ఇది, గెస్ట్ OS లెవేల్ లో జాగ్రత్తలు తీసుకుంటుంది.
మూడవది, hardware asసిస్టెడ్ వర్చురైజేషన్, గెస్ట్ OS రింగ్ 0 లో రన్
 అవుతుంది.
VMM, ఇంటెల్ VT లేదా AMD V లలో ఉన్నట్లుగా
Processor ఎక్స్టెంషన్స్  లను ఉపయోగిస్తుంది
మరియు గెస్ట్  లో ఉన్న ప్రివిలైజెడ్
 operation  లను inర్సెప్ట్
 చేస్తుంది.
హార్డువేర్ సహాయంతో Virtualization
అనేది, ఒక VMM ను వ్రాసేటప్పుడు జరిగే అనేక problemలను
తొలగిస్తుంది, అది ఒక పెద్ద సవాలు.
ఇది hardware అసిస్టెంట్; అనగా, మీరు నేరుగా
పొందగలిగితే అది completely కంపైల్
 అయి ఉంటుంది.
ఇలా చేయడం వల్ల, మీరు VM ల యొక్క పోర్టబిలిటిని
కోల్పోతారు, ఇది గమ్మత్తైన problemగా
మారుతుంది, ఎందుకంటే hardwareని
అర్థం చేసుకునే machine కి మీరు మైగ్rate
అవ్వాలి.ఉపయోగం, అది అన్మోడిఫైడ్
OS ని రన్ చేయడానికి అనుమతిస్తుంది, మీరు
OS లు మార్చల్సిన అవసరం లేదు; లోపం, స్పీడ్
 మరియు ఫ్లెక్సిబిలిటీ  ల problem ఉంది.
మైగ్రేషన్ జరిగినప్పుడు మీరు ఫ్లెక్సిబిలిటీ
 కోల్పోతారు మరియు స్పీడ్ ,
మైగ్రేషన్ పై ఆధారపడి ఉంటుంది.
మనం నెట్ work Virtualization యొక్క కొన్ని అంశాలపై
మనము చర్చించుకుందాం.
ఇప్పటి వరకు మనము హార్డువేర్ level
 లో చూసాము, ఇప్పుడు మనం network
level  లో చూద్దాం; అంటే, ఇచ్చిన networkలోని
ఒక వర్చ్యువల్ నెట్ work పై నెట్
work ను అనుకరించాల్సిన అవసరం ఉంది.
network టెక్నాలజీలో మనం చూసే విలక్షణ
విధానాలు అంటే ఐపి బేస్ లేదా ఎటిఎమ్
బేస్ లేయర్ .
వర్చ్యులైజేషన్ యొక్క ఏ లేయర్
లో ఆర్చిటెక్చురల్ domain ఉంటుంది,దీనిలో
network వనరుల ajamanyaాలు, స్పానింగ్
 networkలు ఉంటాయి, వర్చ్యులైజేషన్
level  లో,Node level  లేదా ఫుల్ వర్చ్యులైజేషన్ వంటివి ఉన్నాయి.
మనం ఈ network కలిగి ఉన్నాం అనుకుందాం.
appపుడు మనం ఇలాంటి network ను
ఎమ్యులెట్చేస్తాం, కనుక, ఇది నా బేస్
network.
మనము 2 రకాల వర్చ్యువల్ network
లను దీని పైన కలిగివున్నాము.
ఒక virtual networkను మనము ఎమ్యులెట్
చేశాము, వాస్తవంగా ఎందుకు మనము విర్చువలైజ్
 కి వెళ్ళాలి అంటే మన స్వంత networking
పారాడిగ్మ్లో internet స్తంభించడం
మాత్రమే కాకుండా, స్payస్  ఎక్కువ
ఉండదు.
ఒన్ size ఫిట్స్ అల్  architecture
 ని తీసుకుని రావడం చాలా కష్టం.
మనము network కాన్ఫిగరేషన్ ని కలిగి ఉంటాము
మరియు ప్రతిఒక్కరికీ సరిపోతుంది.
ఎందుకు మనం వివిధ సినారియో  లకు
అన్నీ create  చేయడానికి బదులుగా
అన్నిటికి సరిపోయేవిధంగా ఒకే రకం create
 చేయకూడదు.
ఇదే మనం చేయాలనుకుంటున్నాం.
కాబట్టి, భవిష్యత్ network architectureల మరియు ప్రోటోcallలు కోసం టెస్ట్ బెడ్
లు ఉన్నాయి.
కనుక, మనము ఒక విధమైన Virtualize network కలిగి ఉంటాము.
మరియు ఇది అకస్మాత్తుగా ఇందులోకి రాలేదు,
ఇది ఇప్పటికే ఒక virtual private
network , ప్రోగ్రామబుల్
network, మరియు ఓవర్లే networkలు మొదలైనవి ఇప్పటికే చాలా ఉన్నాయి.
ఇది వాటిపై ఎమ్యులేట్ చేయబడుతోంది.
మనము here చూసినట్లైతే, వివిధ అంశాలు,అనగా
business model ,business
architecture , డిజైన్ ప్రిన్సిపుల్స్ మరియు డిజైన్ goల్స్  ఉన్నాయి.
మరియు infrastructure providerస్, Service provider, ఎండ్ యుసెర్స్
, మరియు బ్రోకర్లు వంటి వివిధ అంశాలు
ఉన్నాయి.
ఇవి వేర్వేరు ప్లాయెర్స్  మరియు వారి మధ్య
చాలా complex సంబంధం ఉంటుంది.
మరియు business model , ఈ network
Virtualization కు మాత్రమే
సరిపోదు, అది Virtualization యొక్క ఇతర అంశాలకి
కూడా సరిపోతుంది .
కాబట్టి, నేను ఆ infrastructure providerని కలిగి ఉంటే, appపుడు నేను ఒక
Service provider 1 ను కలిగి ఉండి,
ఒక విధమైన Virtualize network
ను కలిగి ఉంటాను.
దీని నుండి ఎమ్యులెట్ చేసినవి, కొన్ని
networkలను ఆక్టివేట్ చెయ్యడం
మదలైనవి.
మనము ఇతర రకాలైన Service provider 2, SP2 ఇతర రకాలైన networkలులను
కూడా ఎమ్యులెట్ చేయడం, కనుక, నేను
ఒక ప్రాథమిక అంతర్లీన network లో
వివిధ రకాల network లను ఎమ్యులెట్
చేస్తుంది.
కాబట్టి, మనము వివిధ రకాల networkలులను
ఏర్పరచవచ్చు.
కాబట్టి, ఇవి చాలా ప్రజాదరణ పొందాయి.
serverలు మాత్రమే కలిగి వుండకుండా
భౌgoళిక స్payస్ అంతటా ఒక నిర్దిష్ట
పరీక్ష నిర్వహించాలని అనుకుంటాను.
కాబట్టి, నేను ఈ serverలను తీసుకురావడం మాత్రమే
కాకుండా నేను ఒక నిర్దిష్ట network
infrastructure కావాలి అనుకుంటాను.
ఇలా చెయ్యాలి అంటే appపుడు IASS స్థాయి
లేదా server స్థాయి Virtualization మాత్రమే
ఉంటే సరిపోదు, network level Virtualization కూడా కావాలి మరియు ఈ మొత్తాన్ని
నేను ఒక వాస్తవిక ఐపి infrastructure
స్థానంగా పొందగలగాలి.
కాబట్టి, మా చర్చలు మా తదుపరి ఉపన్యాసాలలో
మేము కొనసాగిస్తాము.
ధన్యవాదాలు.
లో మా తదుపరి lectureకు స్వాగతం.
మేము త్వరగా Virtualization  గురించి తెలుసుకుందాం.
మేము ఇప్పటికే మన మునుపటి ఉపన్యాసాలలో
ఈ అంశాలను కొన్ని చర్చించారు.
here కోర్  అంశాల పై మరికొన్ని Slideలు
వున్నాయి, అది ప్రధాన భావనలలో ఒకటి. అందువల్ల,
ఈ cloud computing యొక్క Virtualization
అనేది ప్రధాన అంశాలలో ఒకటి. ఇది cloud
computing ఉన్నప్పటి నుంచే
, Virtualization  ఉంది. కనుక
ఇది కొత్త విషయం కాదు. మనలో చాలామంది
Virtualization  ఉపయోగిస్తున్నారు.
LINUX సిస్టం మీద, ఒక విండో Systemపై మనం Virtualization  చేస్తాము.
కాబట్టి, నేను ఒక విధమైన virtual
రియలైజేషన్ కలిగి ఉన్నాను.
మరో వైపు చూస్తే, networking,
మొదలైనటువంటి వివిధ ఇతర రెsource 
లను ఉపయోగిస్తారు.
కాబట్టి, మనము బాగా ప్రసిద్ది చెందిన
virtual LAN లేదా VLAN ను కలిగి ఉంటాము,
అనగా virtual private network మొదలగునవి కలిగి ఉంటాము.
వర్చ్యులైజేషన్ ఉంది. మరియు ఈ cloud
computing నిర్మాణ సాంకేతికత,
cloud యొక్క వివిధ service
లు అందించడం కోసం ఈ లక్షణాన్ని ఉపయోగిస్తుంది.
కాబట్టి, దీనిని IaaS లేదా infrastructure
as ఆ service  గా చూసాము.
subscriber  దృష్టిలో, subscriber
 ఏమి పొందుతాడు.
అంటే, వర్చ్యువల్ computerలు, network access, వర్చ్యువల్ storage, firewall, network infrastructure
లో ఒక భాగం అయిన ఫైర్ వాల్  కాన్ఫిగరేషన్
 services , మొదలైనవి.
నేను ఒక subscriber  గా , virtual
మెషీన్  లేదా machine  సమితిని
access  చేయగలను.
ఆపై, నేను నిర్దిష్ట storage  మరియు
ఇతర  తో ప్రత్యేక machine కోరుతాను.
కానీ aది ఎక్కడ ఉందో, ఎలా కాన్ఫిగర్ 
అయ్యిందో తెలియదు.
కానీ నాకు ఈ ప్రత్యేకమైన interface ద్వారా
ఉండే; machine ల రకం. మన దగ్గర ప్రత్యేకమైన
network తో పాటు virtual మెషీన్
 Hybridizationను కలిగి ఉండడం సాధ్యమే, మరియు
మన ప్రయోజనం కోసం, ఒక నెట్ work
ను అవస్థాపన చేయడం కూడా సాధ్యమే.
కాబట్టి, ఇదే subscriber మన దగ్గర నుంచి తీసుకుని
మరియు ఎలా చెల్లించాలి, ఎలా ఉపయోగించాలి
అనేది చూస్తాం.
ప్రధానంగా , సాధారణంగా, CPU గంటకు, storage
dataకి GB, ఒక గంట ఆధారంగా చెల్లించవచ్చు.
ఒక నిర్దిష్ట rate లో వినియోగించిన
network బ్యాండ్విడ్త్, network infrastructure
 ఉపయోగించబడుతుంది.
ఎంత IP అడ్రెస్, అనగా ఏ రౌటెర్స్ మొదలైనవి
మరియు విలువ ఆధారిత services.
అనగా, ఆటోమేటిక్ scaling
పర్యవేక్షన మొదలైనవి విలువ ఆధారిత serviceలు.
providerలు theoretically వర్చ్యువల్
missionల సమితిని కలిగి ఉంటారు; అంటే,
నేను ఒక cloud Service provider ని, నా వద్ద ఈ రకమైన వర్చ్యువల్
missionలు లు ఉన్నాయి.
మీరు వర్చ్యువల్ mission యొక్క
సమితి కావాలనుకుంటే, appపుడు నేను దానిని
provision చేస్తాను.
సాధారణంగా ఇవి వివిధ రకాలు గా ఉంటాయి.
theoretically, నేను ఏ వర్చ్యువల్ mission కాన్ఫిగర్  చెయ్యగలిగినా, కానీ
ఆచరణాత్మక అర్ధంలో ఇది నిర్దిష్ట కాన్ఫిగర్
 మొదలైనవి కలిగి ఉంటుంది.
ఐ.ఐ.టి Kharagpur, మెగామాలా విషయంలో మాదిరిగా
చాలా తక్కువ సామర్ధ్యం ఉన్న VM కలిగి ఉంది.
here 3 రకాల వర్చ్యువల్ missionలు ఉన్నాయి,
వాటిలో ఒకటి IIT KGP VM లు, ఇది 4 GB RAM, 20 GB హార్డ్
డిస్క్ స్payస్ మరియు ఇతర processing
మొదలైనవి కలిగి ఉంది. రెండవది IIT KGP large,
ఇది ఇప్పటివరకు ఒక 8GB RAM కలిగి ఉంది. చివరిది
IIT KGP ఎక్స్ట్రా large , ఇది 60 GB RAM ను
కలిగి ఉంది; ఇప్పుడు, resource  లభ్యత
ఆధారంగా, వివిధ రకాల VM ల Hybridization మాత్రమే
కాక, ఏ VM కావాలనే అభ్యర్థన రకం మీద కూడా ఆధారపడి
ఉంటుంది.
స్మాల్  VM కు భారీ రెక్వెస్ట్ లను
కలిగి ఉన్నట్లయితే, హైయర్  VM కంటే ఆ
స్మాల్  VM ను కేటాయించాలని అనుకుంటాము.
ఈ పరిగణనలు ఉంటాయి.
కాబట్టి, ఈ సందర్భంలో client A కు
VM1 నుంచి VM2 కు access ఉంది. అయితే, B కు VM3
కు access ఉంది, here client C
VM4 నుంచి VM6 కు access ఉంటుంది.
providerలు ఇతర consumerలకు
VM7 నుంచి VMn వరకు అందిస్తారు.
కాబట్టి, అది ఒక modelగా ఉండవచ్చు మరియు ఆ
పనిని కొనసాగించవచ్చు మరియు ఇవి సాధారణంగా
అలాంటివి చేయబడతాయి.
మీరు IaaS కాంపొనెంట్ stack మరియు
నియంత్రణ పరిధిని చూస్తే.
IaaS యొక్క భాగాలు hardware, ఆపరేటింగ్ System, మిడిల్వేర్ మరియు application
లేయర్ లను కలిగి ఉంటాయి.
కనుక, ఇది విలక్షణమైన విషయం.
ఆపరేటింగ్ సిస్టం, 2 పొరలుగా నిర్మిచబడినది,
మొదటిది లోపలి ప్రివిలేజ్ లేయర్ .
కాబట్టి, ఆపరేటింగ్ System యొక్క
ఎక్కువ కోడ్ ను చూస్తే virtual
మెషీన్ మానిటర్  లేదా VMM చే ఆక్రమించబడతాయి,
దీనిని హైపర్విజర్  అని కూడా పిలుస్తారు.
గెస్ట్ ఆపరేటింగ్ సిస్టం
అని పిలువబడే VM లో నడుస్తున్న ఆపరేటింగ్
సిస్టం అధిక పొరను ఆక్రమించింది.
కాబట్టి, మేము ఈ సందర్భంలో మాదిరిగానే ఉన్నామని
చూసినట్లుగా, మధ్యలో మనం చూసినట్లైతే,
బేర్ మెటల్ hardware ఉంటుంది, ఇందులో
cloud providerలు మొత్తం నియంత్రణను
కలిగి ఉంటారు; ఆచరణాత్మకంగా, cloud subscriber కు తక్కువ నియంత్రణ ఉంది. దీని పై, మనం
ఒక హైపర్విజర్ లేదా VMM లేదా వర్చ్యువల్
mission మానిటర్ ను కలిగి ఉంటుంది.
cloud provider లేదా cloud subscriber యొక్క నిర్వాహక నియంత్రణ , ఒక VM మొదలైన
వాటి కోసం ప్రధానంగా ఈ హైపర్విజర్ 
కు రెక్వెస్ట్  పంపవచ్చు.
ఆపై Guest OS, మిడిల్వేర్, java మొదలైనటువంటి
ఇతర పొరలు ఉంటాయి, మెయిల్, CRM మరియు
ఇతర రకాలు వంటి application లు ఉంటాయి, ఒక Iaas విషయంలో
cloud subscriber మొత్తం నియంత్రణను
కలిగి ఉంటారు.
provider కు ఏ నియంత్రణ ఉండదు
లేదా provider దేనిని నియంత్రించదు.
కనుక, here ఈ విధంగా జఅరుగుతుంది.
కాబట్టి, మనము చూస్తే బయటి పొరలలో నియంత్రణ
రకం cloud subscriber లకు తరలించబడుతుంది
మరియు లోపలి పొరలలో నియంత్రణ రకం provider
వైపుకు తరలించబడతాయి.
IaaS cloud  లో, provider కు ఫిజికల్ hardware పై పూర్తి నియంత్రణ, మరియు హైపర్విజర్
 పొర మీద అడ్మిస్ట్రేటివ్ నియంత్రణ ఉంటుంది.
subscriber , గెస్ట్ OS, మిడిల్వేర్
మరియు application లేయర్ లను
నియంత్రిస్తుంది.
ఇవి subscriber  పై ఉంటాయి.
subscriber  అనునది ఏ సహాయ ఆపరేటింగ్
System load చేయుటకు provider
యొక్క utility నుండి ఉచితముగా ఉపయోగించును.
అందువల్ల, provider మద్దతునిచ్చినట్లయితే,
subscriber , గెస్ట్  OS ను load
చేయవచ్చు.
subscriber  సాధారణంగా ప్రతి
VM లో గెస్ట్ ఆపరేటింగ్ System
యొక్క operation పై పూర్తి నియంత్రణను
నిర్వహిస్తుంది.
కాబట్టి, subscriber  దీన్ని load
అయినప్పుడే అది గెస్ట్ OS పై మొత్తం నియంత్రణను
కలిగి ఉంటుంది, అనగా cloud provider నాకు కొంత లైనక్సు OS మరియు హైపర్విజర్
అందించినప్పుడు, నాకు లైనక్స్
లేదా windows, మొదలైనవాటిని load
చేయడానికి అనుమతిస్తుంది.
కాబట్టి, నేను లైనక్స్ యొక్క కొన్ని రకాలను
load చేస్తే, దాని పై నాకు పూర్తి నియంత్రణ
ఉంటుంది.
IaaS కాంపొనెంట్ stack మరియు ఇతర విషయం,
హైపర్విజర్  ఒకటి లేదా మరిన్ని
వర్చ్యువల్ missionలు  లేదా VM ల సంశ్లేషణకు
హార్డువేరు  లను ఉపయోగిస్తుంది.
ప్రతి VM ఒక సమర్థవంతమైన ఐసోలేటెడ్ డూప్లికేట్
real మెషీన్, subscriber ,
VM access ని రెంట్  కి తీసుకుంటుంది
,ఈ VM subscriber  కి నిర్వహించే
వాస్తవ computer hardware
గా కనిపిస్తుంది, ఇది ఆఫ్ on చేయబడుతుంది,
network ద్వారా పంpay కమాండ్స్
ద్వారా పెరిఫెరల్స్ కాన్ఫిగర్  చేస్తుంది,
ఎందుకంటే subscriber  గా provider
తో interface అయ్యి కమ్యూనికేట్
అవుతుంది.
మీరు ఒక సాధారణ architecture  ని చూస్తేప.
పైన ఉన్న అనేక భాగాలలో cloud మేనేజర్ ఒకటి. విభిన్న cluster మేనేజర్లు ఉన్నారు, ఇవి రెండో స్థాయిలో ఉన్న
విషయాలు మరియు దానికి దిగువన computer
మేనేజర్ లేదా CM ఉంటుంది.
ఇందులో CM ప్రధానంగా హైపర్విజర్స్
మరియు విభిన్న రకాలైన virtual మెషీన్
 అంశాలను కలిగి ఉంది. మనము cloud
మేనేజర్ మరియుData ఆబ్జెక్ట్ storage ను కలిగి ఉన్నాము, అనగా ఇది విషయాలను
పర్యవేక్షించే ముస్టర్Data బేస్.
ఇప్పుడు లోయర్ స్థాయి వద్ద వంటి పెర్సిస్టెంట్
లోకల్ storageని కలిగి ఉంటుంది;
అనగా, cloud provider లేనప్పుడు కూడా storage
 అలానే ఉంటుంది.
ఎప్పుడంటే VM లు ఉపయోగించబడకపోయినా లేదా షట్down
అయినప్పుడు.
ఆ 3 స్థాయిల హైరార్కీ లను చూస్తే, 1.
tap level, దీనికి cloud మేనేజర్
లాంటి సెంట్రల్ కంట్role  బాధ్యత ఉంటుంది.
2
మిడిల్ level,ఇది బహుశా పెద్ద
computer cluster యొక్క నిర్వహణకు
బాధ్యత వహిస్తుంది మరియు భౌgoళికంగా
ఒక దాని నుండి మరొక దానికి దూరం ఉంటుంది.
కాబట్టి, మీరు ఈ cluster మేనేజర్ ని
చూస్తే, ఈ భారీ cluster లను నిర్వహిస్తుంది,
ఇది భౌgoళికంగా వ్యాప్తి చెందుతుంది మరియు
మూడవది వర్చ్యువల్ mission లను
సృష్టించే host computing
system నడుపుటకు బాధ్యత వహిస్తుంది.
కాబట్టి, ఈ host computing
system నడుపుతున్నారు, here VM లు సృష్టించబడతాయి.
ఇది సాధారణంగా 3 లేయర్ ల నియంత్రణ, subscriberసాధారణంగా
వ్యాఖ్యానిస్తుంది.
క్వెరీస్  కి onసర్ ఇచ్చేటపుడు
tap నుంచి down కి పొరల ద్వారా ముందుకు
పంపబడతాయి.
IaaS cloud architecture లో cloud మేనేజర్ భౌgoళికంగా పంపిణీ చేయవచ్చు.
cluster మేనేజర్ లోపల, computer
మేనేజర్ అధిక వేగ network ద్వారా
అనుసంధానించబడి ఉంటుంది.
cluster నిర్వాహకుడిని చూస్తే, ఇవన్నీ అధిక
వేగ network ద్వారా connect
చేయబడతాయి.
ఇప్పుడు మీరు cloud మేనేజర్  operation
చూస్తే; tap  లో cloud మేనేజర్, తర్వాత cluster మేనేజర్, ఆ
తర్వాత వ్యక్తిగత విషయాలు నిర్వహించే
computer మేనేజర్  ఉంటాయి.
మీరు cloud మేనేజర్ విధి చూస్తే, ఇది
cloud యొక్క public access
పాయింట్.
కాబట్టి, ఎవరైనా cloud  ను public
లో access చేసినప్పుడు, subscriber,
అక్కౌంట్ ని నిర్వహించడానికి, cloud నుండి
రెంట్ కు తీసుకున్న resources  ని
నిర్వహించదానికి సైన్  చేస్తారు.
cloud మేనేజర్ subscriber
ని అతెంticket  కొరకు కొన్ని పద్దతులు
ఉంటాయి.మొదటిది అతెంticket  విధానాలు, VM
లతో కమ్యూనికేట్  అయ్యేటపుడు
subscriber ఉపయోగించే access
క్రెడెన్షియల్ ను రూపొందించడం
లేదా ధృవీకరించడం రెండవది.
ప్రధానంగా మొత్తం వ్యవస్థ యొక్క ఫ్రంటెండ్
అయినప్పుడు, మూడవది, ఉన్నత స్థాయి resources
నిర్వహణ.
subscriber అభ్యర్థన కోసం cloud
మేనేజర్, cloudలో తగినంత ఉచిత resources
ని గుర్తింస్తుంది.
కాబట్టి, cloud మేనేజర్ మెటాdata సమాచారాన్ని నిర్వహిస్తుంది.
కాబట్టి, ఒక నిర్దిష్ట VM లేదా cloud
లో అందుబాటులో లేని VM ల సెట్  కోసం నేను
అభ్యర్థిస్తే, cloud మేనేజర్కి
call చేయాల్సి వస్తుంది.
కనుక, అది subscriber ల చేత నిర్వహించబడుతుంది.
data ఆబ్జెక్ట్ storage లేదా DOS అని
పిలువబడే ఒక విషయం ఉంది. యూజర్ క్రెడిట్
ఆపరేటింగ్ సిస్టం మొదలైన
వాటి గురించి మాట్లాడుతున్నందున DOS సాధారణంగా చందాదారుల
మెటాdataను నిల్వ చేస్తుంది.
సాధారణంగా DOS service  cloud  కి
ఒకటే ఉంటుంది.
కాబట్టి, నిర్దిష్ట DOS service  అనేది
ఒక నిర్దిష్ట cloud కోసం అని చెబుతున్నాం.
కాబట్టి, ఇది మన మొత్తం రిజిస్ట్రీ లేదా
cloud జాబితా లేదా ఒక మెటాdata service ని నిర్వహిస్తుంది.
అందువల్ల, మొత్తం విషయం యొక్కByండింగ్
బ్లాక్, ఉచిత resources  అందుబాటులో
ఉన్నయా లేదా మొదలైన వాటిని అన్నింటిని
appడేడ్  చేయడం.
ఈ మిడిల్ లవేల్  cluster మేనేజర్ని చూస్తే.
హై స్పీడ్ లోకల్ ఏరియా network ద్వారా అనుసంధానించబడిన computerలు
సేకరణకు ఇది బాధ్యత వహిస్తుంది.
కాబట్టి, ఇది లో level  computerలను
నిర్వహిస్తుంది, cluster మేనేజర్ ఎగువన ఉన్న cloud మేనేజర్ నుండి
resource కేటాయింపు ఆదేశాలు మరియు ప్రశ్నలను
పొందుతుంది.
cluster  లోని computerల
యొక్క resources ను ఉపయోగించి కమాండ్ను
యొక్క పార్ట్  లేదా మొత్తాన్ని
సంతృప్తిపరచవచ్చో లెక్కిస్తుంది.
అనగా, cluster మేనేజర్ కి రెక్వెస్ట్
 అందినప్పుడు, cluster లో రెsourceవుందో,
లేదో తనిఖీ చేస్తుంది; ఇది విషయాలను సంతృప్తి
చేయగలదా మరియు అనుగుణంగా అది విషయాలకు తగిన
సిగ్నల్ను చెబుతుంది.
అలాగైతే, అది ఆమోదించవచ్చు లేదా ఆమోదించకపోవచ్చు
మొదలైనవి వుంటాయి.
cluster మేనేజర్ రెsource లభ్యతను
గుర్తించడానికి clusterలోని
computerల కోసం computer మేనేజర్ ని ప్రశ్నిస్తాడు, cloud మేనేజర్ కి సందేశాలను పంపుతాడు.
అనగా, అది computer మేనేజర్, cluster
మేనేజర్ మరియు cloud మేనేజర్ కి మధ్య మిడిల్ వేర్ లేదా ఏజెంట్
గా పనిచేస్తుంది.
మీరు operationను చూస్తే, అక్కడ cloud
మేనేజర్ కోసం దిశను నిర్దేశిస్తుంది.
మరియు ఆపై రెsource కేటాయింపు, రీ కాన్ఫిగరేషన్
, రెsource డి అల్లోకేషన్
మరియు ఇతర విషయాలను నిర్వహించడానికి
computer మేనేజర్ల ను నిర్దేశిస్తుంది.
cluster మేనేజర్ నిరంతర స్థానిక
storage కు అనుసంధానిస్తారు; cluster మేనేజర్ పెర్సిస్టంట్ storageకి
అనుసంధానించబడి ఉంటుంది.
అనగా ఇది కోట్ లేదా uncoated నోన్ వొలటైల్
storage.
నిర్దిష్ట వర్చ్యువల్ mission, షట్down అయినప్పుడు, లేమి లేదా కొన్ని problemలు
వస్తాయి.
సో, అది విషయాలు లోకి స్థానిక నిల్వ కలిగి.
కాబట్టి, ఈ PLS వర్చ్యువల్ mission కి storage
 వంటి పెర్సిస్టంట్  డిస్కును
అందిస్తుంది.
కాబట్టి, అదే నిరంతర డిస్క్ ఉన్నట్లయితే.
కాబట్టి, మీరు తర్వాతి సమయం లాగిన్  చేసినప్పుడు
data అందుబాటులో ఉంటుంది.
మేము cloud మేనేజర్ operation
చూస్తే.
సోపానక్రమంలో అత్యల్ప స్థాయిలో, ప్రతి
computer Systemలో రన్ అయ్యే cloud
మేనేజర్, subscriber కి virtual
machine అందించడానికి, Virtualization
 ని ఉపయోగిస్తుంది.
కాబట్టి, cloud మేనేజర్ ప్రాథమికంగా
VM లను అందిస్తుంది.
ఇది బాధ్యత వహించే VM లను అందించే subscriber
కి, computer మేనేజర్ ఎన్ని
వర్చ్యువల్ missionలు నడుపుతున్నారో
లాంటి స్థితి సమాచారాన్ని మొదలైనవి నిర్వహిస్తుంది.
కాబట్టి, అది ఎన్ని విర్జిషియల్ మెషీన్లు నడుపుతున్నాయనేదాని స్థితి సమాచారమును
నిర్వహిస్తుంది.
దీని తో పాటు cloud మేనేజర్ వర్చ్యువల్
missionల ను ప్రారంభించడానికి,
సస్పెండ్ మరియు పునఃనిర్మించటానికి
హైపర్విజర్ కు కమాండ్ interface
ను ఉపయోగిస్తుంది.
computer మేనేజర్ అవసరం ఉంటే అది
కూడా ఒకటే. hereంత మనం చూసేది, Virtualization
 యొక్క ముఖ్యమైన పాత్ర.
ఎలా ఈ Virtualization  తయారుచేస్తాం
మరియు దాని అంశాలు మొదలైనవి: వీటన్నిటి
గురించి తదుపరి Slideలలో త్వరగా చూడటానికి
ప్రయత్నిస్తాం.
కాబట్టి, వర్చ్యులైజేషన్  ఒక విస్తృత
పదం, ఇది ఒక వర్చ్యువల్ మెమొరీ కావచ్చు,
వర్చ్యువల్ network కావచ్చు, వర్చ్యువల్
storage, మొదలైనవి కావచ్చు.
దేన్నైనా మనం Virtualize  చేయగలిగితే
దాన్ని వర్చ్యులైజేషన్  అంశం అంటాం.
మా ప్రాధమికంగా వర్చ్యులైజేషన్  వేదిక కోసం
దృష్టి పెడుతున్నాం.
వర్చ్యులైజేషన్ ప్రాథమికంగా, ఒక
computer, ఒకే hardware 
resource  లను ఎక్కువ ఎన్విరాన్మెంట్
 లో పంచి, బహుళ computerల
యొక్క పనిని చేయడానికి అనుమతిస్తుంది.
కాబట్టి, ఇది ముఖ్యమైనది; దీని అర్ధం, నాకు
ఒక బేర్ మెటల్ ఉంది, నేను విభిన్న
machine లను లేదా వర్చ్యువల్ missionలను సృష్టించగలము.
కానీ బాక్ ఎండ్ లో, అదే బేర్ మెటల్ రన్ అవుతుంది.
ఇప్పుడు ఇది చాలా గమ్మత్తైనది.
మీరు ప్రత్యేక ఎన్విరాన్మెంట్  లో, మీ బేర్
మెటల్ ను కలిగి ఉన్నాం అనుకుందాం
మరియు మీరు Windows లో ఒక machine  రన్
 చేస్తున్నాం, Linux లో ఒక mission Guest
OS, లేదా ఇతర విషయాలు మొదలైనవి ఉపయోగించవచ్చు.
ఈ గెస్ట్ OS యొక్క ఇంస్ట్రక్షన్ సెట్
, hardwareలోఎలా అమలవుతుందనే problem
ఉంది. కాబట్టి, ఆ problemలనేవి ఉన్నాయి, application
 సిజింగ్  సమయాలు ఉన్నాయి.
VM కు ఎక్కువ resources  అవసరం అయినప్పుడు
లేదా ఇతర resources  ని విడుదల చేసినపుడు,
ఎలా నిర్వహించాలో మరియు అలా ఎలా కొనసాగించాలో
వాటికి సంబంధించి కొన్ని problemలు ఉన్నాయి.
కాబట్టి, మనము హార్డువేర్ చూద్దాం.
కాబట్టి, ఇది ఒక వర్చ్యులైజేషన్ లేకపోతే, ఒకే OS అన్ని
హార్డువేరు resource  లను నియంత్రిస్తుంది.
ఇది ఒక వర్చ్యులైజేషన్ ఒకే ఫిజికల్ platform
 పై బహుళ వర్చ్యువల్ కంటైనర్లను
నడపడం సాధ్యపడుతుంది.
కాబట్టి, మనము బహుళ virtual కంటైనర్లను కలిగి ఉంటాము, అవి ఒకే ఫిజికల్
platform  పై అమలు చేయవచ్చు
లేదా ప్లగ్ చేయబడతాయి.
ఈ వర్చ్యులైజేషన్తో మనకు కొంతవరకు అనుభవము
ఉంది. అందువల్ల, వర్చ్యులైజేషన్ ఒకే హార్డువేరు
నందు బహుళ ఆపరేటింగ్ System లను
మరియు యూజర్ application నడుపుటకు ఒక
మార్గం.
కాబట్టి, ఇది Virtualize  చేయబడుతుంది
. కాబట్టి, నేను ఒకేసారి machine పై 2 విభిన్న
ఆపరేటింగ్ Systemను కలిగి ఉండగలను.
అనగా, దీనిలో ఒక OS ని Virtualize
చేస్తాను, కాబట్టి, windows మరియు
లైనక్స్ రెండింటినీ ఇంకొక వైపు అమలు
చేస్తాము.
డబుల్ బూట్ కోసం ఇది ఎలా విభిన్నంగా
ఉంటుంది?
ఒకసారి windows లో చేయడం మొదలైనవి.
here Virtualization విషయంలో, ఈ వేర్వేరు
OS లేదా అన్ని OSలు ఒకేసారి లేదా ఒకే సమయంలో
కలిసి రన్ అవుతాయి.
OS లు ఒక దాని నుండి మరొకటి completely
వేరుచేయబడతాయి.
నిజమైన Virtualization  విషయంలో ఒకదానితో
ఒకటి completely వేరుచేయబడతాయి.
ఇందులోకి మరో ముఖ్యమైన అంశం వర్చ్యువల్
mission మానిటర్ లేదా హైపర్విజర్.
కాబట్టి, ఒక హైపర్విజర్ లేదా virtual
మెషీన్ మానిటర్, గెస్ట్ OSను CPU పై నేరుగా నడుపుతుంది.
అందువల్ల నేను ఒక అతిథి OS ను కలిగి
ఉన్నాను మరియు దానిని నా అక్కౌంట్ లో
చోటు చేసుకున్న లేదా subscriber 
ద్వారా ఇంస్టాల్  చేయబడుతుంది
లేదా అమలు చేయబడుతుంది లేదా client యొక్క
application లో ఉంటుంది.
ఆపై హైపర్విజర్, దీన్ని అమలు చేయడానికి
లేదా ఈ గెస్ట్ OS ను నేరుగా hardwareలో,
బాక్ ఎండ్ లో అమలు చేయబడుతుంది.
కాబట్టి, Guest OS, host OS ఒకే ఇంస్ట్రక్షన్
సెట్ ఉపయోగిస్తే పనిచేస్తుంది.
ఇది విభిన్న ఇంస్ట్రక్షన్ సెట్ ఉంటే,
appపుడు ఒక ఇంస్ట్రక్షన్ ట్రాన్స్లేషన్  ఉపయోగిస్తాము.
పోప్ కె మరియు goల్డ్బెర్గ్
వర్ణించిన అనేక problemలు ఉన్నాయి.
వర్చ్యువల్ mission architecture యొక్క 3 goల్స్ ఉన్నాయి: 1.
ఇక్వివలెన్స్ , అంతర్లీన hardware
నుండి VM లను వేరు చేయరాదు.
కనుక, వర్చ్యువల్ mission, హార్డువేరు
మీద నడుస్తుంటే.
దానిని మనము ఇక్వివలెన్స్  అంటాము.2, రెsource
కొంట్role , VM కి Virtualizeడ్
రెsource  పై అసంపూర్తి నియంత్రణ
ఉండాలి.
కాబట్టి, మీరు నాకు 4 GB machine, 30 GB లేదా
60 GB Hard Disk ఇస్తే, subscriber
గా వాటి పై పూర్తి నియంత్రణ ఉంటుంది.
మరియు 3.
ఎఫిషియెన్సీ , అధిక VM ఇంస్ట్రక్షన్లు
హైపర్విజర్తో సంబంధం లేకుండా అంతర్లీన
CPU పైన నేరుగా అమలు చేయాలి.
కాబట్టి, అది మరొక విషయం.
virtual మెషీన్ బోధన యొక్క అధికభాగం,
ఈ ఇతర ప్రమేయం హైపర్విజర్ యొక్క జోక్యం లేకుండా
నేరుగా CPU పై అమలు చేయగలగడం వలన సామర్థ్యం
పెరుగుతుంది.
అందువల్ల, మనము VM లను అనుకరించటానికి
అనుమతించే ప్రదేశంలో వర్చ్యువల్ mission
మానిటర్ లేదా హైపర్విజర్
వున్నప్పుడు, వీటిని పరిశీలించవలసిన
అంశాలు.
అదే work లో ఈ పొపెక్ మరియు
goల్డ్బెర్గ్ ను వివరించారు మరియు
ఈ లక్షణాలను జరిగేలా అనుమతించే CPU ల ఇంస్ట్రక్షన్ల
యొక్క అవసరాన్ని అందించిన ఒక అధికారిక
రుజువుని కూడా ఇస్తారు.
నిజంగా Virtualization IaaS స్థాయిలో జరిగేలా
చేయాలంటే, ప్రధానంగా , ఈ ఇంస్ట్రక్షన్
3 విభిన్న విషయాలగా వర్గీకరిస్తుంది.
అందులో ఒకటి ప్రివిలైజ్ద ఇంస్ట్రక్షన్ ,
ఇది యూసర్ మోడ్ లో ఎక్జిక్యూట్
 చేసినప్పుడు, ట్రాప్  జరగవచ్చు.
here సెన్సిటివ్ inస్ట్రక్షన్ ఉంది, ఇది అంతర్లీన రెsource ను
మారుస్తుంది, అది IO చేస్తోంది లేదా
గెస్ట్  OS, బార్  లో నడపబడుతున్న
వాస్తవాన్ని మారుస్తుంది; మొదటిది IO లేదా payజ్
టేబుల్స్ లను మార్చడం లేదా ప్రస్తుత
అధికార స్థాయిపై సమాచార సూచనలను గమనించడం.
మీరు మీ ప్రాథమిక architecture 
అంశాలను గుర్థిన్చినట్లైతే.
మనము వివిధ స్థాయి లో operation 
ను కలిగి ఉన్నాము, అవి level 0,level
 1 మొదలైన వేర్వేరు స్థాయి కార్యకలాపాలు.
మరింత తక్కువ level  వెళ్ళేకొద్ది,
బేర్ మెటల్కి మరింత దగ్గరగా వెళ్తాము.
ఇది అన్నిటిని నిర్వహించే Virtualization
పై ఆధారపడి ఉంటుంది.
మరింత పై level  వెళ్ళేకొద్ది
మరింత లాటెన్సి  వస్తుంది, మరియు
మరింత అనువాదం అవసరం అవుతుంది.
కాబట్టి, మనము ఏ level  operation లు
చేయాలనే విషయాన్ని పరిశీలిద్దాం; ప్రత్యేకంగా
మనము IaaS సంభందిత operation  లు చేస్తున్నప్పుడు.
సెన్సిటివ్  ఇంస్ట్రక్షన్
ల యొక్క మొదటి క్లాస్  ని కంట్role సెన్సిటివ్
 అని మరియు తర్వాతి క్లాస్ 
ని బెహెవీర్ సెన్సిటివ్ 
అని అంటాము.
Popek మరియు goల్డ్బెర్గ్ ఏమి చెబుతుందంటే,
ఈ 3 ఉపయోగపడే ప్రాపర్టీస్ ల తో Virtual machine
 రన్ చేస్తే సెన్సిటివ్ ఇంస్ట్రక్షన్
లు , ప్రివిలైజ్ద ఇంస్ట్రక్షన్ 
లకు సుబ్సెట్  గా ఉంటాయి.
వారి పనిలో వీటన్నిటిని చూపిస్థాయి, ఈ రకమైన
విషయాలు నిజమైనవి మరియు నిజమైన Virtual
machine  ని గుర్తించగలము.
ఇదే విషయం లేదా మనం చర్చించే ఏవైనా.
ఈ virtual machine మానిటర్ల పై ఈ VM లు మరియు ఈ హార్డువేరు
రన్ అవుతుంటాయి.
మరియు ఈ వేర్వేరు VM లను అనుకరించటానికి
ఇది అనుమతిస్తుంది.
కాబట్టి, ఇది మీదే కావచ్చు.
కొన్ని చోట్ల ఏదైనా గెస్ట్ OS, VM పై రన్
 అవుతుంటుంది.
కన్వర్ట్  చేయవలసిన ఇంస్ట్రక్షన్ ల
సమితి ఈ hardwareకు  అర్ధం చేసుకోగలగాలి.
కాబట్టి, అది మన బాటమ్ లైన్.
మొత్తం VMM మొత్తం అబ్స్త్రాక్సన్
 ను కలిగివుందా లేదా ఏదో ఒక విధమైన
ఒవెర్లప్పింగ్ ఉందా లేదా అనేది
దానిపై ఇంప్లిమెంటేషన్ పై ఆధారపడి ఉంటుంది.
కాబట్టి, Virtualization సాధారణ విధానాలకు
సమీపంలోని విధానాలను పరిశీలిస్తే.
మీరు ఈ Virtualization యొక్క పరిణామమును
చూసినట్లయితే, మనము మొదటిది ఫస్ట్ జెనెరేషన్ లేదా ఫుల్ Virtualization, దీనినేByనరీ
రీరైటింగ్ అంటాము.
కాబట్టి, ఇది Software ఆధారిత అంశం, VMware మరియు
microsoft దీనికి మద్దతిస్తుంది.
ఏ వర్చ్యువల్ missionలు, డైనమిక్ ట్రాన్స్లేటర్ను
 సృష్టించినా, అండర్ లైనింగ్ హార్డువేరుకు
రీరైట్ చేస్తాయి.
సెకండ్ జెనెరేషన్ లో: Virtualization
లేదా పరా వర్చురైజేషన్, కొ ఓపెరటివ్
 Virtualization.
ఇది అతిథి OS లేదా మోడిఫెడ్ గెస్ట్,VMware మరియు xen ల కొ ఓపెరటివ్  Virtualization.
కాబట్టి, మీరు here చూస్తే ప్రాథమికంగా
ఇది VM లోకి కొంచెం చొచ్చుకొచ్చింది;
అంటే, అంశాలపై సవరించబడింది.
ఒక మూడవ జనరేషన్ లేదా సిలికాన్ ఆధారిత
అంశం, hardware సహాయంతో Virtualization
వర్చ్యులైజేషన్ అవగాహన hardware
ప్లాట్ఫారమ్లో లో, on మోడిఫీడ్
గెస్ట్ , VMware మరియు xen ఉంటాయి, ఇప్పుడు
మీ hardware ప్లాట్ఫారమ్కు Virtualization
తెలుసు.
కాబట్టి, ఇది hardware asసిస్టెడ్ 
Virtualization.
ఈ సందర్భాలలో ఈ hardware ప్లాట్ఫారమ్లో లకు ఈ Virtualization గురించి తెలియదు.
ఈ మీ హైపర్విజర్ చేత ఏమి జరిగినా?
ఫుల్ Virtualization లో వివిధ అంశాలు
ఉన్నాయి, ఫస్ట్ జెనెరేషన్ ఫస్ట్ జెనెరేషన్ x86/x64 server ఫుల్ Virtualizationను అందిస్తుంది.
source కోడ్ యొక్క డైనమిక్Byనరీ
ట్రాన్స్లేషన్, మనము చూసినట్లుగా
అన్ని hardware లు CPU తో సహా ఎమ్యులేటెడ్
అయ్యి ఉంటాయి.
2 ప్రముఖ open source ఎమెల్యూటర్లు
 ఉన్నాయి, వాటిలో ఒకటి చాలామందికి
తెలిసిన QEMU మరియు రెండవది Bochs . ఇవి రెండు
open source ను మార్చే ప్రముఖ
ఎమెల్యూటర్లు .
పూర్తి Virtualization, ఎమ్యులేషన్ లేయర్
 యొక్క ప్రయోజనాలు ఉన్నాయి.
మొత్తం VM portability, నేను VM ను ఒకదాని
నుండి మరొకదానిలో ఉంచగలము.
కాబట్టి, మొత్తం portabilityని
ఉపయోగిస్తాము, ఎందుకంటే VMM మాత్రమే, మనకు అర్థం
అవుతుంది.
ఈ hardware ఎమ్యులేషన్స్ performance  Tierతో పాటు వస్తుంది.
ఇది ఇందులోని ఒక లోపం.
మీరు ట్రడిషనల్ x86 architecture
లో హార్డువేర్ performance Tierను అనుకరించాలనుకున్నప్పుడు,
OS కెర్నెల్ లు ప్రత్యేక హక్కు ప్రివిలేజ్
రింగ్0 లో రన్ అవుతుందని అనుకుంటున్నాం.
ఇప్పుడు మీరు వాటిని అధిక level  లో
అమలు చేయాలనుకుంటే, ఎక్కువ లాటెన్సి
ఉండాలి మరియు ఇతర విషయాలను కూడా పరిశీలించాలి.
కాబట్టి, మనం దాని కోసం pay  చెయ్యాల్సిన
అవసరం ఉంది లేదా performance 
Tier మనకు అవసరం.
పారా వర్చురైజేషన్ విషయంలో, గెస్ట్
OS సవరించబడింది మరియు రింగ్ 1 లేదా రింగ్
3 వద్ద కెర్నల్ level  ఆపరేటింగ్
System ను అమలు చేస్తుంది.
ఇది అధిక level  గెస్ట్ గా ఉంటుంది,
ఇది ప్రివిలేజ్ ఇంస్ట్రక్షన్  ను ఎలా ప్రాసెస్
చేయాలో తెలుసుకోగలదు.
VMM కు అనువదించబడిన ప్రివిలేజ్ 
ఇంస్ట్రక్షన్  ఇకపై అవసరం లేదు.
గెస్ట్ నిర్వహణ వ్యవస్థలు ప్రత్యేక
API ను VMM తో కమ్యూనికేట్ అవడానికి ఉపయోగిస్తాయి.
కాబట్టి, ఇది పారా; దీని అర్థం, మీ VMM,
కొన్ని రకాలైన VM లను ఉపయోగించడానికి
చొచ్చుకుపోతుంది.
కనుక, ఇప్పుడు అది పూర్తి అనువాదం కాదు,
కానీ ఒక పారా వర్చురైజేషన్ performance
 పెరుగుతుంది మరియు ఈ విషయం బాగా
ప్రజాదరణ పొందుతోంది.
పారా వర్చురైజేషన్ విషయంలో, OS
కెర్నెల్ను రి కంపైల్ చేయాల్సిన
అవసరము ఉంది, దీనిని ఉపయోగించాలంటే, పారా
Virtualizeడ్ డ్రైవర్ల
యొక్క inస్టలేషన్  అవసరం.
ఇది, గెస్ట్ OS లెవేల్ లో జాగ్రత్తలు తీసుకుంటుంది.
మూడవది, hardware asసిస్టెడ్ వర్చురైజేషన్, గెస్ట్ OS రింగ్ 0 లో రన్
 అవుతుంది.
VMM, ఇంటెల్ VT లేదా AMD V లలో ఉన్నట్లుగా
Processor ఎక్స్టెంషన్స్  లను ఉపయోగిస్తుంది
మరియు గెస్ట్  లో ఉన్న ప్రివిలైజెడ్
 operation  లను inర్సెప్ట్
 చేస్తుంది.
హార్డువేర్ సహాయంతో Virtualization
అనేది, ఒక VMM ను వ్రాసేటప్పుడు జరిగే అనేక problemలను
తొలగిస్తుంది, అది ఒక పెద్ద సవాలు.
ఇది hardware అసిస్టెంట్; అనగా, మీరు నేరుగా
పొందగలిగితే అది completely కంపైల్
 అయి ఉంటుంది.
ఇలా చేయడం వల్ల, మీరు VM ల యొక్క పోర్టబిలిటిని
కోల్పోతారు, ఇది గమ్మత్తైన problemగా
మారుతుంది, ఎందుకంటే hardwareని
అర్థం చేసుకునే machine కి మీరు మైగ్rate
అవ్వాలి.ఉపయోగం, అది అన్మోడిఫైడ్
OS ని రన్ చేయడానికి అనుమతిస్తుంది, మీరు
OS లు మార్చల్సిన అవసరం లేదు; లోపం, స్పీడ్
 మరియు ఫ్లెక్సిబిలిటీ  ల problem ఉంది.
మైగ్రేషన్ జరిగినప్పుడు మీరు ఫ్లెక్సిబిలిటీ
 కోల్పోతారు మరియు స్పీడ్ ,
మైగ్రేషన్ పై ఆధారపడి ఉంటుంది.
మనం నెట్ work Virtualization యొక్క కొన్ని అంశాలపై
మనము చర్చించుకుందాం.
ఇప్పటి వరకు మనము హార్డువేర్ level
 లో చూసాము, ఇప్పుడు మనం network
level  లో చూద్దాం; అంటే, ఇచ్చిన networkలోని
ఒక వర్చ్యువల్ నెట్ work పై నెట్
work ను అనుకరించాల్సిన అవసరం ఉంది.
network టెక్నాలజీలో మనం చూసే విలక్షణ
విధానాలు అంటే ఐపి బేస్ లేదా ఎటిఎమ్
బేస్ లేయర్ .
వర్చ్యులైజేషన్ యొక్క ఏ లేయర్
లో ఆర్చిటెక్చురల్ domain ఉంటుంది,దీనిలో
network వనరుల ajamanyaాలు, స్పానింగ్
 networkలు ఉంటాయి, వర్చ్యులైజేషన్
level  లో,Node level  లేదా ఫుల్ వర్చ్యులైజేషన్ వంటివి ఉన్నాయి.
మనం ఈ network కలిగి ఉన్నాం అనుకుందాం.
appపుడు మనం ఇలాంటి network ను
ఎమ్యులెట్చేస్తాం, కనుక, ఇది నా బేస్
network.
మనము 2 రకాల వర్చ్యువల్ network
లను దీని పైన కలిగివున్నాము.
ఒక virtual networkను మనము ఎమ్యులెట్
చేశాము, వాస్తవంగా ఎందుకు మనము విర్చువలైజ్
 కి వెళ్ళాలి అంటే మన స్వంత networking
పారాడిగ్మ్లో internet స్తంభించడం
మాత్రమే కాకుండా, స్payస్  ఎక్కువ
ఉండదు.
ఒన్ size ఫిట్స్ అల్  architecture
 ని తీసుకుని రావడం చాలా కష్టం.
మనము network కాన్ఫిగరేషన్ ని కలిగి ఉంటాము
మరియు ప్రతిఒక్కరికీ సరిపోతుంది.
ఎందుకు మనం వివిధ సినారియో  లకు
అన్నీ create  చేయడానికి బదులుగా
అన్నిటికి సరిపోయేవిధంగా ఒకే రకం create
 చేయకూడదు.
ఇదే మనం చేయాలనుకుంటున్నాం.
కాబట్టి, భవిష్యత్ network architectureల మరియు ప్రోటోcallలు కోసం టెస్ట్ బెడ్
లు ఉన్నాయి.
కనుక, మనము ఒక విధమైన Virtualize network కలిగి ఉంటాము.
మరియు ఇది అకస్మాత్తుగా ఇందులోకి రాలేదు,
ఇది ఇప్పటికే ఒక virtual private
network , ప్రోగ్రామబుల్
network, మరియు ఓవర్లే networkలు మొదలైనవి ఇప్పటికే చాలా ఉన్నాయి.
ఇది వాటిపై ఎమ్యులేట్ చేయబడుతోంది.
మనము here చూసినట్లైతే, వివిధ అంశాలు,అనగా
business model ,business
architecture , డిజైన్ ప్రిన్సిపుల్స్ మరియు డిజైన్ goల్స్  ఉన్నాయి.
మరియు infrastructure providerస్, Service provider, ఎండ్ యుసెర్స్
, మరియు బ్రోకర్లు వంటి వివిధ అంశాలు
ఉన్నాయి.
ఇవి వేర్వేరు ప్లాయెర్స్  మరియు వారి మధ్య
చాలా complex సంబంధం ఉంటుంది.
మరియు business model , ఈ network
Virtualization కు మాత్రమే
సరిపోదు, అది Virtualization యొక్క ఇతర అంశాలకి
కూడా సరిపోతుంది .
కాబట్టి, నేను ఆ infrastructure providerని కలిగి ఉంటే, appపుడు నేను ఒక
Service provider 1 ను కలిగి ఉండి,
ఒక విధమైన Virtualize network
ను కలిగి ఉంటాను.
దీని నుండి ఎమ్యులెట్ చేసినవి, కొన్ని
networkలను ఆక్టివేట్ చెయ్యడం
మదలైనవి.
మనము ఇతర రకాలైన Service provider 2, SP2 ఇతర రకాలైన networkలులను
కూడా ఎమ్యులెట్ చేయడం, కనుక, నేను
ఒక ప్రాథమిక అంతర్లీన network లో
వివిధ రకాల network లను ఎమ్యులెట్
చేస్తుంది.
కాబట్టి, మనము వివిధ రకాల networkలులను
ఏర్పరచవచ్చు.
కాబట్టి, ఇవి చాలా ప్రజాదరణ పొందాయి.
serverలు మాత్రమే కలిగి వుండకుండా
భౌgoళిక స్payస్ అంతటా ఒక నిర్దిష్ట
పరీక్ష నిర్వహించాలని అనుకుంటాను.
కాబట్టి, నేను ఈ serverలను తీసుకురావడం మాత్రమే
కాకుండా నేను ఒక నిర్దిష్ట network
infrastructure కావాలి అనుకుంటాను.
ఇలా చెయ్యాలి అంటే appపుడు IASS స్థాయి
లేదా server స్థాయి Virtualization మాత్రమే
ఉంటే సరిపోదు, network level Virtualization కూడా కావాలి మరియు ఈ మొత్తాన్ని
నేను ఒక వాస్తవిక ఐపి infrastructure
స్థానంగా పొందగలగాలి.
కాబట్టి, మా చర్చలు మా తదుపరి ఉపన్యాసాలలో
మేము కొనసాగిస్తాము.
ధన్యవాదాలు.
ఈ cloud computing యొక్క ఈ కోర్సుకు
స్వాగతం.
cloud యొక్క వివిధ అంశాలపై మన
చర్చ కొనసాగుతుంది.
నేడు మనము ఏమి చూసేందుకు ప్రయత్నిస్తున్నాం
అంటే, అండర్ లైనింగ్ టెక్నాలజీ
అంటే ఏమిటి మరియు అండర్ లైనింగ్ ప్రోటోcall
, ఏదైతే అన్నిటిని కలుపుతుందో.
ఇవన్నీ cloudలో ఉన్నాయని మనము చర్చించాము,
here వివిధ రకాలైన service లు లేదా
XaaS, ఏదైనా ఒక service గా ఉండే model
ఉంది. కాబట్టి, మనకు కొన్ని మార్గాలు
లేదా ఇతర ప్రోటోకోల్స్ ని కలిగి ఉండాలి.
ఇప్పుడు, మీరు consumerని లేదా customer
లేదా cloud యొక్క consumerని చూసినప్పుడు,
cloud provider యొక్క service
ను తీసుకుంటారు.
అందుచే, ఇది ఈ cloud  , cloud provider
 లో ఎక్కడ, ఎలా host  అవ్వడం
అనేది Independentంగా ఉంటుంది.
యూజర్ client ఎలా access
చేస్తారు.
కాబట్టి, ఇది service ఓరియెంటెడ్ architecture
 కంటే ఎక్కువ, మనం ఏదైతే
సాధారణం గా అమలు చేస్తామొ అది. Web
service ఓరియెంటెడ్ architecture లేదా Web service లు
మనకు తెలిసినట్లుగా, ఏదైతే loosely కపుల్డ్ వైవిధ్య service ల మధ్య పరస్పరం
అనుసంధానించడానికి, ఎక్స్పెక్టెడ్ outపుట్
 సాధించడానికి అనుమతిస్తుంది.
కాబట్టి, ఈ రకమైన service ఎక్స్ఛేంజీ లు లేదా service డ్రివెన్ architecture
 యొక్క ప్రాధమిక అంశం లేదా
ప్రాథమిక నిర్మాణ బ్లాక్లో ఒకటి
XML. కాబట్టి, మనము నేడు చర్చించబోతున్నాము,
బహుశా ఒకటి లేదా రెండు ఉపన్యాసాలు
XML యొక్క బేసిక్స్ మీద ఉంటాయి.
దీని అర్థం ఏమిటంటే, మీరు ఎక్కువగా XML
వాడతారు లేదా మీరు XML అంటే ఏమిటో తెలుసుకుంటారు.
మీలో చాలా మందికి XML యూస్  చేస్తుంటాము
లేదా XML అంటే తెలుసే ఉంటుంది.
కానీ దీని గురించి తెలియని వారికి , అన్నీ
రకాల శ్రోతలకి మనము XML యొక్క చాలా ప్రాథమిక
విషయాలను చర్చిస్తాము , దాని లక్షణాలను
మరియు దానిని ఎలా అనుమతిస్తుందో తెలుసుకుందాం.
మనము XMLను చూసినట్లైతే.
పెరుగుతున్న Software టూల్స్, XML standards
మరియు ఐడియాస్  కోసం ఉద్భవించిన
ఎక్రోనిం XML. కాబట్టి, మనమిప్పటికీ XML యొక్క
విభిన్న ప్రాపర్టీ లు ఏవి?
ఇది ఎలా ఉంది, అది ఏ విధంగా పరస్పరం
పంచుకుంటుంది.
పార్సెర్ యొక్క వివిధ రకాలు ఏమిటి
లేదా XML లో ఉన్న ఇతర రకాల టెక్నాలజీస్
 ఏవి ఉన్నాయి.
ఇది ఎక్స్టెంసిబల్ మార్కప్ లాంగ్వేజ్.
మనము HTML, హైపర్ టెక్స్ట్ మార్కప్ లాంగ్వేజ్ వాడతాము, ఇవి ప్రధానంగా internet
 యొక్క వరల్డ్  లో డాక్యుమెంట్
చూసేందుకు ఉపయోగించబడతాయి, కాబట్టి, XML ఎక్స్టెన్సిబుల్
మార్కప్ లాంగ్వేజ్ మరియు HTML ల
కాకుండా, అంతకంటే ఎక్కువData డిస్ప్లే
 లేదాData రిప్రజెంటేషన్ లాంగ్వేజ్.
మీ inఫర్మేషన్ రెప్రెసెంటేషన్  XML
అనేదిData ట్రాన్స్ఫార్మేషన్ లాంగ్వేజ్  కంటే ఎక్కువైంది.
అది మనకు intraపోరేషన్స్  ను సాధించటానికి
అనుమతిస్తుంది.
ఎన్కోడింగ్ కోసం సింటాక్స్ అనేది
టెక్స్ట్ ఆధారితంగా ఉంటుంది.
వర్డ్ ఫ్రేస్ నంబర్స్.
కాబట్టి, ఇది చదవగలిగేది, ఒక టెక్స్ట్ ఆధారిత
సింటాక్స్ మరియు XML అనేది ముద్రించదగిన
యూనికోడ్ కారెక్టర్, ఎక్ష్ప్లిసీట్Byనరీ
data, కారెక్టర్ ఎన్కోడింగ్
problemలు ఉండవు; ఇది ఎక్ష్టెన్సిబుల్
; XML లో మనం మన సొంత అంశాలను నిర్వచిస్తాము.
data రకాలు వలె, HTML వలె కాకుండా HTML కు
ఉపయోగించిన లేదా HTML చూసినప్పటికీ,
మనకు ముందుగా ఉన్న ట్యాగ్ల సెట్
ఉంటుంది.
XML లో మనము మన స్వంత అంశాలు లేదా స్వంత
ట్యాగ్  లను నిర్వచించవచ్చు.
దీని సిన్టాక్స్ రూల్ స్థిరంగా
ఉంటుంది, ఖచ్చితంగా మీరు సింటాక్స్
యొక్క సందర్భంలో నిర్వచించగలరు.
దీన్ని కొన్నిtimes యునివర్సల్ ఫార్మాట్ కూడా సూచిస్తుంది.
అన్ని XML processing software సైతం XML data  ఇచ్చిన Software
పీస్  నిర్వహించాలని ఈ సింటాక్స్ నియమం
నిర్ధారిస్తుంది.
కాబట్టి, అది యునివర్సల్ .
మీరు XMLData మరియు XML processing Software లేదా XML పార్సర్ ను కలిగి ఉంటే, ఇది
అన్ని రకాల XML నిర్వహించగలుగుతుంది, కనుక ఇది యునివర్సల్
.
కాబట్టి, ఇది ఒక XML యొక్క విలక్షణ ప్రాథమిక
లక్షణాలలో ఒకటి, ఇది XML ఊబిక్యుఎస్
 చేస్తుంది.
కాబట్టి, మీరు చదివి దానిని ప్రాసెస్
చేయగలిగితే; మీరు దానిని చదివి మరియు
ప్రాసెస్ చేయగలిగితే, ప్రతి ఒక్కరూ అదే
dataను చదవగలరు మరియు ప్రాసెస్
చేయగలరు.
మనము resources నుండి తీసిన మాదిరిగానే
ఒక సరళమైన ఉదాహరణ చూడండి.
ఒక XML డిక్లరేషన్ ఉన్నటువంటి కొన్ని
విషయాలు ఉన్నాయి.
here వెర్షన్, XML నేమ్ స్payస్
ఉంది మరియు వివిధ అంశాల నిర్వచనం ఉన్నాయి.
ఇవి వివిధ XML ట్యాగ్స్, ఈ ట్యాగ్ లు మనం
చూసినట్లైతే వీటిని యూజర్ డిఫైన్డ్  చేశారు, కాబట్టి వీటిని యూజర్ డిఫైన్డ్
 టాగ్  లు అంటాం; అంటే, మనం సొంత టాగ్లు
నిర్వచించగలము, partorders, description,మరియు partnumber, ఇవి
అన్ని యూసర్  నిర్వచించిన టాగ్లు.
కాబట్టి, html లా కాకుండా, దేనిలో అయితే ట్యాగ్లు
ఫ్రే డెఫినేడ్  గా ఉంటాయో మరియు
here మీ సొంత ట్యాగ్లను నిర్వచించలేరు, అయితే
XML లో మీరు మీ స్వంత ట్యాగ్లను నిర్వచించవచ్చు.
ఇప్పుడు మీరు మీ సొంత ట్యాగ్లను
నిర్వచించినట్లయితే, ఆ తరువాత వెలుగులోకి
వచ్చే విషయాలు ఏవి అంటే టాగ్లు ఎలా
నిర్వచించారు అనేది చెప్పాల్సిని అవసరం
ఉంది. నేను టేబుల్ అనే ట్యాగ్ను నిర్వచించాను.
ఇప్పుడు, ఈ టేబుల్ కొన్ని ఫర్నిచర్
తరగతులు లేదా ఫర్నిచర్ వర్గంలో ఉన్న సమూహాన్ని
సూచిస్తుందో లేదో లేదా టేబుల్ వర్డ్
processing లేదా ఫ్రేస్
 వర్గీకరించడంలో ప్రధానంగా ఉంటుంది.
కాబట్టి, ఇది ముఖ్యమైనది.
నేను ఒక ట్యాగ్ను నిర్వచించాను.
ఇప్పుడు నేను తెలుకోవాల్సిన విషయం, టాగ్ ను
డిఫైన్  చేస్తే, నేను ఫర్నిచర్
కేటగిరి నుండి ఒకటి మరియు వర్డ్ processing వర్గం నుండి మరొకదాన్ని ఉపయోగిస్తున్నాం
అని. appపుడు నేను నిర్వచించవలసి ఉంది,
మరో వైపు నేను ఏమి కావాలనుకుంటున్నాను
అనేది ఎలా తెలుసుకుంటారు.
XML నేమ్payస్ యొక్క భావన ఉంది, ఇది ప్రధానంగా
మన సొంత యూజర్ నిర్వచించిన అంశాలు
మరియు ఇతర విషయాలను నిర్వచించటానికి
అనుమతిస్తుంది.
కాబట్టి, మనము XML డాక్యుమెంట్ ను చూస్తే, అది క్రమానుగత
మరియు నిర్మాణాత్మక సమాచారం.
నేను ఈ డాక్యుమెంట్ చూస్తే.
ఇది ఒక పార్ట్ ఆర్డర్.
ఇది ఒక XML నేమ్స్payస్ అయిన tap మోస్ట్Node, ఇది ఈ నేమ్స్payస్ కి సంభందించిన పార్ట్
ఆర్డర్ అని మరియు అది వేర్వేరు level
లను కలిగి ఉంటుంది లేదా అది ప్రధానంగా
హైరార్ఖికల్ గా కనిపిస్తుంది, కనుక
మేము ఒక XML ట్రీ ను ఉత్పత్తి చేస్తాము.
కాబట్టి, XML అనేది ట్రీ  స్తృక్తుర్డ్
 సమాచారం యొక్క ఈ లక్షణంతో వస్తుంది,
ఇది XML ట్రీ చే సూచించబడుతుంది.
కాబట్టి, మనం మళ్లీ మన ప్రాథమిక ఆవరణ
లేదా ప్రాథమిక నిర్వచనానికి తిరిగి వచ్చినా,
ఇది html వంటిది, కానీ అంత సులభం కాదు, html
చాలా వనిల్లా రకం. సింటాక్స్ ఎర్రోర్స్
 ని తొలగించడానికి ఖచ్చితమైన సింటాక్స్
నియమాలు ఉంటాయి.
కాబట్టి, XML చాలా ఖచ్చితమైన సింటాక్స్ రూల్స్ ని అనుసరిస్తుంది.
సింటాక్స్ స్ట్రక్చర్ హైరార్ఖికల్  మరియు స్ట్రక్చురల్  ఎలిమెంట్స్
 payర్లను నిర్వచిస్తుంది మరియు ఇది స్వీయ
వర్ణనData.
కాబట్టి, నా సొంత సెల్ఫ్ డిస్క్రైబింగ్
dataను కలిగి ఉండవచ్చు, ఇది html కేస్
లా కాకుండా ఎక్స్టెన్షన్ చేయబడుతుంది; ఇది
XML here వాకబులరి  అనేది ఫిక్స్
అయ్యి ఉండదు.
మీరు మీ స్వంత వోకాబులరి లేదా ట్యాగ్లు
లేదా అంశాలని నిర్వచించగలరు మరియు దీని అర్థం,
మీరు ప్రాథమికంగా ఈDataను విస్తరించవచ్చు.
ఇది distributed ఎన్విరాన్మెంట్ కొరకు డిజైన్ చెయ్యబడింది, HTML లాగా,
ఇది కూడా distributed ఎన్విరాన్మెంట్ కొరకు డిజైన్ చెయ్యబడింది.
దీనికి distributed System ల
యొక్క వేర్వేరుNodeలలో వివిధ వ్యవస్థలతో
కమ్యూనికేట్ చేయడానికి లేదా interface
 లేదా ఇంటెరోpayrate చేయగల సామర్థ్యం
ఉంది. కనుక, టాగ్ ల యొక్క మన సొంత లాంగ్వేజ్
 మరియు ఎలిమెంట్స్ ని సృష్టించవచ్చు,
అంతటా ఉన్నData పొందవచ్చు మరియు
రిలయబుల్ గా ఉపయోగించవచ్చు.
అందువల్ల, ఇది డిస్ట్రిబ్యూట్  చేయబడుతుంది
మరియు వివిధData టైప్ లను కలపవచ్చు
కాకుండా.
కాబట్టి, html దీన్ని చేయగలదు.
కానీ XML లో, నేను మల్టిపుల్ resource లను
కలిపి మరియు దాని నుండి ఇంకొకDataను
రూపొందించుకోవచ్చు.
దీని మాదిరిగా, నేను 2 రిపొజిటరీ
ల నుండి వచ్చాను.
నేనుData యొక్క వివిధ కొంపోనెంట్స్
 తీసుకొని చివరిగా ఈ రెండు విషయాల మిశ్రమాన్ని
కలిగి ఉన్న ఇంకొక dataను రూపొందించవచ్చు,
అవి HTML, XML అలా చేయటానికి అనుమతిస్తుంది.
ఇది వివిధ సందర్భాల్లో చాలా ఉపయోగకరంగా
ఉంటుంది, మీరుDataను రెండు రకాలుగా పొందుతున్నారంటే,
మీ విద్యాinstitutionలో చెప్పాలంటే, అకడెమిక్
విభాగానికి చెందిన ఒకData, మరొక data
అన్నీ management Center ల
నుంచి విద్యార్థులందరికీ సంబంధించినవి తీసుకుని,
క్లబ్ చేసి ఈ ప్రత్యేక సెమిస్టర్ లేదా
ప్రత్యేక బ్యాచ్ లేదా ప్రత్యేక సంవత్సరం
ఉత్తమ విధ్యార్ధిని తెలుసుకోవాలనుకుంటున్నాను
వంటి కొన్ని విషయాలు కనుగొనేందుకు ప్రయత్నించండి.
కాబట్టి, నేను విద్యార్థికి సంభందించిన వివిధ
ఆక్టివిటి Data, విద్యార్థి అకడెమిక్
Data మరియు వేరొక రకమైన data  ఉపయోగించి
మరొకData సమితిని రోపొందించవచ్చు.
కనుక, ఈ విధమైన distributed వైవిధ్యమైనData
సెట్  ను మీరు ఎప్పుడైనా ఎలా కలపవచ్చు,
ఎలా ఇంటెరోpayrate  చెయ్యబడుతుంది,
మరియు కొత్త data  ని ఎలా రూపొందిచవచ్చు.
ఈ విధమైన సంTier్భాలలో, ఈ XML ఉపయోగకరంగా ఉంటుంది.
కాబట్టి, ఇది వివిధData టైప్స్ ల
మిశ్రమం.
ఇతర access, XMLData ఎలా ప్రాసెస్
అవుతుంది.
కాబట్టి, మనము చూసిన ఒక విషయం ఏమిటంటే
అది ట్రీ  స్ట్రక్చర్  ని కలిగి ఉంటుంది.
ఇప్పుడు HTML వంటి ఇతర standard లాగా
కాకుండా ,లేదా మీరు ఎటువంటి యూజర్ డెఫినేడ్
 విషయాలు లేకుండా ఉండేది చూస్తున్నాం.
కనుక, మీరు సింటెక్స్ మాత్రమే కాకుండా,
ఎలిమెంట్స్  మొదలైన వాటిని కూడా
డిఫైన్  చెయ్యవచ్చు.
కానీ here ఈ సందర్భంలో, నేను మొదట తెలుసుకోవాల్సిన
అవసరం ఏమిటంటే, ఎలిమెంట్ల నంబర్స్  ఏమి
ఉన్నాయి,వాటిలో ఏవి యూసర్ డెఫిన్ద్  మరియు వారు మొదట ఏమి చేయాలనుకుంటున్నారో
తెలుసుకోవాల్సిన అవసరం ఉంది. కాబట్టి,
ఈDataని ప్రాసెస్ చేయడానికి, నేను
ఇటు వంటిDataను కలిగి ఉన్నాను, దాన్ని
కొన్ని internet resource ల నుంచి
తీసుకున్నాను.
ఇలాగే, ఫైల్ ట్రాన్సఫర్ తేదీ, చాలా మొత్తం
ట్రాన్సాక్షన్ ID మరియు వివిధ రకాల
ట్రాన్సాక్షన్ లు అనేవి ఇంటర్బ్యాంకు
కు సంభందించినవి.
ఇది బ్యాంకు లావాదేవీల లాగా ఉంటుంది, కొన్ని
బ్యాంక్ లోపల అంతర్గతంగా ఉంటాయి మరియు కొంతమంది
ఇంటర్బ్యాంక్ లేదా వివిధ బ్యాంకుల
మధ్య ఉంటాయి, appపుడు ఈDataను ఎలా ప్రాసెస్
చేయాలి.
దీనికి ముందుగా XMLData నుండి inఫర్మేషన్
ను సేకరించిన తర్వాత processing
జరుగుతుంది.
ఇది ఒక XML రకమైన లాంగ్వేజ్ లో ప్రాథమికంగా కవర్
చేయబడి ఉంటుంది, appపుడు నేను దానిని
ఎక్స్ట్రాక్ట్  చెయ్యాలి మరియు కొన్ని
విధాలైన application లను,Dataను
సేకరించేందుకు అవసరమైన టూల్స్  ఉపయోగించి
ప్రాసెస్ చేస్తాను.
దీనిని మనము XML పార్సర్ ద్వారా చేస్తాము.
XML పార్సర్ processing model, ఇది XMLData
పార్సర్ అయినట్లయితే, data  పార్సర్
గుండా వెళుతుంది మరియు ఇతర వైపు XML
బేస్డ్ application, వీటి మధ్యలో
పార్సర్ interface ఉంది. కాబట్టి,
XMLData appపుడు Processor, అది
XML ఆధారిత applicationలు ప్రేరేపించిన విషయాలు
వెలికితీస్తుంది.
పార్సర్, XMLData సింటాక్తీకలి
సరైనదా కదా అని ధృవీకరించాలి.
కాబట్టి, పార్సర్ యొక్క పాత్ర ఏమిటి
అంటే, మొదటిది, పార్సర్లో XMLData వాక్యనిర్మాణంగా
సరైనదో ధృవీకరించాలి.
కాబట్టి,Dataలో సింటాక్స్ ఎర్రర్లేదు. రెండవది, అటువంటి data 
ని వెల్ ఫోర్మ్ద్  data అంటాము.
ఇది సీన్టాక్టికలి సరియైనది అయితే,
appపుడు దానిని వెల్ ఫోర్మ్ద్ XML
అంటాము.
కాబట్టి, ఒక XML గా కనీస అవసరాన్ని సరిగ్గా
రూపొందించాలి, ఇది ప్రాసెస్ చేయదగినది,
మనము ఈDataను ప్రాసెస్ చేయగలము.
data సరిగ్గా లేనట్లయితే, పార్సెర్ data
processing ఆపి వేస్తుంది.
కాబట్టి, అది ఆపివేసిన processing
మరియు XML ఆధారిత application  కు ఎక్ష్కెప్షన్
 త్రో  చేస్తుంది.
అది వెల్ ఫార్మ్డ్ కాకపోతే; అనగా, ఇది
సింటాక్తీకలి కరెక్ట్  data
కాదు. కాబట్టి, మనము తిరిగి గెర్తుచేసుకున్నట్లైతే,
వేర్వేరు భాగాలతో కలిపి XML processing
రూల్ లో, DTD అని పిలువబడే అంశం ఉంది, ఇది డాక్యుమెంట్
టైప్ డిక్లరేషన్.
కాబట్టి, ఏదైనా XMLDataకు ముఖ్యమైనది
ఏమిటంటే, రిలేషనల్ data బసెస్  వంటిData బేస్ విషయంలో మనము చూసినట్లుగా,
సాధారణం గా ఏమి చేస్థామంటే, ఒక టేబల్ లేదా
బహుళ టేబల్ ను డెఫినే చేస్తాము,
ఎక్కడైతేData వివిధ రూపాలలో లేదా
రికార్డు రూపంలో లేదా వివిధ రో లుగా
లేదా టుపుల్స్ గా ఉంటుందో.
ఇప్పుడు, ఈ టేబల్ నిర్వచించటానికి,
మనము టేబల్ యొక్క నిర్మాణం నిర్వచించవలసి
ఉంటుంది లేదా దీనినే మనం టేబల్ యొక్క
స్కీమా అని అంటాము, కాబట్టి ఈ టేబల్
లో వేర్వేరు వేరియబుల్ ఉంటే, ఏ వేరియబుల్,
ఏ స్కీమ కు సంభందించినది అనేది మనము నిర్వచించాల్సిన
అవసరం ఉంది. కాబట్టి, XML విషయంలో కూడా, ఇవి
యూసర్ డెఫినేడ్  నిర్మాణం మరియు
ఇది క్ర హైరార్ఖికల్ .
మనం ఎలిమెంట్ ని ఎలా డిఫైన్
చేశామో కూడా తెలియదు, appపుడు ఇతర ఎలిమెంట్స్
levelస్  మరియు ఎలిమెంట్స్
రకాలు ఏవి, మరియు అందుకే here కూడా,
మనము ఒక స్కీమా డిఫైన్ చెయ్యాల్సిన
అవసరం ఉంది లేదా గతంలో మనం చూసినట్లుగా
దీనిని డాక్యుమెంట్ టైప్ డిక్లరేషన్ అని పిలుస్తారు.
మొదటగా మీరు డాక్యుమెంట్  రకం డిక్లేర్
చెయ్యాలి.
ఇప్పుడు డాక్యుమెంట్ రకంపై ఆధారపడి ఉంటుంది,
అది ఒకవేళDataలో మిగిలినది ఉంటే.
కాబట్టి, ఒక మార్గం; పార్సెర్ యొక్క పనిలో
ఒకటి data  సింటాక్తీకలి కరెక్ట్ ఆ, కదా ఆని
చూడడం, ఇది ప్రత్యేకమైన డాక్యుమెంట్ ,
నిర్వచనం ను అనుసరిస్తుందా లేదా అన్నది కాకుండా,
సింటాక్తీకలి కరెక్ట్ అని చెప్పుకోవాలంటే,
బాగా ఉపయోగపడుతుంది.
appపుడు స్కీమా లేదా డాక్యుమెంట్
టైప్ డెఫినిషన్ తరువాత అది
చెల్లుబాటు అయ్యే XML అవసరం అవుతుంది.
XMLDataను పొందడానికి, పార్సర్ ఈ DTD ను
సంప్రదిస్తుంది.
ఇది సింటాక్తీకలి సరియైనదిగా ఉంటే,
ఈ ప్రత్యేకమైన operationల కోసం XML వాలిడ్ 
అని చెబుతుంది.
మనకు XML పార్సర్, DTD, మరొక ఇంటర్నల్
ఎంటిటీలు ఉన్నాయి.
పార్సెర్ ప్రక్రియల వలె, DTD కంటెంట్
ఇంటర్నల్ ఎంటిటీ ని గుర్తిస్తుంది
మరియు ప్రతి ఎంటిటి వెల్ ఫోర్మ్ద్  ఆ కదా అని చెక్ చేస్తుంది.
DTD కంటెంట్ కోసం స్పష్టమైన సింటాక్స్
రూల్  ఉండాలి.
వెల్ ఫోర్మ్ద్  XML here సరిగ్గా
ఉండాలి.
DTD కంటెంట్ కోసం స్పష్టమైన సింటాక్స్
రూల్  ఉన్నాయి కాబట్టి, బాగా XML ఈ
విషయంలో సరిగ్గా ఉండాలి.
పార్సర్ appపుడు ప్రస్తావించబడిన
ఎంటిటీ ద్వారా ఎంటిటీ రిఫరెన్స్ యొక్క ప్రతి సంఘటనను భర్తీ చేస్తుంది.
సో, రికార్సివ్ గా ఎంటిటి ల లోపల
చేస్తుంది.
కాబట్టి, రిఫరెన్స్ చేయబడిన ఎంటిటీ
ద్వారా రిఫరెన్స్ చేసిన ఎంటిటీ
తో, ఇది ముందు ఉన్న ఎంటిటి ని రిప్లేస్
చేస్తుంది.
కనుక ఇది ఎంటిటి రిఫరెన్స్
గా ఉంటుంది.
పరిష్కారం పొందినData ఆబ్జెక్ట్ , తర్వాత XML applicationకి అందుబాటులో ఉంటుంది.
ఈ XML application కు వెళ్లినప్పుడు,
మనం ఇంతకుముందే పిక్చర్  లో చూసినట్లుగా,
ఇది వెల్ ఫామ్ చెకింగ్, సింటాక్టికల్
చెకింగ్ చేయడాన్ని మరియు
DTD తో చెక్  చేయడాన్ని కూడా రూపొందిస్తుంది,
ప్రత్యేకమైన డాక్యుమెంట్ను మనము XML application
పంపించే ముందు ఏదో విధమైన application
ధృవీకరించడం.
XML processing లో external
ఎంటిటీలు ఉండవచ్చు.
మనం ముందు చూసిన ఇంటర్నల్  ఎంటిటీలు
ఉన్నాయి, అనగా ఏమిటంటే డిటిడి hereే
డెఫినే  చేయబడింది లేదా స్కీమా కూడా
hereే నిర్వచించబడిందని అర్థం.
కాబట్టి, external ఎంటిటీ ఒక
URL ద్వారా సూచిస్తారు.
ఇది ప్రాథమికంగా external నిర్మాణం లేదా
స్కీమాను ఏంటీటీఎస్  లో చూడవచ్చు.
కాబట్టి, పార్సర్, DTD కంటెంట్ని ప్రాసెస్
చేస్తుంది, external ఎంటిటీలను గుర్తిస్తుంది
మరియు వాటిని పరిష్కరించడానికి ప్రయత్నిస్తుంది.
పార్సర్, appపుడు, ఎంటిటీ రిఫరెన్స్
 యొక్క ప్రతి సంఘటనను రేఫెరెన్స్డ్
ఎంటిటి చే భర్తీ చేస్తుంది
మరియు ఇంటర్నల్  అంశాలతో సహా అన్ని
ఏంటీటీఎస్లతో రేకుర్సివ్ 
గా జరుగుతుంది.
external ఏంటీటీఎస్  లో కూడా రిప్లేస్
చేసేటప్పుడు outస్ మరియు go ఉంటాయి.
కానీ పార్సర్ external ఏంటీటీఎస్
ని కనుగొనలేకపోతే, అది firewall
అడ్డుకోవడం వల్ల కావచ్చు.
ఇది application మరియు పార్సర్
రకాన్ని బట్టి ఉంటుంది.
రెండు రకాలైన XML పార్సర్లు ఉన్నాయి.
అందులో ఒకటి అన్ని ఏంటీటీఎస్  ని
రిట్రీవ్ చేసుకుంటుంది.
మరొకటి వాటిని ఇగ్నోర్  చేస్తుంది.
కాబట్టి, ఇది పార్సర్ యొక్క processing
పాలసీ మరియు ప్రొసెసింగ్ రూల్స్
పై ఆధార పడి ఉంటుంది.
మనకు 2 రకాలైన XML పార్సర్ లు ఉన్నాయి, మొదటగా
చెప్పుకునే పార్సర్; అన్ని ఎంటిటి లను
తిరిగి పొందాలి మరియు మొత్తం DTD కంటెంట్
ను తప్పనిసరిగా ప్రాసెస్ చేయాలి, సరిగ్గా
చేయలేకపోతే, ప్రాసెస్ను ఆపి వేస్తాము మరియు
విఫలమయిందని మేము సూచిస్తాము.
కాబట్టి, మేము ఏమి చెప్తున్నామంటే,
వాలిడేటింగ్ పార్సర్ విషయంలో.
ఇది ఈ స్కీమా డెఫినిషన్ కి లేదా DTD కంటెంట్కు
అనుగుణంగా ఉండాలి.
నోన్ వాలిడేటింగ్ పార్సర్
ఎంటిటీలో డెఫినే  చేసిన అన్ని ఎలిమెంట్స్
 ని తిరిగి పొందేందుకు ప్రయత్నిస్తుంది,
కనుగొనలేకపోతే, కానీ మొదటి అంశం లో DTD కంటెంట్
ను processing  ను తొలగిస్తుంది.
కాబట్టి, ఇది వాలిడేటింగ్ పార్సర్ లేదా
నోన్ వాలిడేటింగ్ పార్సర్
పై ఆధారపడి ఉంటుంది.
application బిహెవీర్  ఖచ్చితంగా
పార్సర్ రకంపై ఆధారపడి ఉంటుంది.
కాబట్టి, ఇది పని ఎలా పనిచేస్తుంది
అనేది పార్సెర్ పై ఆధారపడి ఉంటుంది.
కాబట్టి, మనము here XMLDataను పార్సర్
కు పంపుతాము.
తర్వాత అది XML application యొక్క పార్సర్ interface కు వెళుతుంది.
DTD పార్సర్ తో ముడిపడి ఉంటుంది, ఇది పార్సర్
స్వభావంపై రేలేషన్షిప్, బెహెవీర్ dependency
 ఇస్తుంది.
కాబట్టి, DTD అనేది ఈ పార్సరును తనిఖీ
చేయడానికి, వెల్ ఫోర్మ్ద్  వెలిడేషన్
 కు మరియు వెలిడేషన్  కోసం, సరియైనదిగా
చేస్తుంది.
కొన్ని ప్రత్యేక problemలు ఉన్నాయి,
క్యారెక్టర్స్  మరియు క్యారెక్టర్
సెట్స్  కాబట్టి, XML స్పెసిఫికేషన్
మాదిరిగా, వైట్ స్payస్ టాగ్ ని ఉపయోగించి
వైట్ క్యారెక్టర్స్  ని డెఫినే
చెయ్యొచ్చు.
EBCIDIC క్యారెక్టర్స్ , NEL ను వైట్ స్payస్
టాగ్  గా ఉపయోగించలేరు.
ఎన్కోడింగ్ క్యారెక్టర్ సెట్లో నిర్వచించబడని
అక్షరాలను మీరు ఇంక్లూడ్  చేయాలనుకుంటే
ఏమి జరుగుతుంది.
కాబట్టి, ఈ విధమైన క్యారెక్టర్ సెట్
ల నిర్వహణ కోసం వివిధ మార్గాలు ఉన్నాయి.
ఈ విధమైన క్యారెక్టర్  సెట్లను నిర్వహించడానికి
XML కొన్ని విధానాలను అందిస్తుంది.
ఇప్పుడు, నేను లాంగ్వేజ్ డిఎలెక్ట్ ని
ఎలా నిర్వచించాలి, చివరికి మనం చూడాలని
ప్రయత్నిస్తున్నది సాధారణంగా ఒక XML డాక్యుమెంట్
ను ఎలా నిర్వచించాలి మరియు ఇది ప్రాథమికంగా
ఇతర విషయాలతో ఎలా ఇంటెరక్ట్  అవుతుంది.
కాబట్టి, మనకు తెలుసు, service ఓరియెంటెడ్
architecture లో, మేము
3 ప్రధాన భాగాలను కలిగి ఉన్నాము.
కన్స్యూమర్, provider మరియు
రిజిస్ట్రీ లేదా service ల రకాలు
లేదా రేపోసిటోరి కి కొన్ని విధాల
ఆర్రేస్  వంటివి.
ఈ వేర్వేరు service providerలు, service కన్స్యూమర్ల మధ్య ఒక Communication
ఉన్నప్పుడల్లా, service రిజిస్ట్రీ
అంటే మనము చూడవలసినది ఏమిటంటే, ఈ data Communication ఎలా జరుగుతుందో, సర్వవ్యాప్త పద్ధతిలో
అమలు చేయబడుతుంది.
మేము మీకు తెలిసినట్లుగా ఇది ఒక స్కోప్ సందేశంగా
ఉంటుంది, ఇది ప్రాథమికంగా మరియు XML డాక్యుమెంట్
లో సరైనది అయిన ఒక machine  కావచ్చు.
soap WSDL, UDDI, వంటివన్నీ అన్ని ప్రధానంగా
XML సరైన డాక్యుమెంట్స్.
కాబట్టి, మీరు XML డాక్యుమెంట్ రకం, XML spec యొక్క డిక్లరేషన్
భాగం, XML స్కీమా, కొత్త XML స్పెసిఫికేషన్,
XML డాక్యుమెంట్ పై బలమైన అడ్డంకులను
అనుమతించే రెండు మార్గాల్లో చూస్తే.
కాబట్టి, మీరు చూస్తున్నది DTD, ఇప్పుడు 2001 XML స్కీమా
లేదా XSD నిర్వచించబడింది.
కాబట్టి, స్పెక్ట్రంలో అధిక వెర్షన్.
ఇది XML డాక్యుమెంట్ నిర్మాణం యొక్క స్కీమాను
నిర్వచించే ఒక కొత్త స్పెక్.
ప్రధానంగా ఒకే విధమైన జాబ్  చేస్తున్నదాని
కంటే ప్రాథమికంగా లేదా ప్రాథమికమైన
వ్యత్యాసం ఉంటుంది; XML స్కీమ XML లో రాస్తారు,
అంతేకాదు; అయితే DTD వాస్తవానికి వేరొక
విధంగా రాయబడింది.
కాబట్టి, ఇప్పుడు XMLDataలో స్కీమా
ను హ్యాండిల్  చెయ్యడం.
కాబట్టి, మాండలిక వివరణ జతచేయడం అనేది
రెండు వర్గాల XML లను సూచిస్తుంది, ఒకటవది
వెల్ ఫోర్మ్ద్ XML డాక్యుమెంట్ను,
ఏదైతే సింటాక్తీకలి కరెక్ట్  గా ఉంటుందో
అది. కాబట్టి, మనము ఏమి చెపుతున్నామంటే
అది వెల్ ఫోర్మ్ద్ XML, మరియొకటి వ్యాలీడ్
 XML అని పిలువబడే ఒక విషయం ఉన్నది.
కాబట్టి, ప్రత్యేకమైన DTD లేదా XSD లేదా స్కీమాతో
సరిగ్గా ఏర్పడిన వెల్ ఫోర్మ్ద్ మరియు స్థిరమైన XML డాక్యుమెంట్లు,
ఇవి వ్యాలిడేట్  అయ్యేవి.
ఇది ప్రాథమికంగా స్కీమా కు అనుగుణంగా
ఉంటుంది; అంటే, ఇది వ్యాలీడ్ స్కీమా.
కాబట్టి, అన్ని వ్యాలిడేట్  XML డాక్యుమెంట్లు
వెల్ ఫోర్మ్ద్.
కాబట్టి, DTD మరియు ఇతర స్కీమ అంశాలు
ఎలిమెంట్లను మరియు అట్రిబ్యూట్Data, హైరార్ఖికల్ నెస్టింగ్ రూల్స్ ,
ఎలిమెంట్ , కంటెంట్ మరియు టైప్ నియంత్రణలను
అనుమతిస్తుంది.
కాబట్టి, ఇది స్కీమా లేదా payర్కొన్న విషయం.
ఇదిData కాదు.
XML స్కీమ లేదా DTD ఏ XMLDataను సరిగా
కలిగి ఉండదు.
XML ఫైల్ లో inఫర్మేషన్  ఉంది, కానీ నిర్మాణం
here నిర్వచించబడింది.
ఇది ఒక ప్రత్యేకమైన ప్రాపర్టీ, అనగా
ఎప్పుడు రెండు institutionలు A, B inఫర్మేషన్ ని
మార్పిడి చేయాలని కోరుతున్నాయి లాంటిది.
కాబట్టి, వారు వెతుకుతున్నది ఏమిటంటే, మొదటిది
ఈ ఎక్స్ఛేంజ్ ప్రోటోcall నిర్మాణంపై ఒప్పుకోవాలి.
ఉదాహరణకు చెప్పాలంటే, IIT Kharagpur,Data
ట్రాన్సఫర్ ని కలిగి ఉంటుంది, payమెంట్
గేట్వే లేదా కొంత payమెంట్ ట్రాన్సఫర్, బ్యాంకుతో లేదా ఏదైనా ఆర్ధిక institutionతో
payమెంట్ పరస్పరంగా జరుగుతుంది.
ముఖ్యమైనది ఏమిటంటే, ఒక విద్యార్థిData
యొక్క స్ట్రక్చర్  IIT Kharagpur లో
మరియు అవి స్టేట్ బ్యాంక్లో ఏ విధంగా
store అవుతుంది అనేది మొదటిది.
అవి ఏ బ్యాంకులు అయిన కావచ్చు స్టేట్
బ్యాంక్ లేదా పంజాబ్ బ్యాంకు లేదా ఏదైనా,ఆ institutionతో ఒప్పందం ఉండాలి.
ఆ తేదీ కోసం, ఆ అవసరం కోసం ఏDataను ఎక్స్ఛేంజి
 చెయ్యాల్సిన అవసరం లేదు?
కాబట్టి, ఇది సరైన విషయం యొక్క ప్రాథమిక
కర్తవ్యం.
దీనికి నేను ఏDataను మార్పిడి చేసుకోవలసిన
అవసరం లేదు. మన అవసరం ఏమిటంటే నిర్మాణం
కంటే ఎక్కువగా, ఏమి ఎక్స్ఛేంజి 
చెయ్యాలి మరియు inసిడెంటల్గా స్ట్రక్చర్ 
ని ఎక్స్ఛేంజి చేయడం అనేది complexది
కాదు. here ప్రైవసీ  problemలు, ఈData
నిర్వహణను సేకరించడం కోసం నిర్వహణ వ్యయాల
problemలు ఉన్నాయి.
అది ప్రాథమికంగా మన చేజారిపోతుంది.
అందువల్ల,Data చాలా problemలను కలిగి ఉన్నది,
అయితే IIT Kharagpurలో మనం చూస్తే గనక, ఈ
స్టూడెంట్ స్ట్రక్చర్  ఇలా ఉంటుంది.
కాబట్టి, స్టూడెంట్ స్కీమా ఇలా
ఉంటుంది.
నేను ఎంత మంది స్టూడెంట్స్  ఉన్నారు, దాని
లక్షణాలు ఏమిటి అనేది చెప్పము, కానీ స్కూల్
 విద్యార్ధి యొక్క స్కీమా ఈ విధంగా
ఉటుంది.
ఇది ఇతర institutionతో ఇంటెరక్ట్  అయితే,
స్కీమా వారీగా ఇంటెగ్రేషన్ 
సాధ్యమవుతుంది.
ఎలిమెంట్ అట్రిబ్యుట్, హైరార్ఖికల్
నెస్టింగ్ రూల్స్ , ఎలిమెంట్
, కంటెంట్ మరియు టైప్ limitedులను
దీని కొరకు అనుమతిస్తుంది.
స్కీమాలు, DTD ల కంటే మరింత powerfulవి,
అవి తరచూ టైప్ వ్యాలిడేషన్ కోసం లేదా XML
modelలకుDataబేస్ స్కీమా లను
రిలేట్ చేయ్యడానికి ఉపయోగిస్తాయి.
స్కీమాలు, DTD కన్నా మరింత powerfulవి.
వారు నిర్మాణాన్ని మాత్రమే ఉంచరు, కానీ
ఇది విభిన్న రకాల విషయాల కోసం ఉపయోగించబడుతుంది.
స్కీమా ఉపయోగించడం వంటి, నేను ఒకDataబేస్
టేబుల్ create  చేసి, తర్వాత
ఈ రెండిటి మధ్య ఉబిక్యుఎస్లీDataను బదిలీ చేయవచ్చు.
కాబట్టి, ఈ స్కీమాలకు అదనపు నిర్వహణను
అందిస్తుంది.
కాబట్టి, ఈ రోజుల్లో మేము ప్రధానంగా స్కీమాలను
ఉపయోగిస్తాము మరియు విభిన్న partyల
మధ్య ఈ విధమైన ఇంటర్ కార్యకలాపాలను నిర్వహించడానికి
స్కీమా ఒక ముఖ్యమైన పాత్రను పోషిస్తోంది.
మీరు DTD ఎక్సాంపుల్  ని, డాక్యుమెంట్
లో భాగంగా చూస్తే గనక. డాక్యుమెంట్
టైప్, ఎలిమెంట్స్ బదిలీ, కొన్ని ఇతర
రకాలు ఉన్నాయి.
ఇప్పుడు, మీరు దీనిని చూస్తే, ఇది నిజంగా
XML ఫైల్ లేదా XML డాక్యుమెంట్ ను సరిగ్గా అనుసరించడం
లేదు. అయితే, ఒక స్కీమా లో, ఇది XML డాక్యుమెంట్
గా ఉంటుంది.
external  DTD ఉంది, here foo.org
అనేది ఒక DTD. దీన్ని ఎప్పుడైనా రెఫర్
 చెయ్యాల్సిన అవసరం ఉన్నప్పుడు
ఇది ఎక్ష్తెరల్గా రెఫర్  చేస్తాం.
కనుక, ఇది కొన్ని ఇతర DTD లను రెఫర్ 
చెయ్యడానికి అనుమతి ఇస్తుంది మరియు ఏ
విధమైన data వస్తున్నాయో చూడడానికి అనుమతిస్తుంది.
నేను మరొక provider నుండిDataను వినియోగిస్తున్నప్పుడు
నేను చూడాలనుకుంటున్నాను, ఏ విధమైనData వస్తోంది,
అనగా, ఒక ప్రత్యేకమైన ఆర్డర్లో వస్తోందా
లేదా, నిర్తిష్ట హైరార్ఖి లో
ఉందా. మరొక వైపు నేను external 
DTD చేయవచ్చు మరియు అది ఏ విధమైనData
అని చెక్ చెయ్యొచ్చు.
కనుక, ప్రాసెస్ చేయడానికి కావలసిన
data, పార్సర్ ద్వారా ఫిల్టర్
మరియు సేకరించేందుకు అనుమతిస్తుంది.
నా ఆబ్జెక్టివ్  నేను ఒక source 
నుండిDataను పొందుతున్నాను, నేను చేయాలనుకుంటున్న
data యొక్క భాగాన్ని సేకరించేందుకు ఫిల్టర్
చేయాలనుకుంటున్నాను మరియు నేను సెంటైగ్రేడ్
 నుండి ఫెరెన్హీట్ కు లేదా meter 
నుండి ఫీట్  కు unitను మార్చడానికి
కావలసిన విధంగా కొన్ని application లు
అవసరం కావచ్చు.
మేము XML లో మా చర్చను కొనసాగిస్తాము.
XML లో మరికొందరు అర్థం చేసుకోవటానికి XML
యొక్క కొన్ని ఇతర లక్షణాలు అంటే ఈ
ఇంటర్పోపెరాట్ కు ఎలా ఉపయోగపడుతున్నాయో
తెలుసుకోవడం మరియు ఎలా ఒక cloud ముఖ్యంగా
Software as ఆ service modelస్
రేయలిజేషన్  కోసం ఉపయోగపడుతుంది
అనేవి తెలుసుకుందాం.
ధన్యవాదాలు.
కొనసాగిస్తాము.
కాబట్టి, చివరి lectureను మీరు గుర్తుపెట్టినట్లయితే,
మనము XML బేసిక్స్ గురించి మాట్లాడుతున్నాము,
మనము ఏమినేర్చుకున్నాం అంటే, ఈ XML distributed
System లోని వివిధ ఇంటెరోpayrate
System లు లేదా కొ ఓపెరటివ్ 
System ల మధ్య ఇంటెరోpayరట్ 
చేయటానికి ఎలా అనుమతిస్తుంది అని. మరియు ఇది cloud
computingని ప్రత్యేకించి SaaS
cloudని లేదా Software as ఆ
service రకమైన cloud
కు ఎలా ప్రధాన వెన్నెముక లా ఉంటుంది.
మనము ఇంకా DTD మరియు XML స్కీమ XSD గురించి
చర్చించాము.
నేడు మనము XML యొక్క ఈ ప్రాథమిక అంశాలపై
చర్చను కొనసాగిస్తాము.
మనము XML స్కీమా గురించి ఏమి చర్చించామో
గుర్తుచేసుకున్నట్లైతే.
ఇది ప్రధానంగా XML యొక్క నిర్మాణాన్ని
నిర్వచిస్తుంది.
IIT Kharagpur లో ఒక నిర్దిష్ట బ్యాచ్ లోని ఒక
స్టూడెంట్Data ని XML లో ఉంచడం, ఇది
భారీ పరిమాణం లో ఉంటుంది.
ఇది మా ప్లేస్మెంట్ విభాగంలో లేదా మా
బ్యాంక్ అక్కౌంట్  విభాగంలో ఉంటుంది.
వారు ఈDataలో కొంత భాగాన్ని external
ఏజెన్సీలతో భాగస్వామ్యం చేయాలనుకుంటారు.
దదీనికి ఒక పరిష్కారం స్కీమాలో కొన్ని
భాగాలను పంచడం.
మరియు external ఏజన్సీలతో ఉన్న అంశాలలో భాగమని
చెప్pay ఒక మార్గం, లేదా వేరొక విధంగా
మీ institutionలోని data  ని ఇతర institution తో
పంచాలనుకోవడం.
అందువల్ల, ముందుగా అక్కడ ఉన్న data
కి ఏ స్కీమా అవసరం ఉంటుందో గుర్తుంచాలి.
కాబట్టి, వివిధ రిపోజిటరీల మధ్య ఇంటెరోpayరబిలిటీ
లో సహాయపడే సమాచార మార్పిడికి XML స్కీమా
కీలక పాత్ర పోషిస్తుంది.
కొత్త వివరణ, స్కీమ అనేది XML యొక్క వ్యాలిడేషన్
రూల్ ను payర్కొనడానికి 2001 లో వచ్చిన క్రొత్త
వివరణ.
మనం చూడగలిగినవి ఏ XML పార్సర్ని
మొదట ఇది సింటాక్తీకల్లి సరియైనదో లేదో, లేదా
వెల్ ఫోర్మ్ద్ ఆ కాదా పరిశీలించాలీ.
రెండవది, స్కీమా విషయంలో data వాలీడ్
అవుతుందా అని చెప్పుకోవాలంటే అది స్కీమతో తనిఖీ
చేస్తుంది.
కాబట్టి, దీనిని మనం వాలీడ్ అయ్యే
XML డాక్యుమెంట్ అంటాము.
మీరు చూడవచ్చు కొన్ని స్పెక్ మరియు ఉత్తమ
ఆచరణలో W3 వంటివి ఉన్నాయి.ఇది ప్యూర్ XML, ఇలా ఉండాలంటే
XML స్కీమా ని XML లో రాయాలి.
ఈ స్కీమాస్ మరింత powerfulవి మరియు
DTD లు ఇంటీజీర్  రకం, తేదీ, real 
రకం మొదలైనవి మరియు ఇతర పరామేటెర్స్
ను వాటిని payర్కొంటాయి.
వారు తరచూ టైప్ వాలిడేషన్  కోసం లేదా
XML బేస్ modelలనుData బేస్ స్కీమాస్కు సంబంధించిన అన్ని రకాలుగా ఉపయోగిస్తున్నారు.
మనకు స్కీమా తెలిస్తేDataబేస్ ను
create చెయ్యొచ్చు మరియు ఆ తర్వాత ఈ
XMLDataను ఈDataబేస్ కు లేదా ఇతర మార్గానికి
పంపుతాము, అయితే, మనము ఎనిటీటీస్ 
ని డిక్లేర్  చేయలేము; ఇవి DTD లో
మాత్రమే చేయవచ్చు.
కాబట్టి, ఎంటిటీలలో దీనిని నిర్వచించలేము.
మన డిటిడి లు ఆ స్కీమా ఎలా సమానం
అవుతాయో ఈ Slide  చూపిస్తుంది.
మీరు మొదటి తరగతి అంటే XML బేసిక్స్
లో గుర్తు పెట్టుకున్నట్లయితే చివరగా మనం చూసిన
డిటిడి మాదిరిగానే ఉంటుంది.
అదే విషయం ఇప్పుడు ఒక స్కీమాగా సూచించబడుతుంది.
కాబట్టి, మనము XML డాక్యుమెంట్ లో ఇంకా ఏమి చేస్తున్నామో
చూద్దాం.
మనము ఈ స్కీమాను నిర్వహించగలము అదే
విధంగా XMLDataని సరిగా నిర్వహించగలము.
XML యొక్క మరో ముఖ్యమైన అంశం XML నేమ్ స్payస్
; XM యూసర్ డిఫైన్డ్ data ను అనుమతిస్తుంది
ఇది చాలా ముఖ్యమైన అంశం. కాబట్టి, మనం
ఏ విధమైన నిర్వచనం ఉందో మరియు ఏం నేమ్
స్payస్ కావాలి అనేది జాగ్రత్తగా
చూసుకోవాలి.
మీకు చివరి చర్చ గుర్తు ఉంటే మేము
ఒక ఎంటిటీ call టేబల్  లేదా ఎలిమెంట్
call టేబుల్ డెఫినే  చేస్తే,
ఇది టేబల్  , ఏ రకమైన టేబల్  అనేది payర్కొనాలి.
మనము ఒక టేబుల్ ను కలిగి ఉన్నట్లుగా
మనం చెప్పుకున్నాం, ఆ ఫర్నిచర్ లేదా
టేబుల్ అనేది ఒక వర్డ్ Processor లేదా స్ప్రెడ్ షీట్  నుండి
కావచ్చు, దీని ఎలా చెప్పొచ్చు
అంటే, ఫర్నిచర్ రకానికి చెందిన ఒక
టేబల్ మరియు దాని డెఫినిషన్  ఒక
విధం గా ఉంటుంది, వర్డ్ processing రకానికి చెందిన టేబల్  మరియు దాని
డెఫినిషన్  మరొక విధంగా ఉంటుంది.
దీని అర్థం, నేను దీనిని ఎక్కడ నిర్వచించాను,
నేమ్ స్payస్ లో నిర్వచించాలి.
నేమ్ స్payస్ ఏ ఎలిమెంట్  ఉంది
, ఏ విధమైన డీలింగ్  లు, మోడైలన వాటి
గురిచి చెబుతుంది.
XML payర్ల కోసం వేర్వేరు స్payస్  లను గుర్తించడం,
అనగా ఎలిమెంట్స్  మరియు వాటి నేమ్
లు, కోసం ఇది ఒక పద్ధతి.
ఇది వేర్వేరు భాషా మాండలికాలను గుర్తించే
ఒక మార్గం, నిర్దిష్ట సెమాంటిక్స్
మరియు processing అర్ధాలను కలిగి ఉన్న
payర్లను కలిగి ఉంటుంది.
కీ అనేది ఒక లాంగ్వేజ్, ఒక నిర్దిష్ట security
కీ లాంటిది, మనము టేబల్  గురించి
మాట్లాడుతున్నప్పుడు, మరొక లాంగ్వేజ్
లో బహుశా ఒకDataబేస్ కీ  అంటారు.
కాబట్టి, కీ అనేది బహుశా ఒక విధమైన
security కీ మరియు మరికొన్ని
విషయాల్లో మనము వెతుకుతున్న కీDataబేస్
సంబంధిత కీ అయి ఉండవచ్చు.
ఈ రెండు కీలుDataబేస్ స్కీమ నుండి
ఒకDataబేస్ నేమ్ స్payస్ మరియు
మరొకటి ఈ security నేమ్  కోసం
స్payస్, నిర్వచించాల్సిన అవసరం ఉంది. కాబట్టి,
ఇది ఒక ప్రత్యేక XMLNS ఉపయోగిస్తుంది,
XML నేమ్  అంటే ఈ నేమ్ స్payస్ ని నిర్వచించడానికి
కావలసిన XML నేమ్ స్payస్ అట్రిబ్యూత్.
నేమ్ స్payస్ ఒక URL స్ట్రింగ్
లాగా ఇవ్వబడుతుంది, కానీ URL దేన్ని రిఫర్
 చేయదు, ఏదైనా ఉండవచ్చు.
కాబట్టి, ఇది దేన్ని సూచించలేదు.
కాబట్టి, నేమ్ స్payస్  , లాంగ్వేజ్
 డైలాగ్ల యొక్క మిశ్రమం.
ఈ విధంగా ఉంటే, నేమ్ స్payస్  ఇంతకంటే
సులభతరం చేయగలదా, నాకు రెండు కీలు
కావాలి.
dataబేస్ కీల నుండి నేనుDataబేస్
అన్లాక్ చేయడానికి సీక్రెట్ కీని
ఉపయోగిస్తాను, ఆపై యూజర్Dataబేస్ కీ ని access  చేయడానికి ఉపయోగిస్తాము.
మనము రెండూ కీ లను ఎక్కడో ఒకచోట ఉపయోగిస్తాము.
మరియు రెండూ XML లో ఉన్నాయి, ఈ XML నేమ్
స్payస్ dataబేస్కీ  లేదా security
కీ లేదా కొన్ని ఇతర కీ అనుమతిస్తుంది.
here ప్రధానంగా కీ రకం payర్కొనబడిఉంది.
అంటే, here మీరు చూస్తే ఈ నేమ్ స్payస్
 డిfault నేమ్ స్payస్.
ఇది W3C చేత నిర్వచించబడింది, అయితే, ఈ నేమ్ స్payస్
ఖాళీ అనేది ఒక గణిత సంబంధిత నేమ్స్payస్.
ఇది కూడా ప్రీ డిఫైన్డ్, కానీ ఖాళీగా ఉన్న
ఒక గణిత సంబంధిత నేమ్payస్ అని
నేను చెపుతాను.
ఇప్పుడు నేను ఈ ప్రత్యేక మ్యాత్ రేలాటెడ్
తో ఏదైనా చేస్తే appపుడు నేను ఖాళీ
డబుల్ కోలన్ mathml మరియు టైటిల్
మొదలగునవి చెప్తాను.
నేను ఈ గణిత నేంస్payస్ ను రిఫర్  చేస్తాను.
కాబట్టి, ఈ ఎంప్టీ ప్రేఫిక్స్ 
mathml, డిఫరెంట్ లాంగ్వేజ్  ఒక అనే స్payస్
 ని సూచిస్తుంది.
ఇది completely విభిన్నమైన భాష మరియు నా డాక్యుమెంట్లో
ఆ ప్రత్యేక నేమ్payస్ యొక్క ఆ అంశాలకు
నేను ప్రాథమికంగా ఉపయోగించగలగాలి.
ఈ విధంగా, మనము చూస్తున్నట్లుగా నేమ్ స్payస్
ఒక ముఖ్యమైన పాత్ర పోషిస్తుంది మరియు
మీరు జాగ్రత్తగా ఉండాలి, మరియు నేమ్
స్payస్ నిర్వచనాలు అక్కడ ఉండాలి.
కాబట్టి, ఇతర మాటల్లో చెప్పాలంటే, మనం
చూస్తున్నప్పుడు మనమిప్పుడు ఏమి చేస్తున్నామో
చూద్దాం, ఆ ప్రత్యేక నేమ్payస్ చూసి
అది ఎలా ఉపయోగించాలో మొదలైన విషయాలను
తెలుసుకుంటాం.
ఇంతకుముందు మరో ముఖ్యమైన అంశాలను మేము చర్చించాము
వాటిలో కొన్ని XML Software.
కాబట్టి, XML డాక్యుమెంట్  టెక్స్టువల్
 మోడ్ లో ఉంటుంది.
నేను దానిని ప్రాసెస్ చెయ్యాలి.
దీనిలో మొదటగా, ఇది వెల్ ఫోర్మ్ద్  లేదా సింటాక్తీకల్లి కరెక్ట్  గా ఉందా
లేదా అని వాలిడేట్చెయ్యాలి.
రెండవది, వేర్వేరు applicationలకు
ప్రాసెస్ చేయవలసిన అవసరం ఉంది. కాబట్టి,
ఈ XML Software ఒక ముఖ్యమైన పాత్ర
పోషిస్తుంది.
కాబట్టి, XML పార్సర్ , XMLData  ను రీడ్
 చేసుకుని DTD మరియు స్కీమా కన్స్త్రైంట్స్
 తో సింటాక్స్ చెక్  చేస్తుంది
మరియు ఈ మొత్తంDataను ఒక application 
కి అందుబాటులో ఉంచుతుంది.
మూడు సాధారణ XML API లు లేదా పార్సర్
API లు ఉన్నాయి.
అందులో ఒకటి, XML SAX పార్సర్, ఇది ఒక సాధారణ XML ఈవెంట్
బేస్డ్ API, ఇది చాలా ప్రజాదరణ పొందిన
విస్తృత పార్సర్ గా మరియు ఎక్కువగా
అన్ని ప్లాట్ఫారమ్ లలో అందుబాటులో ఉంటుంది.
రెండవది DOM పార్సర్, డాక్యుమెంట్ ఆబ్జెక్ట్
model లేదా ఆబ్జెక్ట్ ట్రీ  ఆధారిత పార్సర్.
చివరిది, JDOM పార్సర్ లేదా java DOM పార్సర్.
ఈ XML పార్సర్ మరియు interface Software లు అధికముగా వివిధ ఆపరేటింగ్
Systemsలో అందుబాటులో ఉంటాయి.
SAX ఆధారిత పార్సర్లు  మనము తరచుగా
పంpayData స్ట్రీమ్  వేగంగా లాగే
ఉంటాయి మరియు ఇవి చాలా తక్కువ కపాసిటీ
 ఉన్న పార్సెర్ మరియు ఇవి చాలా ఎక్కువ
వేగంతో పనిచేసినా కూడా తక్కువ ఫంక్షనాలిటీలను
 కలిగి ఉంటాయి.
DOM చూసినట్లైతే, ఇది స్లోయర్  పార్సర్
, అధిక మెమరీ ఇంటెన్సివ్ , మొత్తం డాక్యుమెంట్
 యొక్క మెమొరీ వర్షన్  ని
create  చేస్తుంది.
వాలిడేటింగ్ పార్సర్ అనేది నోన్ వాలిడేటింగ్
పార్సర్ కంటే చాలా నిదానముగా ఉంటుంది,
ఎందుకంటే వాలిడేటింగ్ పార్సర్,
ప్రొసెసింగ్  కి వెళ్ళే ముందు
స్కీమా  కు అది అనుకూలంగా ఉందో లేదో
వాలిడేట్  చేస్తుంది.
వేర్వేరు పార్సర్స్ గురుంచి చూశాం అందులో
SAX పార్సర్ అందుబాటులో ఉన్నట్లయితే, ఇది
ఈవెంట్ ఆధారిత interface, పార్సర్,
టాగ్ అట్రిబ్యూట్  /టెక్స్ట్
node / పరిష్కరించనిఎ క్ష్టెర్నల్
ఏంటీటి లు మొదలైనవి చూసినప్పుడల్లా
ఈవెంట్స్ని రిపోర్టు  చేస్తుంది.
ప్రోగ్రామర్లు ఈవెంట్స్ని నిర్వహించడానికి
ఈవెంట్ హ్యాండ్లర్లను అటాచ్ చేస్తారు.
ప్రయోజనాలు.
ఇది ఉపయోగించడానికి చాలా సులభం, చాలా
వేగంగా ఉంటుంది.
మరియు టెక్స్ట్,Data పొందుటకు
ముందు ఎక్కువగా కష్టపడనవసరం లేదు. కాబట్టి, ఇది
చాలా ఫాస్ట్ , తక్కువ మెమరీ.
కాబట్టి, ఇది తక్కువ payload ని కలిగి
ఉంటుంది.
ప్రతికూలతలు, ఎక్కువ processing 
చేయవు.
కాబట్టి, మీరు మీ దగ్గర కొన్ని processingలను
చేయవలసి ఉంటుంది.
మీరు డైనమిక్ గా సవరించే డాక్యుమెంట్
వరల్డ్ సిరీస్ మీ మెమొరీ
లో ఉన్నట్లైతే ఇది అంత ఉపయోగకరం కాదు.
కనుక, మీ డైనమిక్ డాక్యుమెంట్
లు సవరించడానికి అది ఉపయోగకరంగా లేదు.
ఎందుకంటే ఇది మెమొరీ , దానికి జ్ఞాపకశక్తి
ఉంటుంది, మీ మొత్తం ప్రొసెసింగ్ 
చేసి మెమొరీ లో పెట్టుకోవచ్చు.
కనుక, ఇది ఒక వనిల్లా రకం XM processing
అవసరాన్ని కలిగి ఉన్నప్పుడు ఇది ఉపయోగకరంగా
ఉంటుంది మరియు తక్కువ మెమరీ తో, ఫాస్ట్
గా మరియు ఉపయోగించడానికి సులభం గా ఉంటుంది.
డాక్యుమెంట్ ఆబ్జెక్ట్ model లేదా DOM పార్సర్
అయినప్పటికీ అది ఒక ఆబ్జెక్ట్ 
ఆధారిత interface.
పార్సర్, XML డాక్యుమెంట్ కు అనుగుణంగా మెమరీ
ట్రీలో లేదా మెమరీ XML ట్రీ
లో ఉత్పత్తి చేస్తుంది.
DOM interface  అనేది ట్రీ ని
access మరియు సవరించడానికి ఒక
పద్ధతిని గుర్తిస్తుంది.
కాబట్టి, ట్రీ ని డైనమిక్ గా
సవరణ మరియు access చేయడానికి ఇది ఉపయోగకరంగా
ఉంటుంది.
ట్రీ కి డైనమిక్ సవరణ access
ఉంటే, అది చాలా ఉపయోగకరంగా ఉంటుంది,Data
కోసం చూస్తున్న ప్రశ్నకు ఉపయోగకరమైనది, అది
ట్రీ నిర్మాణం మీద ఆధారపడి ఉంటుంది.
కాబట్టి, క్వెర్రియింగ్ ఎందుకంటే ఇది ఒక
ట్రీ  నిర్మాణంగా ఉంటే అది ఉపయోగకరంగా
ఉంటుంది.
ఇది అనేక ప్రోగ్రామింగ్ లాంగ్వేజ్
అయిన C++, JAVA కి అదే interface.
నష్టం తక్కువగా గా ఉంటుంది.
ట్రీ ని ప్రొడ్యూస్  చెయ్యడం మరియు
ఎక్కువ మెమరీ అవసరం అవుతుంది.
DOM ప్రోగ్రామింగ్ interface
ఇక ఆ స్టేట్  కి రాలేదు.
కాబట్టి, ఇది కొంచెం సంcomplexగా ఉండి
మరియుDataను professional హ్యాండ్లింగ్ , ఈ ప్రోగ్రామింగ్ ను నిర్వహించాల్సిన
అవసరం ఉంది.
ఒక DOM పార్సర్ విషయంలో ఈ పార్సర్ interface
లో ట్రీ యొక్క ఈ నిర్మాణంకి వెళుతుంది.
JDOM లేదా java DOM అనేది java ఆధారిత ఆబ్జెక్ట్
ఓరియెంటెడ్ .
ఇది DOM తో సమానంగా ఉంటుంది; ఇది java నుండి
వచ్చింది.
పార్సర్ డాక్యుమెంట్  అనుగుణంగా మెమొరీ ని ప్రొడ్యూస్ చేస్తుంది.
JDOM interface  ట్రీ ని access
 చేయడానికి మరియు సవరించడానికి, పద్ధతులను
కలిగి ఉంది. అందువల్ల, ట్రీ ని access
చేయడం మరియు సవరించడం జరుగుతుంది,ప్రయోజనాలు.ఇది
ఎంతో ఉపయోగకరం.
ట్రీ యొక్క డైనమిక్ సవరణ ట్రీ నిర్మాణ
ఆధారిత క్వార్ర్యింగ్  కి ఉపయోగపడుతుంది.
కాబట్టి, మీ క్వెర్రి , ట్రీ నిర్మాణంపై
ఆధారపడి ఉంటే అది చాలా వేగంగా మరియు
ఉపయోగకరమైనది.
DOM కంటే చాలా బాగా ఉండే ఆబ్జెక్ట్ ఓరియంటెడ్
ప్రోగ్రామింగ్ interface ను కలిగి
ఉంటుంది.
కనుక, దీనికి చాలా ప్రోగ్రామింగ్ interface ఉందని అర్థం ఉంది. ప్రతికూలతలు
తక్కువ, కొత్త కొత్త అంశాలు ఉంటాయి ఈ
రోజుల్లో కొత్త విశయాల పై పనిచేయడానికి
మీరు కకొంత నైపుణ్యం అవసరం మరియు అది
JAVA పై పని చేస్తుంది, అది బహుశా ప్రతికూలంగా
ఉంటుంది లేదా మీరు పని చేయటానికి JAVA
గురించి తెలుసుకోవచ్చని మేము అనుకోవచ్చు
. ఒక పెద్ద problem.
here DOM4J లాంటి ఇంకా కొన్ని ఉన్నాయి,
నావిగేషన్, రాయడం, చదవడం మరియు XML సరిదిద్దడం
కోసం ఇది ఒక java ఫ్రేమ్work.
SAX, DOM, JDOM interface మరియు XSLT లాంటి ఇతర
రకాలైన interface వంటి ఇతర XML institutionలకు
access ని అందిస్తుంది, మిశ్రమ SAX, DOM పార్సింగ్
చేయవచ్చు.
ఇందులో కొన్ని ప్రయోజనాలు ఉన్నాయి, అన్నిటికి
ఇది చాలా బాగా ఉపయోగపడుతుంది.
అన్ని JAVA ప్యాకేజీలో ఒక కలెక్షన్
గా ఉంటాయి.
SAX మరియు DOM పార్సర్ అపాచీ open source
లైసెన్స్ చేయవచ్చు, ఉచితంగా
ఉపయోగించవచ్చు.
ప్రతికూలతలు here కూడా java నే ఉపయోగిస్తాము
మరియు కొన్ని విషయాల యొక్క open sourceఅయితే ఇది మంచిది కాదు.
Xerces మరియు XML టూల్కిట్, C కొరకు XML మొదలైనటువంటి
XML పార్సర్ లు ఉన్నాయి.
cloud  వంటి కొన్ని దిస్తృబుటెడ్ System
 లో పరస్పరం అనుసంధానించినప్పుడు
మా సంవిధానంలో మరింత సంcomplex కార్యకలాపాలను
చేయటానికి కూడా బాగా రూపొందించినవే కాకుండా
ధృవీకరించినవిగా కూడా ఎక్కువ సంఖ్యలో
XML పార్సర్ లు ఉన్నాయి.
పార్సర్ ఎలా ఉంటుందో వంటి బెంచ్మార్క్లు
కొన్ని ఉన్నాయి, స్పీడ్ మెమరీ
మరియు స్ట్రీమ్ processing గురించి, కొన్ని
ఉన్నాయి.
XML processing లో మరో ముఖ్యమైన
అంశం XSLT. ఇది ఎక్ష్టెన్సిబుల్ స్టయిల్ షీట్ లాంగ్వేజ్
.
XML ఎలా రెప్రసెంట్ చేస్తుందో ఈ స్టయిల్
షీట్ ద్వారా ఇవ్వబడుతుంది.
మరో అర్థంలో, మనం స్టైలింగ్తో
పాటు XML దానిని రెప్రసెంట్  లేదా డిస్ప్లే
 చేయడానికి అనుమతిస్తుంది.
కొన్నిtimes కారెక్టర్ పరమ్ గా XML ప్లస్ XSLT
అనేది HTML రకంకి సమానమైనది.
కాబట్టి XSLT ఎక్స్టెన్సిబుల్ స్టైల్ షీట్ లాంగ్వేజ్
ప్రధానంగా ట్రాన్స్ఫోర్మేషన్  కోసం ఉపయోగిస్తారు.
లేదా అది పరివర్తన రకాన్ని మరింతగా
కలిగి ఉంది.
XMLDataను ప్రాసెస్ చేయడానికి XML లాంగ్వేజ్
, XML మరియు XSLT స్టైల్ షీట్ ని inపుట్
గా తీసుకుని ట్రీ  ట్రాన్స్ఫోర్మేషన్
 చేస్తుంది.
విభిన్న నిర్మాణం మరియు విషయాల రకంతో
ఒక కొత్త XML డాక్యుమెంట్ ని ఉత్పత్తి చేస్తుంది.
కాబట్టి, ఇది XSLT గా ఉంటుంది.
మనం సాధారణం గా XSLT లో ఒక విధమైన ఫిల్టర్
operation  లు చేయవచ్చు.
కాబట్టి, ఇది XMLDataను తీసుకుంటుంది, దాన్ని
ప్రాసెస్ చేస్తుంది మరియు మరోవైపు వేరొక
XMLDataను జనrate  చేస్తుంది మరియు
ఒక కొత్త XML డాక్యుమెంట్ని వేర్వేరు నిర్మాణంతో
చేస్తుంది.
ప్రయోజనాలు, ట్రీ  ట్రాన్స్ఫోర్మేషన్
 లకు చాలా ఉపయోగకరంగా ఉంటాయి; కాబట్టి,
నేను ట్రీ ని ట్రాన్స్ఫోర్మ్  చెయ్యాలనుకుంటున్నాను,
మరియు నా application  కోసం నేను దాని
యొక్క సబ్ ట్రీ ని ఉపయోగించడానికి
కావాలి.
ఇది నేను ఎలా చేయగలను?
కాబట్టి, ఈ XSLT ను ఉపయోగించి ఫిల్టేరింగ్ 
చేస్తాను, ఆపై ఇతర భాగాలకు ఫిల్టర్
చేయగలను.
కనుక, ప్రతికూలతలు, large డాక్యుమెంట్స్
లకు లేదా స్టయిల్ షీట్  లకు ఇది
శ్లో  గా ఉంటుంది, స్టైల్ షీట్ డీ బగ్
 చేయడం కష్టం, ఎర్రర్ డిటెక్షన్ ,
మొదలైనవి శ్లో  గా ఉంటాయి.
ఎర్రర్ డెటెక్షన్ లో ఇది అంతా
వర్సటైల్  కాదు. కాబట్టి ఇప్పుడు,
మీరు పై చిత్రాన్ని చూస్తే.
XMLData వస్తోంది.
ఇప్పుడు మనము ఒక స్టయిల్ షీట్
కలిగివుంటే అది మరొక XML పార్సర్ ని కలిగి
ఉంటుంది.
మరియు అది ఈ Processor, processing
unitకి వెళుతుంది.
ఈ వేరొక ట్రీ ని కలిగి ఉంటాము.
కాబట్టి, నేను here ట్రీ  ని మరియు
ఆక్కడ ట్రీ  యొక్క ఒక పార్ట్ ని కలిగి
ఉన్నాను, వీటిని inపుట్గా తీసుకుంటే
out పుట్ data అనేది XML, XSLT ఆధారంగా
ఫిల్టర్  చేయబడి కొత్త XML data  ని
ఉత్పత్తి చేస్తుంది.
XML మెసేజింగ్, వ్యవస్థల మధ్య సందేశాలను
పంపడానికి ఫార్మాట్గా XML ను ఉపయోగిస్తుంది.
ప్రయోజనాలు, ఒకే రకమైన సింటాక్స్
, సెల్ఫ్ దిస్క్రైబింగ్  సులభంగా వివరించే
HTTP etc వంటివి XMLDataను తరలించడానికి ఎక్షిస్టింగ్
లో ఉన్న సాధారణ ట్రాన్స్పోర్ట్
విధానంను ఉపయోగించవచ్చు.
dataను బదిలీ చేయడానికి XML కి క్యారియర్ ప్రోటోcall అవసరం.
అందువల్ల, మనము ఏదైనా data ట్రాన్స్పోర్ట్ పద్దతిని ఉపయోగించాలి.
ఇది మరి ఏ ఈతర ట్రాన్స్పోర్ట్ లేయర్  ప్రోటోcallల
తో కలసి ఉండకూడదు.
కనుక, అది ఒక ట్రాన్స్పోర్ట్  విధానం అంటే
network క్రింద ఉంటుంది మరియు మనము
http, https, SMTP మొదలగునవి ఉపయోగించవచ్చు.
ఈ విధమైన XML మెసేజింగ్ యొక్క కొన్ని అవసరాలు
మరియు appరయోజనాలు ఉన్నాయి.
మరియు సాధారణ సందేశ modelలు ఉన్నాయి.
కాబట్టి, XML సందేశాలు కోసం ప్రోటోcallకు
HTTP ను ఉపయోగించడం, XML లో ఈ XML సందేశాలు
మీరు చూసినట్లయితే ఈ అంశాన్ని ఈ భాగం
ఒక ప్రామాణిక ప్రోటోcall, http ప్రోటోcall యాంత్రికాలు
అని payర్కొన్నట్లయితే.
అయితే, ఇది XML సందేశం లేదా XML పత్రం విషయాలు
లోకి పొందుపర్చబడింది.
సో, అది ఒక కవరు అని ఇది HTTP ప్రోటోcall
మరియు తరువాత అది stuff లోకి ఎంబెడెడ్.
XML-RPC వంటి మెసేజ్ ఫార్మాట్కి కొన్ని ప్రమాణాలు
ఉన్నాయి.
కాబట్టి, ఎన్కోడింగ్ ఫంక్షన్ పద్ధతి
యొక్క చాలా సరళమైన మార్గం నేమ్  ను
call చేసి దాన్నిని మరొక చోటికి పాస్
 చేయడం వంటివి.
సమాచార ఫార్మాట్లలో ఒకటి, సోప్, సింపుల్
ఆబ్జెక్ట్ ఓరియెంటెడ్ access ప్రోటోcall
 ఇది ప్రధానంగా Web
serviceల్లాంటి service ఆధారిత నిర్మాణంలో ఉపయోగించబడుతుంది.
కాబట్టి, ఇది మరింత సంcomplex రేపర్
మీరు interface కోసం మరింత complex
నియమాలను నిర్వహించడానికి మరియు ప్రాక్సీ
సందేశాలను మరియు ఇంతకు ముందుగా స్కీమాలను
payర్కొనడానికి అనుమతిస్తుంది.
దీనిని soap సందేశం ఫార్మాట్ ద్వారా
చేయవచ్చు.
మీరు మరలా చూస్తే XML సందేశము ప్లస్
processing, XML అనేదిData ఎక్స్ఛేంజ్ కోసం యునివర్సల్ ఫార్మాట్.
నేను soap API తో ఈ application ను కలిగి ఉంటాను,
మరియు here ప్రధానంగా రెండు వేర్వేరు రకాల
సరఫరాదారులు ఉంటారు.
అందువల్ల, వివిధ రకాల సరఫరాదారులతో
ఇంటెరక్ట్  అవుతుంది, ఇది మొత్తంగా ఒకే
application, హెచ్‌టి‌టి‌పి  ద్వారా ఇతర application
లతో ఇంటెరక్ట్  అవుతుంది.
కాబట్టి, ఇది soap సందేశం, http లో పిగ్గీబ్యాక్
అవుతుంది.
మరియు ఈ http యొక్క payload లాగా తీసుకెళ్ళి,
విషయాలను పంపిణీ చేస్తుంది, ఇతర ఏంటీటీఎస్
, data  రన్ అవుతున్న ఈ ప్రత్యేక
application  కు ఎక్స్ట్రాక్ట్
చేసి డెలివేరి  చేస్తాయి.
కాబట్టి, మేము XML యొక్క ఈ కుటుంబం చూస్తే.
మధ్య భాగంలో మనకు XML, XSLT, XSL, X పాత్, X పాయింటర్
మరియు ఇతర అంశాలు ఉన్నాయి.
ఇవ్వన్ని చర్చించడానికి మొదటగా మనకు అంత
సమయం లేదు. మరియు రెండోది, మనము ఈ లక్షణం
ఎలా లేదా XML యొక్క విలక్షణమైన లక్షణాలు
ఏవి.
XML నేర్చుకోవాలని ఆసక్తి ఉన్నవారు
W3C స్కూల్  లేదా ఏదైనా ప్రామాణిక
పుస్తకంను అనుసరించవచ్చు, మరియు కొన్ని చిన్న
ప్రాజెక్టులను చేయదానికి ప్రయత్నించండి.
అయితే; ఈ విధమైన API లు విభిన్న స్టైలింగ్
లో ఉన్నాయి, వీటిలో వేర్వేరు ప్రోటోcall,
XML ఉన్న Web services  లు ఉన్నాయి.
here వేరే ఇతర రకాలు ఉండవచ్చు.
ఈ XML యొక్క వర్సటైల్  స్వభావం చూపించడానికి
ప్రయత్నిస్తుంది మరియు ఇది ఒక కొంపనీయన్
 టెక్నాలజి .
ఈ XML మరియు దాని community దిస్తృబుటెడ్ System లో దాని నిర్మాణాన్ని గుర్తించడంలో కీలక
పాత్ర పోషిస్తుంది.
సో, నేను దిస్తృబుటెడ్ System
ను ఇంటెరక్ట్  అవ్వడానికి కలిగి
ఉన్నాను మరియు soap మెసేజ్  ని ఉపయోగించి
కొమ్మునికేట్  అవుతాను, దీనితో
పాటుగా WSDL మెసేజింగ్, WSDL UDTI మొదలైనవన్నీ
ప్రధానంగా XML పై ఆధారపడి ఉంటాయి.
మనము mathml వంటి ఇతర నేమ్ స్payస్
లు కూడా ఉన్నాయి మరియు గ్రాఫిక్స్
సంభందిత విషయాలను ఉత్పత్తి చేయడానికి
SVG ఉంది. కాబట్టి, ఈ XMLData ట్రాన్స్ఫోర్మేషన్
 అనుమతించడంలో సహజంగానే వర్సటైల్
గా ఉంటుంది.
మరియు నేను ఈData ను రెప్రెసెంట్ 
చెయ్యాలి అనుకుంటే appపుడు నేను XSLT లేదా
కొన్ని XLD ద్వారా కొన్ని స్టైలింగ్
లు అవసరం అవుతాయి.
కొన్ని స్టయిల్ షీట్లు కూడాData ను రెప్రెసెంట్
 చెయ్యడానికి ఉపయోగపడతాయి; నేను
ఒక HTML ఫైల్, మరొక వైపు data ను చూడడానికి
రూపొందించవచ్చు.
మనం ప్రాథమికంగా చాలా ప్రాథమిక పరిచయ
విషయాలు లేదా XML యొక్క ప్రధాన భాగాల గురించి,
మరియు ఇంటెరోpayరబిలిటీ  ని రూపొందిచడంలో
ఈ కొంపోనెంట్స్ ఎలా తోడ్పడతాయి అనేవి
తెలుసుకున్నాం.
మీరు కొన్ని రకాల interfaceలు
ఇంటరాక్ట్ అవ్వడం లేదా ఇంటర్పోపెరాబిలిటీ
అవసరము ఉన్న cloud లేదా దిస్తృబుటెడ్
Systemను చూస్తే అక్కడ XML గుర్తించదగ్గ
de facto లాంగ్వేజ్ .
కాబట్టి, మనమిప్పుడు XML యొక్క ఈ బేసిక్స్గురించిన
చర్చను ఈరోజుతో ముగిస్తున్నామ్.
ధన్యవాదాలు.
                                                                  MODIFIED SENTENCE(FORMAL)
కొనసాగిస్తాము.
కాబట్టి, చివరి lectureను మీరు గుర్తుపెట్టినట్లయితే,
మనము XML బేసిక్స్ గురించి మాట్లాడుతున్నాము,
మనము ఏమినేర్చుకున్నాం అంటే, ఈ XML distributed
System లోని వివిధ ఇంటెరోpayrate
System లు లేదా కొ ఓపెరటివ్ 
System ల మధ్య ఇంటెరోpayరట్ 
చేయటానికి ఎలా అనుమతిస్తుంది అని. మరియు ఇది cloud
computingని ప్రత్యేకించి SaaS
cloudని లేదా Software as ఆ
service రకమైన cloud
కు ఎలా ప్రధాన వెన్నెముక లా ఉంటుంది.
మనము ఇంకా DTD మరియు XML స్కీమ XSD గురించి
చర్చించాము.
నేడు మనము XML యొక్క ఈ ప్రాథమిక అంశాలపై
చర్చను కొనసాగిస్తాము.
మనము XML స్కీమా గురించి ఏమి చర్చించామో
గుర్తుచేసుకున్నట్లైతే.
ఇది ప్రధానంగా XML యొక్క నిర్మాణాన్ని
నిర్వచిస్తుంది.
IIT Kharagpur లో ఒక నిర్దిష్ట బ్యాచ్ లోని ఒక
స్టూడెంట్Data ని XML లో ఉంచడం, ఇది
భారీ పరిమాణం లో ఉంటుంది.
ఇది మా ప్లేస్మెంట్ విభాగంలో లేదా మా
బ్యాంక్ అక్కౌంట్  విభాగంలో ఉంటుంది.
వారు ఈDataలో కొంత భాగాన్ని external
ఏజెన్సీలతో భాగస్వామ్యం చేయాలనుకుంటారు.
దదీనికి ఒక పరిష్కారం స్కీమాలో కొన్ని
భాగాలను పంచడం.
మరియు external ఏజన్సీలతో ఉన్న అంశాలలో భాగమని
చెప్pay ఒక మార్గం, లేదా వేరొక విధంగా
మీ institutionలోని data  ని ఇతర institution తో
పంచాలనుకోవడం.
అందువల్ల, ముందుగా అక్కడ ఉన్న data
కి ఏ స్కీమా అవసరం ఉంటుందో గుర్తుంచాలి.
కాబట్టి, వివిధ రిపోజిటరీల మధ్య ఇంటెరోpayరబిలిటీ
లో సహాయపడే సమాచార మార్పిడికి XML స్కీమా
కీలక పాత్ర పోషిస్తుంది.
కొత్త వివరణ, స్కీమ అనేది XML యొక్క వ్యాలిడేషన్
రూల్ ను payర్కొనడానికి 2001 లో వచ్చిన క్రొత్త
వివరణ.
మనం చూడగలిగినవి ఏ XML పార్సర్ని
మొదట ఇది సింటాక్తీకల్లి సరియైనదో లేదో, లేదా
వెల్ ఫోర్మ్ద్ ఆ కాదా పరిశీలించాలీ.
రెండవది, స్కీమా విషయంలో data వాలీడ్
అవుతుందా అని చెప్పుకోవాలంటే అది స్కీమతో తనిఖీ
చేస్తుంది.
కాబట్టి, దీనిని మనం వాలీడ్ అయ్యే
XML డాక్యుమెంట్ అంటాము.
మీరు చూడవచ్చు కొన్ని స్పెక్ మరియు ఉత్తమ
ఆచరణలో W3 వంటివి ఉన్నాయి.ఇది ప్యూర్ XML, ఇలా ఉండాలంటే
XML స్కీమా ని XML లో రాయాలి.
ఈ స్కీమాస్ మరింత powerfulవి మరియు
DTD లు ఇంటీజీర్  రకం, తేదీ, real 
రకం మొదలైనవి మరియు ఇతర పరామేటెర్స్
ను వాటిని payర్కొంటాయి.
వారు తరచూ టైప్ వాలిడేషన్  కోసం లేదా
XML బేస్ modelలనుData బేస్ స్కీమాస్కు సంబంధించిన అన్ని రకాలుగా ఉపయోగిస్తున్నారు.
మనకు స్కీమా తెలిస్తేDataబేస్ ను
create చెయ్యొచ్చు మరియు ఆ తర్వాత ఈ
XMLDataను ఈDataబేస్ కు లేదా ఇతర మార్గానికి
పంపుతాము, అయితే, మనము ఎనిటీటీస్ 
ని డిక్లేర్  చేయలేము; ఇవి DTD లో
మాత్రమే చేయవచ్చు.
కాబట్టి, ఎంటిటీలలో దీనిని నిర్వచించలేము.
మన డిటిడి లు ఆ స్కీమా ఎలా సమానం
అవుతాయో ఈ Slide  చూపిస్తుంది.
మీరు మొదటి తరగతి అంటే XML బేసిక్స్
లో గుర్తు పెట్టుకున్నట్లయితే చివరగా మనం చూసిన
డిటిడి మాదిరిగానే ఉంటుంది.
అదే విషయం ఇప్పుడు ఒక స్కీమాగా సూచించబడుతుంది.
కాబట్టి, మనము XML డాక్యుమెంట్ లో ఇంకా ఏమి చేస్తున్నామో
చూద్దాం.
మనము ఈ స్కీమాను నిర్వహించగలము అదే
విధంగా XMLDataని సరిగా నిర్వహించగలము.
XML యొక్క మరో ముఖ్యమైన అంశం XML నేమ్ స్payస్
; XM యూసర్ డిఫైన్డ్ data ను అనుమతిస్తుంది
ఇది చాలా ముఖ్యమైన అంశం. కాబట్టి, మనం
ఏ విధమైన నిర్వచనం ఉందో మరియు ఏం నేమ్
స్payస్ కావాలి అనేది జాగ్రత్తగా
చూసుకోవాలి.
మీకు చివరి చర్చ గుర్తు ఉంటే మేము
ఒక ఎంటిటీ call టేబల్  లేదా ఎలిమెంట్
call టేబుల్ డెఫినే  చేస్తే,
ఇది టేబల్  , ఏ రకమైన టేబల్  అనేది payర్కొనాలి.
మనము ఒక టేబుల్ ను కలిగి ఉన్నట్లుగా
మనం చెప్పుకున్నాం, ఆ ఫర్నిచర్ లేదా
టేబుల్ అనేది ఒక వర్డ్ Processor లేదా స్ప్రెడ్ షీట్  నుండి
కావచ్చు, దీని ఎలా చెప్పొచ్చు
అంటే, ఫర్నిచర్ రకానికి చెందిన ఒక
టేబల్ మరియు దాని డెఫినిషన్  ఒక
విధం గా ఉంటుంది, వర్డ్ processing రకానికి చెందిన టేబల్  మరియు దాని
డెఫినిషన్  మరొక విధంగా ఉంటుంది.
దీని అర్థం, నేను దీనిని ఎక్కడ నిర్వచించాను,
నేమ్ స్payస్ లో నిర్వచించాలి.
నేమ్ స్payస్ ఏ ఎలిమెంట్  ఉంది
, ఏ విధమైన డీలింగ్  లు, మోడైలన వాటి
గురిచి చెబుతుంది.
XML payర్ల కోసం వేర్వేరు స్payస్  లను గుర్తించడం,
అనగా ఎలిమెంట్స్  మరియు వాటి నేమ్
లు, కోసం ఇది ఒక పద్ధతి.
ఇది వేర్వేరు భాషా మాండలికాలను గుర్తించే
ఒక మార్గం, నిర్దిష్ట సెమాంటిక్స్
మరియు processing అర్ధాలను కలిగి ఉన్న
payర్లను కలిగి ఉంటుంది.
కీ అనేది ఒక లాంగ్వేజ్, ఒక నిర్దిష్ట security
కీ లాంటిది, మనము టేబల్  గురించి
మాట్లాడుతున్నప్పుడు, మరొక లాంగ్వేజ్
లో బహుశా ఒకDataబేస్ కీ  అంటారు.
కాబట్టి, కీ అనేది బహుశా ఒక విధమైన
security కీ మరియు మరికొన్ని
విషయాల్లో మనము వెతుకుతున్న కీDataబేస్
సంబంధిత కీ అయి ఉండవచ్చు.
ఈ రెండు కీలుDataబేస్ స్కీమ నుండి
ఒకDataబేస్ నేమ్ స్payస్ మరియు
మరొకటి ఈ security నేమ్  కోసం
స్payస్, నిర్వచించాల్సిన అవసరం ఉంది. కాబట్టి,
ఇది ఒక ప్రత్యేక XMLNS ఉపయోగిస్తుంది,
XML నేమ్  అంటే ఈ నేమ్ స్payస్ ని నిర్వచించడానికి
కావలసిన XML నేమ్ స్payస్ అట్రిబ్యూత్.
నేమ్ స్payస్ ఒక URL స్ట్రింగ్
లాగా ఇవ్వబడుతుంది, కానీ URL దేన్ని రిఫర్
 చేయదు, ఏదైనా ఉండవచ్చు.
కాబట్టి, ఇది దేన్ని సూచించలేదు.
కాబట్టి, నేమ్ స్payస్  , లాంగ్వేజ్
 డైలాగ్ల యొక్క మిశ్రమం.
ఈ విధంగా ఉంటే, నేమ్ స్payస్  ఇంతకంటే
సులభతరం చేయగలదా, నాకు రెండు కీలు
కావాలి.
dataబేస్ కీల నుండి నేనుDataబేస్
అన్లాక్ చేయడానికి సీక్రెట్ కీని
ఉపయోగిస్తాను, ఆపై యూజర్Dataబేస్ కీ ని access  చేయడానికి ఉపయోగిస్తాము.
మనము రెండూ కీ లను ఎక్కడో ఒకచోట ఉపయోగిస్తాము.
మరియు రెండూ XML లో ఉన్నాయి, ఈ XML నేమ్
స్payస్ dataబేస్కీ  లేదా security
కీ లేదా కొన్ని ఇతర కీ అనుమతిస్తుంది.
here ప్రధానంగా కీ రకం payర్కొనబడిఉంది.
అంటే, here మీరు చూస్తే ఈ నేమ్ స్payస్
 డిfault నేమ్ స్payస్.
ఇది W3C చేత నిర్వచించబడింది, అయితే, ఈ నేమ్ స్payస్
ఖాళీ అనేది ఒక గణిత సంబంధిత నేమ్స్payస్.
ఇది కూడా ప్రీ డిఫైన్డ్, కానీ ఖాళీగా ఉన్న
ఒక గణిత సంబంధిత నేమ్payస్ అని
నేను చెపుతాను.
ఇప్పుడు నేను ఈ ప్రత్యేక మ్యాత్ రేలాటెడ్
తో ఏదైనా చేస్తే appపుడు నేను ఖాళీ
డబుల్ కోలన్ mathml మరియు టైటిల్
మొదలగునవి చెప్తాను.
నేను ఈ గణిత నేంస్payస్ ను రిఫర్  చేస్తాను.
కాబట్టి, ఈ ఎంప్టీ ప్రేఫిక్స్ 
mathml, డిఫరెంట్ లాంగ్వేజ్  ఒక అనే స్payస్
 ని సూచిస్తుంది.
ఇది completely విభిన్నమైన భాష మరియు నా డాక్యుమెంట్లో
ఆ ప్రత్యేక నేమ్payస్ యొక్క ఆ అంశాలకు
నేను ప్రాథమికంగా ఉపయోగించగలగాలి.
ఈ విధంగా, మనము చూస్తున్నట్లుగా నేమ్ స్payస్
ఒక ముఖ్యమైన పాత్ర పోషిస్తుంది మరియు
మీరు జాగ్రత్తగా ఉండాలి, మరియు నేమ్
స్payస్ నిర్వచనాలు అక్కడ ఉండాలి.
కాబట్టి, ఇతర మాటల్లో చెప్పాలంటే, మనం
చూస్తున్నప్పుడు మనమిప్పుడు ఏమి చేస్తున్నామో
చూద్దాం, ఆ ప్రత్యేక నేమ్payస్ చూసి
అది ఎలా ఉపయోగించాలో మొదలైన విషయాలను
తెలుసుకుంటాం.
ఇంతకుముందు మరో ముఖ్యమైన అంశాలను మేము చర్చించాము
వాటిలో కొన్ని XML Software.
కాబట్టి, XML డాక్యుమెంట్  టెక్స్టువల్
 మోడ్ లో ఉంటుంది.
నేను దానిని ప్రాసెస్ చెయ్యాలి.
దీనిలో మొదటగా, ఇది వెల్ ఫోర్మ్ద్  లేదా సింటాక్తీకల్లి కరెక్ట్  గా ఉందా
లేదా అని వాలిడేట్చెయ్యాలి.
రెండవది, వేర్వేరు applicationలకు
ప్రాసెస్ చేయవలసిన అవసరం ఉంది. కాబట్టి,
ఈ XML Software ఒక ముఖ్యమైన పాత్ర
పోషిస్తుంది.
కాబట్టి, XML పార్సర్ , XMLData  ను రీడ్
 చేసుకుని DTD మరియు స్కీమా కన్స్త్రైంట్స్
 తో సింటాక్స్ చెక్  చేస్తుంది
మరియు ఈ మొత్తంDataను ఒక application 
కి అందుబాటులో ఉంచుతుంది.
మూడు సాధారణ XML API లు లేదా పార్సర్
API లు ఉన్నాయి.
అందులో ఒకటి, XML SAX పార్సర్, ఇది ఒక సాధారణ XML ఈవెంట్
బేస్డ్ API, ఇది చాలా ప్రజాదరణ పొందిన
విస్తృత పార్సర్ గా మరియు ఎక్కువగా
అన్ని ప్లాట్ఫారమ్ లలో అందుబాటులో ఉంటుంది.
రెండవది DOM పార్సర్, డాక్యుమెంట్ ఆబ్జెక్ట్
model లేదా ఆబ్జెక్ట్ ట్రీ  ఆధారిత పార్సర్.
చివరిది, JDOM పార్సర్ లేదా java DOM పార్సర్.
ఈ XML పార్సర్ మరియు interface Software లు అధికముగా వివిధ ఆపరేటింగ్
Systemsలో అందుబాటులో ఉంటాయి.
SAX ఆధారిత పార్సర్లు  మనము తరచుగా
పంpayData స్ట్రీమ్  వేగంగా లాగే
ఉంటాయి మరియు ఇవి చాలా తక్కువ కపాసిటీ
 ఉన్న పార్సెర్ మరియు ఇవి చాలా ఎక్కువ
వేగంతో పనిచేసినా కూడా తక్కువ ఫంక్షనాలిటీలను
 కలిగి ఉంటాయి.
DOM చూసినట్లైతే, ఇది స్లోయర్  పార్సర్
, అధిక మెమరీ ఇంటెన్సివ్ , మొత్తం డాక్యుమెంట్
 యొక్క మెమొరీ వర్షన్  ని
create  చేస్తుంది.
వాలిడేటింగ్ పార్సర్ అనేది నోన్ వాలిడేటింగ్
పార్సర్ కంటే చాలా నిదానముగా ఉంటుంది,
ఎందుకంటే వాలిడేటింగ్ పార్సర్,
ప్రొసెసింగ్  కి వెళ్ళే ముందు
స్కీమా  కు అది అనుకూలంగా ఉందో లేదో
వాలిడేట్  చేస్తుంది.
వేర్వేరు పార్సర్స్ గురుంచి చూశాం అందులో
SAX పార్సర్ అందుబాటులో ఉన్నట్లయితే, ఇది
ఈవెంట్ ఆధారిత interface, పార్సర్,
టాగ్ అట్రిబ్యూట్  /టెక్స్ట్
node / పరిష్కరించనిఎ క్ష్టెర్నల్
ఏంటీటి లు మొదలైనవి చూసినప్పుడల్లా
ఈవెంట్స్ని రిపోర్టు  చేస్తుంది.
ప్రోగ్రామర్లు ఈవెంట్స్ని నిర్వహించడానికి
ఈవెంట్ హ్యాండ్లర్లను అటాచ్ చేస్తారు.
ప్రయోజనాలు.
ఇది ఉపయోగించడానికి చాలా సులభం, చాలా
వేగంగా ఉంటుంది.
మరియు టెక్స్ట్,Data పొందుటకు
ముందు ఎక్కువగా కష్టపడనవసరం లేదు. కాబట్టి, ఇది
చాలా ఫాస్ట్ , తక్కువ మెమరీ.
కాబట్టి, ఇది తక్కువ payload ని కలిగి
ఉంటుంది.
ప్రతికూలతలు, ఎక్కువ processing 
చేయవు.
కాబట్టి, మీరు మీ దగ్గర కొన్ని processingలను
చేయవలసి ఉంటుంది.
మీరు డైనమిక్ గా సవరించే డాక్యుమెంట్
వరల్డ్ సిరీస్ మీ మెమొరీ
లో ఉన్నట్లైతే ఇది అంత ఉపయోగకరం కాదు.
కనుక, మీ డైనమిక్ డాక్యుమెంట్
లు సవరించడానికి అది ఉపయోగకరంగా లేదు.
ఎందుకంటే ఇది మెమొరీ , దానికి జ్ఞాపకశక్తి
ఉంటుంది, మీ మొత్తం ప్రొసెసింగ్ 
చేసి మెమొరీ లో పెట్టుకోవచ్చు.
కనుక, ఇది ఒక వనిల్లా రకం XM processing
అవసరాన్ని కలిగి ఉన్నప్పుడు ఇది ఉపయోగకరంగా
ఉంటుంది మరియు తక్కువ మెమరీ తో, ఫాస్ట్
గా మరియు ఉపయోగించడానికి సులభం గా ఉంటుంది.
డాక్యుమెంట్ ఆబ్జెక్ట్ model లేదా DOM పార్సర్
అయినప్పటికీ అది ఒక ఆబ్జెక్ట్ 
ఆధారిత interface.
పార్సర్, XML డాక్యుమెంట్ కు అనుగుణంగా మెమరీ
ట్రీలో లేదా మెమరీ XML ట్రీ
లో ఉత్పత్తి చేస్తుంది.
DOM interface  అనేది ట్రీ ని
access మరియు సవరించడానికి ఒక
పద్ధతిని గుర్తిస్తుంది.
కాబట్టి, ట్రీ ని డైనమిక్ గా
సవరణ మరియు access చేయడానికి ఇది ఉపయోగకరంగా
ఉంటుంది.
ట్రీ కి డైనమిక్ సవరణ access
ఉంటే, అది చాలా ఉపయోగకరంగా ఉంటుంది,Data
కోసం చూస్తున్న ప్రశ్నకు ఉపయోగకరమైనది, అది
ట్రీ నిర్మాణం మీద ఆధారపడి ఉంటుంది.
కాబట్టి, క్వెర్రియింగ్ ఎందుకంటే ఇది ఒక
ట్రీ  నిర్మాణంగా ఉంటే అది ఉపయోగకరంగా
ఉంటుంది.
ఇది అనేక ప్రోగ్రామింగ్ లాంగ్వేజ్
అయిన C++, JAVA కి అదే interface.
నష్టం తక్కువగా గా ఉంటుంది.
ట్రీ ని ప్రొడ్యూస్  చెయ్యడం మరియు
ఎక్కువ మెమరీ అవసరం అవుతుంది.
DOM ప్రోగ్రామింగ్ interface
ఇక ఆ స్టేట్  కి రాలేదు.
కాబట్టి, ఇది కొంచెం సంcomplexగా ఉండి
మరియుDataను professional హ్యాండ్లింగ్ , ఈ ప్రోగ్రామింగ్ ను నిర్వహించాల్సిన
అవసరం ఉంది.
ఒక DOM పార్సర్ విషయంలో ఈ పార్సర్ interface
లో ట్రీ యొక్క ఈ నిర్మాణంకి వెళుతుంది.
JDOM లేదా java DOM అనేది java ఆధారిత ఆబ్జెక్ట్
ఓరియెంటెడ్ .
ఇది DOM తో సమానంగా ఉంటుంది; ఇది java నుండి
వచ్చింది.
పార్సర్ డాక్యుమెంట్  అనుగుణంగా మెమొరీ ని ప్రొడ్యూస్ చేస్తుంది.
JDOM interface  ట్రీ ని access
 చేయడానికి మరియు సవరించడానికి, పద్ధతులను
కలిగి ఉంది. అందువల్ల, ట్రీ ని access
చేయడం మరియు సవరించడం జరుగుతుంది,ప్రయోజనాలు.ఇది
ఎంతో ఉపయోగకరం.
ట్రీ యొక్క డైనమిక్ సవరణ ట్రీ నిర్మాణ
ఆధారిత క్వార్ర్యింగ్  కి ఉపయోగపడుతుంది.
కాబట్టి, మీ క్వెర్రి , ట్రీ నిర్మాణంపై
ఆధారపడి ఉంటే అది చాలా వేగంగా మరియు
ఉపయోగకరమైనది.
DOM కంటే చాలా బాగా ఉండే ఆబ్జెక్ట్ ఓరియంటెడ్
ప్రోగ్రామింగ్ interface ను కలిగి
ఉంటుంది.
కనుక, దీనికి చాలా ప్రోగ్రామింగ్ interface ఉందని అర్థం ఉంది. ప్రతికూలతలు
తక్కువ, కొత్త కొత్త అంశాలు ఉంటాయి ఈ
రోజుల్లో కొత్త విశయాల పై పనిచేయడానికి
మీరు కకొంత నైపుణ్యం అవసరం మరియు అది
JAVA పై పని చేస్తుంది, అది బహుశా ప్రతికూలంగా
ఉంటుంది లేదా మీరు పని చేయటానికి JAVA
గురించి తెలుసుకోవచ్చని మేము అనుకోవచ్చు
. ఒక పెద్ద problem.
here DOM4J లాంటి ఇంకా కొన్ని ఉన్నాయి,
నావిగేషన్, రాయడం, చదవడం మరియు XML సరిదిద్దడం
కోసం ఇది ఒక java ఫ్రేమ్work.
SAX, DOM, JDOM interface మరియు XSLT లాంటి ఇతర
రకాలైన interface వంటి ఇతర XML institutionలకు
access ని అందిస్తుంది, మిశ్రమ SAX, DOM పార్సింగ్
చేయవచ్చు.
ఇందులో కొన్ని ప్రయోజనాలు ఉన్నాయి, అన్నిటికి
ఇది చాలా బాగా ఉపయోగపడుతుంది.
అన్ని JAVA ప్యాకేజీలో ఒక కలెక్షన్
గా ఉంటాయి.
SAX మరియు DOM పార్సర్ అపాచీ open source
లైసెన్స్ చేయవచ్చు, ఉచితంగా
ఉపయోగించవచ్చు.
ప్రతికూలతలు here కూడా java నే ఉపయోగిస్తాము
మరియు కొన్ని విషయాల యొక్క open sourceఅయితే ఇది మంచిది కాదు.
Xerces మరియు XML టూల్కిట్, C కొరకు XML మొదలైనటువంటి
XML పార్సర్ లు ఉన్నాయి.
cloud  వంటి కొన్ని దిస్తృబుటెడ్ System
 లో పరస్పరం అనుసంధానించినప్పుడు
మా సంవిధానంలో మరింత సంcomplex కార్యకలాపాలను
చేయటానికి కూడా బాగా రూపొందించినవే కాకుండా
ధృవీకరించినవిగా కూడా ఎక్కువ సంఖ్యలో
XML పార్సర్ లు ఉన్నాయి.
పార్సర్ ఎలా ఉంటుందో వంటి బెంచ్మార్క్లు
కొన్ని ఉన్నాయి, స్పీడ్ మెమరీ
మరియు స్ట్రీమ్ processing గురించి, కొన్ని
ఉన్నాయి.
XML processing లో మరో ముఖ్యమైన
అంశం XSLT. ఇది ఎక్ష్టెన్సిబుల్ స్టయిల్ షీట్ లాంగ్వేజ్
.
XML ఎలా రెప్రసెంట్ చేస్తుందో ఈ స్టయిల్
షీట్ ద్వారా ఇవ్వబడుతుంది.
మరో అర్థంలో, మనం స్టైలింగ్తో
పాటు XML దానిని రెప్రసెంట్  లేదా డిస్ప్లే
 చేయడానికి అనుమతిస్తుంది.
కొన్నిtimes కారెక్టర్ పరమ్ గా XML ప్లస్ XSLT
అనేది HTML రకంకి సమానమైనది.
కాబట్టి XSLT ఎక్స్టెన్సిబుల్ స్టైల్ షీట్ లాంగ్వేజ్
ప్రధానంగా ట్రాన్స్ఫోర్మేషన్  కోసం ఉపయోగిస్తారు.
లేదా అది పరివర్తన రకాన్ని మరింతగా
కలిగి ఉంది.
XMLDataను ప్రాసెస్ చేయడానికి XML లాంగ్వేజ్
, XML మరియు XSLT స్టైల్ షీట్ ని inపుట్
గా తీసుకుని ట్రీ  ట్రాన్స్ఫోర్మేషన్
 చేస్తుంది.
విభిన్న నిర్మాణం మరియు విషయాల రకంతో
ఒక కొత్త XML డాక్యుమెంట్ ని ఉత్పత్తి చేస్తుంది.
కాబట్టి, ఇది XSLT గా ఉంటుంది.
మనం సాధారణం గా XSLT లో ఒక విధమైన ఫిల్టర్
operation  లు చేయవచ్చు.
కాబట్టి, ఇది XMLDataను తీసుకుంటుంది, దాన్ని
ప్రాసెస్ చేస్తుంది మరియు మరోవైపు వేరొక
XMLDataను జనrate  చేస్తుంది మరియు
ఒక కొత్త XML డాక్యుమెంట్ని వేర్వేరు నిర్మాణంతో
చేస్తుంది.
ప్రయోజనాలు, ట్రీ  ట్రాన్స్ఫోర్మేషన్
 లకు చాలా ఉపయోగకరంగా ఉంటాయి; కాబట్టి,
నేను ట్రీ ని ట్రాన్స్ఫోర్మ్  చెయ్యాలనుకుంటున్నాను,
మరియు నా application  కోసం నేను దాని
యొక్క సబ్ ట్రీ ని ఉపయోగించడానికి
కావాలి.
ఇది నేను ఎలా చేయగలను?
కాబట్టి, ఈ XSLT ను ఉపయోగించి ఫిల్టేరింగ్ 
చేస్తాను, ఆపై ఇతర భాగాలకు ఫిల్టర్
చేయగలను.
కనుక, ప్రతికూలతలు, large డాక్యుమెంట్స్
లకు లేదా స్టయిల్ షీట్  లకు ఇది
శ్లో  గా ఉంటుంది, స్టైల్ షీట్ డీ బగ్
 చేయడం కష్టం, ఎర్రర్ డిటెక్షన్ ,
మొదలైనవి శ్లో  గా ఉంటాయి.
ఎర్రర్ డెటెక్షన్ లో ఇది అంతా
వర్సటైల్  కాదు. కాబట్టి ఇప్పుడు,
మీరు పై చిత్రాన్ని చూస్తే.
XMLData వస్తోంది.
ఇప్పుడు మనము ఒక స్టయిల్ షీట్
కలిగివుంటే అది మరొక XML పార్సర్ ని కలిగి
ఉంటుంది.
మరియు అది ఈ Processor, processing
unitకి వెళుతుంది.
ఈ వేరొక ట్రీ ని కలిగి ఉంటాము.
కాబట్టి, నేను here ట్రీ  ని మరియు
ఆక్కడ ట్రీ  యొక్క ఒక పార్ట్ ని కలిగి
ఉన్నాను, వీటిని inపుట్గా తీసుకుంటే
out పుట్ data అనేది XML, XSLT ఆధారంగా
ఫిల్టర్  చేయబడి కొత్త XML data  ని
ఉత్పత్తి చేస్తుంది.
XML మెసేజింగ్, వ్యవస్థల మధ్య సందేశాలను
పంపడానికి ఫార్మాట్గా XML ను ఉపయోగిస్తుంది.
ప్రయోజనాలు, ఒకే రకమైన సింటాక్స్
, సెల్ఫ్ దిస్క్రైబింగ్  సులభంగా వివరించే
HTTP etc వంటివి XMLDataను తరలించడానికి ఎక్షిస్టింగ్
లో ఉన్న సాధారణ ట్రాన్స్పోర్ట్
విధానంను ఉపయోగించవచ్చు.
dataను బదిలీ చేయడానికి XML కి క్యారియర్ ప్రోటోcall అవసరం.
అందువల్ల, మనము ఏదైనా data ట్రాన్స్పోర్ట్ పద్దతిని ఉపయోగించాలి.
ఇది మరి ఏ ఈతర ట్రాన్స్పోర్ట్ లేయర్  ప్రోటోcallల
తో కలసి ఉండకూడదు.
కనుక, అది ఒక ట్రాన్స్పోర్ట్  విధానం అంటే
network క్రింద ఉంటుంది మరియు మనము
http, https, SMTP మొదలగునవి ఉపయోగించవచ్చు.
ఈ విధమైన XML మెసేజింగ్ యొక్క కొన్ని అవసరాలు
మరియు appరయోజనాలు ఉన్నాయి.
మరియు సాధారణ సందేశ modelలు ఉన్నాయి.
కాబట్టి, XML సందేశాలు కోసం ప్రోటోcallకు
HTTP ను ఉపయోగించడం, XML లో ఈ XML సందేశాలు
మీరు చూసినట్లయితే ఈ అంశాన్ని ఈ భాగం
ఒక ప్రామాణిక ప్రోటోcall, http ప్రోటోcall యాంత్రికాలు
అని payర్కొన్నట్లయితే.
అయితే, ఇది XML సందేశం లేదా XML పత్రం విషయాలు
లోకి పొందుపర్చబడింది.
సో, అది ఒక కవరు అని ఇది HTTP ప్రోటోcall
మరియు తరువాత అది stuff లోకి ఎంబెడెడ్.
XML-RPC వంటి మెసేజ్ ఫార్మాట్కి కొన్ని ప్రమాణాలు
ఉన్నాయి.
కాబట్టి, ఎన్కోడింగ్ ఫంక్షన్ పద్ధతి
యొక్క చాలా సరళమైన మార్గం నేమ్  ను
call చేసి దాన్నిని మరొక చోటికి పాస్
 చేయడం వంటివి.
సమాచార ఫార్మాట్లలో ఒకటి, సోప్, సింపుల్
ఆబ్జెక్ట్ ఓరియెంటెడ్ access ప్రోటోcall
 ఇది ప్రధానంగా Web
serviceల్లాంటి service ఆధారిత నిర్మాణంలో ఉపయోగించబడుతుంది.
కాబట్టి, ఇది మరింత సంcomplex రేపర్
మీరు interface కోసం మరింత complex
నియమాలను నిర్వహించడానికి మరియు ప్రాక్సీ
సందేశాలను మరియుస్వాగతం, నేడు మనము cloud computingకి మూల కారకమైన మరియు దీని యొక్క
బిల్డింగ్ బ్లాక్ లో ఒకటిగా పరిగణించబడే
Web service లు మరియు service ఓరియెంటెడ్
architecture  ల గురించి
చూద్దాం.
సరిగ్గా దీని అర్థం ఏమిటో మనము చూద్దాం
మరియు మొత్తం ఒవెర్వ్యూ ని తెలుసుకోవడానికి
ప్రయత్నిద్దామ్.
ఇలా చేయడం వల్ల మనం cloud ని ఎలా నిర్మించాలో
తెలుసుకుంటాం.
Web services  అనగా ఏమిటి?
దీనికి అనేక వివరణలు ఉన్నాయి, మీరు లిటరేచర్
 మరియు internetలో కనుగొంటారు.
కాబట్టి, మీరు W3C Web Service architecture రిక్వైర్మెంట్స్  స్పెసిఫికేషన్
 చూసినట్లయితే, అది ఒక URI చే గుర్తించబడిన
Software application, దీని interfaceలు
మరియుByండింగ్లు XML ఆర్టిఫక్ట్స్ ని
గుర్తిస్థాయి.
ఇది చాలా వర్సటైల్ నిర్వచనం.
కాబట్టి, ఇడి URI మరియు దీని interface
లు లేదాByండింగ్స్ గుర్తించగల సామర్ధ్యం
ఉన్న software applicationలు ను కలిగి ఉంటుంది, కనుక, దీనిని ఉపయోగించి
మీరు XML ఆధారిత లాంగ్వేజ్ లను ఉపయోగించి
నిర్వచించగలవు, మీరు కనుగొనవచ్చు.
అయితే microsoft ను చూసినట్లైతే,
ఇది ఒక ప్రామాణిక internet ప్రోటోcallని ఉపయోగించి access  చేయగల
ప్రోగ్రామబుల్ application లాజిక్గా డెఫినే  చేయబడి ఉంటుంది.
IBM ఇచ్చిన మోరోకా నిర్వచనం, Web service
 operation  ల కలెక్షన్ ని
వివరించే ఒక interface , అనగా XML మెస్సేజింగ్
 ద్వారా access  చేయబడే network
అని అర్థం.
కాబట్టి, ఈ విభిన్న రకాల నిర్వచనాల నుండి
మనము చూడదగినది ఏమిటంటే ఒక విషయం, అది ఒక XML
ఆధారిత ఫెనిమిన .
మనకు తెలిసిన XML ఇది ఎక్కువData ట్రాన్స్ఫర్మేషన్
లాంగ్వేజ్ , ఇది ఇంటర్పోపరాబిలిటీలో
సహాయపడుతుంది మరియు applicationలు
ఒక దానితో ఒకటి కమ్యూనికట్  అవ్వడం లో సహాయపడుతుంది.
అందువల్ల, Web service లు అనేవి అందుబాటులో
ఉన్న service ల రకాలు, ఇవి URI ను ప్రామాణీకరించడం
ద్వారా అందుబాటులో ఉంటాయి మరియు ఇది
XML ఆధారిత మెసేజ్ ఎక్స్ఛేంజి ప్రోటోcallపై పనిచేస్తుంది.
ఇది ఇచ్చేది ఏమిటంటే ఒక application 
మరొక application  తో ఎలా అనుసందనీచబడి
ఉంటుంది, here మనము బాక్ గ్రౌండ్ 
ప్రాసెస్  గురించి ఏమాత్రం బాధపడటం
లేదు, మనము పట్టించుకోవలసింది service  ఎక్కడ
లభిస్తుంది, దాని మనము ఎలా పొందాలి
అనేది మాత్రమే.
ఇది ఇతర application లు మాట్లాడటానికి
ఈ లెగసీ application తీసుకురావడానికి
కూడా సహాయపడుతుంది.
మరొక మార్గంలో మనము చూస్తున్నాం, మరింత
టైట్లీ కాపుల్డ్  ప్రోటోcall
యొక్క client server రకం తో, వారు మరింత
లూస్లీ కాపుల్డ్  client
 చాలా సులభంగా ఇంటెరక్ట్  అవ్వవచ్చు.
ఈ Web service  లను ప్రచారం చేయటానికి
లేదా ప్రోత్సాహించే వివిధ కోణాలలో ఖచ్చితంగా
స్ట్రక్తర్డ్ ప్రోగ్రామ్మింగ్  ఒకటి, ఇది
మన మునుపటి ఉపన్యాసాలలో చర్చించుకున్నట్లుగా
ఆబ్జెక్ట్ ఓరియెంటెడ్ ప్రోగ్రామింగ్, distributed సిస్టం కు
మరో అంశం గా పుట్టుకొచ్చింది.
కాబట్టి, ఇది ఒక ముఖ్యమైన పాత్ర పోషిస్తుంది.
here మనం చూడవలసిన మరొక అంశం రెండు
ఏంటీటీ ల మద్య, ప్రధానంగా వ్యాపార
institutionల మధ్య ఎలక్ట్రానిక్Data ఎక్స్ఛేంజి
 ఒక నిర్దిష్ట ప్రయోజనం కోసంDataను
అనుసంధానించాలనే మరొక భావన ఉంది. అయితే,
ఈ వరల్డ్ వైడ్ Web మొత్తం computing
ఫెనొమెనా internetను ప్రోటోcall
తో ఒకరికొకరు connect అవ్వడానికి అనుమతిస్తుంది.
ఇలాంటి కొంపోనెంట్స్  ని కలిగి ఉన్నాయి;
ఇప్పుడు Web service లు లేదా Web
service ల యొక్క పరిణామాల యొక్క ఈ
developmentని మేము సులభతరం చేశాము.
ఇప్పుడు distributed computing గురించి ఎక్కువగా చూడడంలేదు, ఎందుకంటే
మనము మన పూర్వ ఉపన్యాసాలలో విస్తారంగా నేర్చుకున్నాం.
డిస్ట్రిబూటింగ్ computing  చేస్తున్నప్పుడల్లా ఇంటెరోpayరబిలిటీ
 అనేది ప్రధాన problemల్లో ఒకటి;
కనుక, వివిధ వెండార్స్ లు కమ్యూనికేట్
అయ్యి data, Software మొదలైన వాటిని వివిధ
platform లతో share  చేసుకునే
సామర్ధ్యం అనేది చాలా ఆసక్తికరమైన
ఫెనొమిన .
ఈ మొత్తం ప్రపంచ లేదా అనువర్తనం యొక్క
మొత్తం స్వరసప్తకం మీరు ఇతర వెండార్స్
నుండి platformలుData, Software
కమ్యూనికేట్ చేస్తూ share  చేయడానికి
అనుమతిస్తుంది.
ఇంటెరోpayరబిలిటీ  విషయంలో,
సంప్రదాయ ajamanya distributed
computing టెక్నాలజీస్
తక్కువ స్కోప్  ఉంటుంది.
limited స్కోప్ల సందర్భంలో, దీనిని విస్తరించాల్సిన
అవసరం ఉంది.
ఈ ప్రాంతంలో మరొక ప్రధాన development
అంటే EDI లేదా ఎలక్ట్రానిక్Data ఇంటర్చేంజ్, జాతీయంగా అంతర్జాతీయంగా గుర్తించబడిన
ప్రమాణాలను ఉపయోగించి company ల మధ్య business
data మరియు డాక్యుమెంట్
లను ఒక computer నుండి మరొక computer
కి మార్పిడి చేయడం.
అంటే, ఇది ప్రధానంగా వ్యాపారData లేదా
ఫార్మాట్లలో ఉంటుంది, కానీ ఫార్మాట్లను
రెండు partyలు గుర్తించగలగాలి.
కాబట్టి, A వ్యవస్థ అర్థం చేసుకకుంటుంది;
ఏ రకమైన సందేశం institution B నుండి వస్తున్నది
అని మరియు తరువాత మార్పిడి జరుగుతుంది.
EDI లో ఉపయోగించే సమాచారం రెండు companyలు ఎక్స్ఛేంజ్
పాల్గొనే ఒక నిర్దిష్ట ఫార్మాట్ ప్రకారం
నిర్వహించబడుతుంది.
కాబట్టి, ఫార్మాట్ లేదాData మార్పిడికి
ముందుగా ఫార్మాట్ లేదా స్కీమా ఎక్స్ఛేంజ్ ఎలా మార్పిడి చేయాలో లేదా ఫార్మాట్
ని కొంతవరకు ముందుగానే తెలుసుకుంటారు.
కాబట్టి, ఏ విధమైనData ఉండవచ్చు
అనేది partyకి తెలుసు.
ఇందులో ఎక్కువ ప్రయోజనాలు ఉన్నాయి: అందులో
ఒకటి తక్కువ ఆపరేటింగ్ కోస్ట్ .
data ఎప్పుడు ఎక్స్ఛేంజి అవుతుందని పట్టించుకోనవసరం
లేదు. ఈ లావాదేవీలు చాలా తక్కువగా ఉండటం
వలనData తక్కువగా ఉన్నData మరింత
ఖచ్చితత్వాన్ని మార్చుతున్నప్పుడు
మీరు తక్కువ శ్రమ ఖర్చుతో కూడుకున్నందున
లాభాలు చాలా ఉన్నాయి.
కాబట్టి, data ఎంట్రీ ఉండదు, తక్కువ మానవ
లోపం. కాబట్టి, నేరుగా ఇతర విషయాల నుండి
సమాచారాన్ని పొందడం వలన ప్రోడుక్తవిటి
 పెరుగుతుంది.
అనేక companyలు కలిసి పని చేస్తే ట్రేడింగ్
సైకల్ అనేది ఫాస్ట్ గా ఉంటుంది.
ఇప్పుడు మేము అన్ని విషయాలు కారణం Web
services గురించి చర్చించడానికి.
ఆబ్జెక్ట్ ఓరియంటెడ్ ప్రోగ్రామింగ్ ప్రయోజనాలను ఉపయోగిన్చి, ఒక మాడ్యులర్
విధానం లో, ముందే ఉన్న Software
నుండి కొత్త application నిర్మించడానికి
డెవలపర్ లను ఎనేబుల్ చేస్తుంది.
కాబట్టి, డెవలపర్, application
లను development చేయడానికి, లెగసీ Software లేదా ఇప్పటికే ఉన్న Software
 నుండి సహాయపడుతుంది మరియు ఒక మాడ్యులర్
పద్ధతిలో వివిధ అంశాలను development చేయడానికి
వారికి వివిధ అంశాలకు సహాయపడుతుంది.
ఒక network లేదా internet
ని, డెవలపర్లకి  అందుబాటులో ప్రోగ్రామటిక్
భాగాలతో కూడిన లైబ్రరీగా ట్రాన్స్ఫోర్మ్
చేస్తే, significant ఉత్పాదకత లాభాలు
కలిగవచ్చు.
కాబట్టి, మనము ఒకవేళ వేర్వేరు ప్రోగ్రామింగ్
భాగాల లైబ్రరీ అక్కడ ఉన్నట్లయితే, ఇప్పుడు
మీ application ను నిర్మించుకోవచ్చు.
కాబట్టి, ఈ రకమైన ఉదాహరణ ఏమిటంటే మేము
ఈ service లను ఎలా మార్పిడి చేస్తాం,
మనము ఈ on లైన్ రిజర్వేషన్లు లేదా బుకింగ్
వ్యవస్థలు, నేను ఒక రైలును లేదా ఫ్లైట్
ను book చేస్తాను.
అందువల్ల, మేము access చేయడానికి ఒక ప్రత్యేక
అడ్రెస్ ను లేదా URI ను ఉపయోగించినప్పుడు
ఆ ప్రత్యేకమైన ప్రయాణ పోర్టల్ విమానాలను,
హోటేల్స్ ను కలిగి ఉండకపోతే కనుక, ఇతర
వేర్వేరు ఎయిర్లైన్స్ service లకు
consumerని ఎంపికలను చూపించి, బుకింగ్
ప్రక్రియ కొనసాగిస్తే అది క్రెడిట్ కార్డు లేదా డెబిట్ కార్డు లేదా నెట్ బ్యాంకింగ్ ద్వారా ఇతర service లకు వెళ్తుంది.
అంటారు.
కాబట్టి, మీరు చూసినట్లయితే, ఒక ఉద్యోగం అమలు
చేయడానికి సరైన కొరియోగ్రాఫిక్ మార్గంలో అనేక service
లను సమ్మేళనం చెయ్యాలి.
కాబట్టి, నా బడ్జెట్ మరియు నా సౌలభ్యం
ఆధారంగా ఉత్తమ విమాన service ని ఎంచుకోవడం
నా పని , మరియు నేను onలైన్ లో సెలెక్ట్
చేయాలనుకుంటున్నాను.
కనుక, నేను ఒక ట్రావెల్ పోర్టల్  కి
లేదా బ్రోకర్ , ఎడైతే వివిధ ఎయిర్లైన్స్
విషయాలను చూడడానికి అనుమతిస్తుందో దానిని
మనము ఉపయోగించుకుంటాము.
మరియు నేను నా క్రెడిట్ కార్డు, డెబిట్
కార్డుమొదలైన వాటి ద్వారా చెల్లించి
నాకు అనుకూలమైన వాటిని ఎంచుకుంటాను.
తర్వాత నేను ticket ను పొందుతాను.
కాబట్టి, ఈ ఎయిర్లైన్స్ institutionలు డైరెక్ట్
గా తెలియవు; నేను వాటిని నేరుగా దాచడం
లేదు, వారు మీ క్రెడిట్ కార్డు లేదా
డెబిట్ కార్డు service providerతో ఏ విధంగానూ connect చేయబడటం లేదు, మీరు
ticket purchase చేస్తున్నారన్నదాని
గురించి ఏవైనా క్లూ కలిగి ఉంటారు.
కాబట్టి, అది ఒక నిర్దిష్ట రూపంలో ఒక అభ్యర్థన
పొందినట్లయితే, అది దానిని గుర్తించి,
దానిని ఒక ప్రత్యేకమైన రూపం లో సమాధానం
ఇస్తుంది.
దీని అర్థం, ఇది ఒక విధమైన XML రకం సందేసం,
విషయాల మార్పిడి జరగబోతోంది.
కాబట్టి, ఇది వేరొక రకపు వేర్వేరు రకాలైన
Software కొంపోనెంట్స్ లను లేదా వేర్వేరు
రకాలైన ఇతర applicationలను ఉపయోగించి వివిధ
రకాలైన మెగా applicationలలను ఉత్పత్తి చేయటానికి
ఇది అనుమతిస్తుంది.
సో, నేను మిక్స్ మరియు మ్యాచ్
చేస్తూ మరియు అది వివిధ service provider ల యొక్క తక్కువ ప్రమేయంతో ఒక choreographic
మార్గం జాబితాలో వెళుతుంది.
కాబట్టి, open కాని ajamanya ప్రమాణాల
ద్వారా distributed computingలో ఇంటర్పోపెరాబిలిటి ని మెరుగుపరచడం మీరు
చూస్తే; ఇది theoretically ఏ రెండు లేదా అంతకంటే
ఎక్కువ Software భాగాలు 99కమ్యూనికేట్
చేయడానికి వీలు కల్పిస్తుంది; కాబట్టి, ఇది XML మరియు
దాని విషయాల గురించి మనము చర్చిస్తున్నందున
అది open standard మరియు సులభతరం
ఇంటర్పోపెరాబిలిటీని ఉపయోగిస్తుంది.
కాబట్టి,Dataను మార్పిడి చేయడం వంటి
EDI యొక్క సామర్ధ్యంను అందిస్తుంది, కానీ
ఇది సింపుల్ మరియు తక్కువ వ్యయంతో కూడుకుని
వుంటుంది.
data ఫార్మాట్ లో ముందే నిర్వచించబడిన
ఏ విధమైన ఒప్పందాన్ని కలిగి ఉండము.
అయితే విషయాలు ఎక్కడికి వెళ్తున్నాయో తెలుసుకుంటాను.
EDI వ్యవస్థలతో పనిచేయడానికి కాన్ఫిగర్ చేయబడిన
institutionలు Web సాంకేతిక serviceలను స్వీకరించినప్పుడు
రెండు సాంకేతిక పరిజ్ఞానాలను ఉపయోగించడం లేదా
EDI ను దశలవారీగా ఉపయోగించడానికి అనుమతిస్తుంది.
సో, www లేదా వరల్డ్ వైడ్ Web
విషువల్ కాంపొనెంట్ ను నోన్ విషువల్
కాంపొనెంట్  ని సెపrate
చేసేస్తుంది.
కాబట్టి, ముఖ్యమైనది ఏమిటంటే నేను దృశ్యమానంగా
మరొకదానిని చూడడం నేపథ్యంలో ఏమి జరుగుతుందో.
కాబట్టి, ఈ రెండు విషయాలు మీరు XML రకాన్ని
XML రూపంలో చూస్తే వంటివి వేరు చేయబడతాయి,
XML ఒకData ట్రాన్స్ఫర్మేషన్ లాంగ్వేజ్.
కాబట్టి, అది ఒకData విజువలైజేషన్ భాష కాదు; మనకు తెలిసిన html,Data విజువలైజేషన్
లాంగ్వేజ్  లేదా అది సరైనదిగా
ప్రదర్శిస్తుంది.
కాబట్టి, ఇంటరాపెరాబిలిటీ రకం problemలపై XML మరింత
పని చేస్తుంది మరియు ఎక్స్చేంజ్ ఎలా
చేయాలనెదని పై కూడా .Data యొక్క XML ప్లస్
స్టైలింగ్ యొక్క స్టైలింగ్
తో XML సమాచారాన్ని వీక్షించడానికి
లేదా ప్రదర్శించడానికి సహాయపడుతుంది.
కనుక, మా సాధారణ http ఆధారిత విషయాలు మాదిరి
కాకుండా అనగా ఇది data ను ప్రదర్శిచడం.
XML అనేది అంతకంటే ఎక్కువData రెప్రెసెంటేషన్
 లేదాData ట్రాన్స్ఫర్మేషన్ ఉంటుంది.
బ్రౌజర్ ద్వారా లేదా డెస్క్tap
client ద్వారా పరస్పర చర్య, జావా
స్వింగ్, పైథాన్, Windows వంటివి ఉండవచ్చు,
మేము డెస్క్tap clientుని
వేర్వేరు రకాలుగా వ్యవహరించవచ్చు
లేదా బ్రౌజర్తో అంతర్ముఖానికి సాధారణ interface
ఉంటుంది.
ఇప్పుడు, Web service ని చూస్తే, మూడు
ప్రధాన problemలను కలిగి ఉంటుంది.
అందులో మొదటిది ఇంటెరోpayరబిలిటీ , దిస్తృబుటెడ్
ఆబ్జెక్ట్ మెస్సేజింగ్ లో ఇంటెరోpayరబిలిటీ
 standard  లేకపోవడం, ఈ ఇంటర్పోపెరాబిలిటీ
అనేది రెండు party ల మధ్య లేదా రెండు
Software ల మధ్య ఉంటుంది.
రెండవది firewall ట్రావెర్సల్.
ఇప్పుడు, Web service వంటి వివిధ internet
లేదా TCP / IP ఆధారిత ప్రోటోcall, ప్రధానంగా http ప్రోటోcall
లో piggyback అవుతుంది.
సో, ఇది ప్రధానంగా firewall మీద
వెల్లుతు ఉండాలి , http పోర్ట్ నెంబర్
80 అనుమతితో.
సో, Web service  ఇప్పటికీ పని
చేయవచ్చు.
అందువల్ల, CORBA మరియు DCOM appరమాణిక పోర్ట్సు
Web serviceలను ఎక్కువగా http ను ఉపయోగిస్తుంది.
కాబట్టి, http మాత్రమే కాకుండా ఇతర ప్రోటోకోల్స్
ని కూడా ఉపయోగించుకోవచ్చు, కానీ ప్రధానంగా http
యొక్క చాలా firewallస్ పోర్ట్  80 ను అనుమతిస్థాయి,
ఇది కొన్ని ముఖ్యమైన కోణాలకి దారి తీస్తుంది
Web service లో సులభంగా డైనమిక్
సహకారానికి దారితీస్తుంది, చివరిది కాంప్లెక్సిటీ,
ఇది డెవలపర్ స్నేహపూర్వక serviceా
వ్యవస్థ.
కాబట్టి, development చాలా సులభం.
open టెక్స్ట్ ఆధారిత standardని
ఉపయోగిస్తుంది.
ఇందులో ఒకటి XML. వివిధ లాంగ్వేజ్ లలో
కొంపోనెంట్స్ ని వ్రాయడానికి మరియు
ప్లాట్ఫారమ్లో వాటిని కమ్యూనికేట్
చేయడానికి అనుమతిస్తుంది.
కాబట్టి, ఇది ముఖ్యం.
ఇది ఇంక్రీమెంటల్  గా అమలు చేయబడుతుంది
మరియు deployమెంట్ చేయబడుతుంది, ఇతర
ఖర్చులను కూడా పెంచుకోవడమే కాక, ఖర్చులను తక్కువగా
చేస్తుంది మరియు సాంకేతికతలకు ఆకస్మిక
స్విచ్ నుండి institutionాగత అంతరాయంను
తగ్గిస్తుంది.
కాబట్టి, ఈ external ప్రపంచానికి సరైన
Web service interface ఉంటే
ఇప్పటికీ లేగసి Software  అండ్ టూల్స్
ని అమలు చేస్తుంది.
ఇది మరో ప్రధాన అంశం ఇప్పటికీ విభిన్న
అంశాలను కలిగి ఉంది.
కాబట్టి, మనము మళ్ళీ open standard
ద్వారా ఈ సంభాషణ మొత్తాన్ని చూసినట్లైతే
, అది HTTP కావచ్చు, SMTP కావచ్చు లేదా ఏదైనా
ఇతర TCP / IP application లేయర్ ప్రోటోcall యొక్క ఏ రకం అయిన కావచ్చు.
రూపొందించిన XML సందేశాలను SOAP ఉపయోగించి ప్రాసెస్
చెయ్యడం, SOAP అంటే ఏమిటో చూద్దాం.
ఇది ప్రాథమికంగా XML ఆధారిత సందేశ వ్యవస్థ
మరియు ప్రజాదరణ పొందిన వాటిలో ఒకటి.
XML వ్యూహాన్ని ఉపయోగించి దాని సందేశాలను వివరిస్తుంది,
ఎలా నాData నిర్వహించబడుతోంది; నేను ప్రాథమికంగా
XML స్కీమ ను ఎలా ఉపయోగిస్తాను అనేది
వివరిస్తుంది.
WSDL ని ఉపయోగించి తుది వివరణను అందిస్తుంది.
Web service డిస్క్రిప్సన్ లాంగ్వేజ్  గురించి తర్వాత తెలుసుకుందాం.
మన serviceని ఎక్కడ లాంచ్  చేశారు
మరియు కాన్ఫిగర్ ఎలా ప్రారంభించాలో,
నేను ఒక WSDL వద్ద చేయగలను.
UDDI ను ఉపయోగించి ప్రాథమికంగా పబ్లిష్  మరియు
డిస్కోవర్  చెయ్యొచ్చు.
కాబట్టి, నా Web Service డిస్క్రిప్సన్
 డిస్కవరీ  మరియు ఇంటెగ్రేషన్
 UDDI ద్వారా సులభతరం.
దీనిని అమలు చేయడానికి ఒక మార్గం, మనము బేస్
గా XML ను కలిగి ఉన్నాము.
మనము మూడు ప్రధాన భాగాలు SOAP, WSDL, UDDI కలిగి
ఉన్నాము.
కాబట్టి, ఇవన్నీ అన్ని W3C కొంపోనెంట్స్
 మరియు de facto XML ఆధారిత విషయాలు ఉపయోగిస్తాము,
ఇవన్నీ ఎలా work  అవుతాయో పరిశీలిస్తాము.
ఒక ఉదాహరణ purchase చేయడం.
పర్చేస్ ఆర్డర్  appపుడు క్రెడిట్
చెక్, రిజర్వ్ జాబితా, క్రెడిట్
ప్రతిస్పందన, జాబితా ప్రతిస్పందన,
సంఘటిత ఫలితం మరియు inవాయిస్ ఉంటాయి.
కాబట్టి క్రెడిట్ service , inవెంటరీ
service, పి.ఒ. serviceలు మొదలైనటువంటి
విభిన్న partyలు ఉన్నాయి మరియు వాటికి
serviceలను అందించటానికి రూపకల్పన చేయబడతాయి.
ఇది ఒక resources  నుండి తీసుకోబడింది,
కానీ అది ఏ విధంగా ప్రయత్నిస్తుంది,వివిధ
రకాలైన services ను అందించగలదు, కంపోజ్
చేసి మరియు విభిన్న రకాల application
లను కలిపి ఒక పెద్ద application
ని సృష్టించగలము.
ఈ application ని ఇతర రకాల తో choreograph
లేదా విలీనం చేసినప్పుడు; కొన్ని ఇతర రకాల
services ను అందిస్తుంది.
ఇప్పుడు ఈ మొత్తం విషయం చూస్తూ ఉంటే,
మనకు అర్థం అయ్యేది ఏమిటి అంటే ఇది అంతా
కూడా మరొక architecture  కు దారి తీసింది.
అదే Web service ఓరియెంటెడ్ architecture
 SOA. అందువల్ల, IBM లు Web service
 ఇంటెరాక్సన్ ను చూపించడానికి
ఒక modelను రూపొందించాయి, ఇది మూడు institutionల
మధ్య సంబంధాన్ని కలిగి ఉన్న service
ఓరియెంటెడ్ architecture గా సూచిస్తారు.
కాబట్టి, ప్రాథమికంగా మనకు మూడు భాగాలున్నాయి;
ఒక Service provider, ఒక service రెక్వెస్టర్ లేదా service కన్స్యూమర్ మరియు
Service బ్రోకర్.
here కన్స్యూమర్ మరియు provider,
రెక్వెస్టర్ లేదా కన్స్యూమర్
మరియు బ్రోకర్ కి మధ్య ఇంటెరాక్సన్,అనగా
serviceలు ఎక్కడ లభిస్తాయో తెలుసుకోవడానికి
అనుమతించే ఒక విషయం ఉంది.
here మనం చూస్తున్న చిత్రం చాలా ప్రజాదరణ
పొందింది, చాలా లిటరేచర్ లలో మనం చూడవచ్చు.
అందువల్ల, Service provider
నుండి service లను పొందాలనుకుంటున్న
service రెక్వెస్టర్  లేదా కన్స్యూమర్
 ని కలిగి ఉన్నాము; కానీ here service
లు ఎక్కడ ఉంటాయో service రెక్వెస్టర్
 ఎలా కనుగొంటాడు?
దీని కొరకు here ఏ రకమైన serviceలు ఉన్నాయో
తెలుసుకోవడానికి రిజిస్ట్రీ ఉంది.here
మనం ఏ రకమైన serviceలు ఉన్నాయి అనేది తెలుసుకోవచ్చు.
దీనికి సంభంధించిన ఒక అనాలోజీ  చూద్దాం,telephone
ఎక్స్ఛేంజి నుంచి వచ్చే telephone
డైరెక్టరీ తీసుకుంటే.
యెల్లో payజీలు, వైట్ payజీలు
మొదైలనవి మొదట్లో ఉండేవి.
కాబట్టి, ఎక్కడ ఏది కనుగొంటారు?
కాకుండా డైరెక్టరీ కూడా ఒక నిర్దిష్ట
విషయం కోసం శోధించడం ఎలా అనేది చెప్పదు;
మీరు plumbing లేదా బేస్ లేదా
ఏదో కోసం చూస్తున్నారు అనుకుందాం.
డైరెక్టరీ service  లేదా రిజిస్ట్రీ
service గా పనిచేస్తుంది.
కాబట్టి, ఆ రకమైన విషయాలు కూడా hereే
రిజిస్ట్రీ service ను కలిగి ఉంటాయి.
here service డిస్క్రిప్సన్  ఉటుంది,
service రెక్వెస్ట్  లు QSDL మరియు
UDDI ఉపయోగించి రిజిస్ట్రీ service  నుండి
అవసరమైన service ను కనుగొంటాయి
మరియు అది ప్రధానంగా ఒక service provider తో అనుసందనించబడి ఉంటుంది.
ఎక్కువ service provider లను మనం గుర్తించవచ్చు.
service ను నవీకరించినప్పుడు కొత్త service 
ప్రారంభించిన తర్వాత ఒక service provider ఆ service  ని రిజిస్ట్రీలో
ప్రాథమికంగా పబ్లిష్  చేస్తారు, తద్వారా
కాబోయే purchaseదారు లేదా కాబోయే consumer.
customer అభ్యర్థి ఈ service ల రకాలు
ఎక్కడ ఉన్నాయో తెలుసుకోవచ్చు.
ఇది వివిధ కాంపొనెంట్ లు పనిచేసే ఒక
త్రిభుజం అని మీరు కనుగొనవచ్చు మరియు
ఈ రకమైన అంశాల ఆధారంగా ఏదైనా ఉంటే అది ఒక
service  నడిpay లేదా service ఓరియెంటెడ్
architecture అని అంటాము.
ఈ Web service modelస్ లో Web service
architecture  roleస్ 
ని మనం చూసినట్లైతే, మొదటగా service provider
: వీరు service  యొక్క యజమాని
గా ఉంటారు, ఇది services  ను అందించే ఒక
ప్లాట్ఫారమ్.
రెండవది service రెక్వెస్టర్  లేదా కొంసుమర్ : ఎవరైతే services
ని వినియోగించుకుంటారో వాళ్ళు.
మరియు చివరిది service రిజిస్ట్రీ :
service డిస్క్రిప్సన్  వెతకడం కోసం
ఉపయోగించే రిజిస్ట్రీ , ఇందులో service
provider  వారి service 
వివరణను పబ్లిష్  చేస్తాడు.
ఈ Web service architecture లో మూడు
ప్రధాన కార్యకలాపాలు ఉంటాయి, అందులో మొదటిది
పబ్లిష్ : ఇది Service provider
service లను ప్రచురిస్తుంది.
రెండవది, ఫైండ్ : customerకు అవసరమయ్యే
serviceలను కనుగొంటుంది.
చివరిది,Byండ్ : ఇది provider
తో Service కన్స్యూమర్ని కలుపుతుంది.
Web service యొక్క కొంపోనెంట్స్
లో ఒక ప్రముఖ కాంపొనెంట్  XML, ఎక్స్టెంసిబుల్
మార్క్app లాంగ్వేజ్ .
నేను మీకు దీని గురించి తెలిసే ఉంటుంది అనుకుంటున్నాను,
ఒకవేళ తెలియకపోతే, ఒక ప్రామాణిక పుస్తకం
ద్వారా లేదా W3C ట్యుటోreal ద్వారా తెలుసుకోవచ్చు.
ఇది XML కి సంబంధించి ఒక మంచి ట్యుటోreal.
రెండవ కాంపొనెంట్  SOAP సింపుల్ ఆబ్జెక్ట్
ఓరియెంటెడ్ ప్రోటోcall, ఇది ఒకే
రకమైన data రెప్రెసెంటేషన్  ను మరియు
మార్పిడి విధానాలను అందిస్తుంది.
ఇది XML ను ఉపయోగించటానికి సమాచార మార్పిడికి
సరైన మార్గం.
మూడవది,WSDL Web services డిస్క్రిప్షన్ లాంగ్వేజ్, ఇది XML ను ఉపయోగిస్తుంది
మరియు అందించబడిన service ల గురించి
వివరించడానికి ఒక ప్రామాణిక మెటా లాంగ్వేజ్
.
చివరిది UDDI, యునివర్సల్ డిస్క్రిప్షన్ డిస్కవరీ
మరియు ఇంటిగ్రేషన్ స్పెసిఫికేషన్,
ఇది రిజిస్ట్రీ service ను నిర్మించడానికి
సహాయపడుతుంది, మరియు Web service applicationలను
రిజిస్టర్  చేయడానికి మరియు గుర్తించడం
కోసం ఒక పద్దతిని అందిస్తుంది.
client, service లను గుర్తించడానికి
రిజిస్ట్రీకి క్వెరీ పంపుతారు,
రిజిస్ట్రీ వివరణ ఉన్న WSDL డాక్యుమెంట్
న్ని సూచిస్తుంది, client ఈ WSDL డాక్యుమెంట్
ని access చేస్తాడు.
ఇది Web service లతో ఇంటెరాక్ట్
అవ్వడానికి కావలసిన dataను అందిస్తుంది.
clientను SOAP మెసేజ్  రెక్వెస్ట్ని
provider కి పంపుతారు.
మరియు Web service  SOAP మెసేజ్ రెస్పోంస్
ను తిరిగి పంపుతుంది.
ఇది ఒక కాంపొనెంట్ల సమూహం మరియు ఇవ్వన్ని
కూడా అండర్లయింగ్ ఇంటర్ networking
లేదా ప్రామాణిక network ప్రోటోcall
TCP/IP లేదా OSI పై పని చేస్తాయి.
కాబట్టి, UDDI వివరణను SOAP messaging లో
ఒక వెన్నెముకగా చెప్పవచ్చు; UDDI అనేది ఒక స్టాటిక్
పబ్లికేషన్ గా ఉండవచ్చు లేదా అది
ఒక డైనమిక్ పబ్లికేషన్ గా అయినా ఉంటుంది
మరియు తరువాత WSFL అనగా flow నిర్వహణ.
కాబట్టి, ఇతర రకాలైన అంశాలలో మరియు మూడు
ఇతర కాంపొనెంట్లు ఉన్నాయి, ఇందులో
ఒకటి క్వాలిటి ఆఫ్ service:
ఏ విధమైన service లు అందిస్తారు,
వారు QS management problemలు అనగా మొత్తం
ఎలా నిర్వహించాలీ, ఆపై security 
అంశాలు ఉంటాయి, security ఉల్లంఘన ఎలా ఉందో
లేదో, security విధానాలు ఏవి, ఎవరిని నమ్మాలి
మొదలైనవన్నీ ఉంటాయి.
XML, here ఎక్కువగా చర్చించడం లేదు;
ఇది ఒక జెనరలైజేడ్ మార్కప్ లాంగ్వేజ్
 యొక్క ప్రామాణిక సాధారణ
పద్ధతి నుండి ఉద్భవించింది.
ఇది ఎక్స్టెంశీబుల్ మార్కప్ లాంగ్వేజ్, ఇది ప్రాథమికంగాDataను వివరించడానికి
ఉపయోగించబడుతుంది మరియు ప్రెజెంటేషన్
నుండి కంటెంట్ను వేరుచేయడంలో ఇది
సహాయపడుతుంది.
XML డాక్యుమెంట్ DTD ద్వారా సూచించబడుతుంది,
DTD ద్వారా మరింత జనాదరణ పొందినది XSD, అనగా
XML స్కీమా డెఫినిషన్ లాంగ్వేజ్ , here మనము స్కీమను నిర్వచిస్తాము.
XML లో టాగ్లు ముందే నిర్వచించబడలేదు.
కాబట్టి, మీ స్వంత ట్యాగ్లను మీరు నిర్వచించవచ్చు.
అదే html లో అయితే నిర్వచించలేము అవి ప్రీ డెఫిన్ద్.
ఇది Web service ల్లో క్రాస్ ప్లాట్ఫామ్
Communicationను ని అందిస్తుంది.
కాబట్టి, ఇది సాధారణంగా ఒక XML విషయం వివరిస్తుంది.
క్షమించాలి, ఇది ఒక html విషయం, ఇది ప్రాథమికంగా
ఒక వ్యక్తి అడ్రెస్ని లేదా వ్యక్తిగత ఇమెయిల్
అడ్రెస్  ని నిర్వచిస్తుంది.
ఇందులో జాన్ అనే వ్యక్తి యొక్క పరిచయం
నిర్వచించబడిందని తెలుపుతుంది.
ఈ html ను ఏ బ్రౌజరులో అయినా మేము ఉపయోగిస్తే
పై విధంగా ఉంటుంది, దీనినే XML లో చూడాలనుకుంటే,
ఇది ఇలా కనిపిస్తుంది.
కాబట్టి, ఇదిData దేస్క్రిప్షన్ కంటే ఎక్కువ.
కాబట్టి, ఇది ఒక payరు, ఇది అడ్రెస్ ,
ఇది కంట్రి ఫోన్, ఇ-మెయిల్ మరియు
ఇంకేదైనా కావచ్చు.
కాబట్టి, ఇది ఒక XML రకానికి చెందినది.
ప్రెసెంటేషన్ కాదు. కాబట్టి, రెప్రసెంట్
 చెయ్యడం కోసం ఏదో ఒకటి అవసరం.
మూడు ప్రధాన అంశముల గురించి చర్చిస్తున్నాము,
అందులో ఒకటి SOAP, ఇది మెసేజ్ ప్రోటోcall కంటే ఎక్కువ.
సింపుల్ ఆబ్జెక్ట్ access ప్రోటోcall ఫార్మాట్ వంటిది.
దీనిని internetలో మెసేజ్లను పంపడానికి
ఉపయోగిస్తారు.
ఇది XML పై ఆధారపడి ఉంటుంది, W3C లో ఉంటుంది.
దీనికి స్టేట్  ఉండదు మరియు ఇది
ఒన్ వే  ప్రోటోcall.
ఇది ప్రధానంగా http ని ట్రాన్స్పోర్ట్
ప్రోటోcall గా ఉపయోగిస్తుంది.
ఈ ట్రాన్స్పోర్ట్ ప్రోటోcall
ని TCP / IP ట్రాన్స్పోర్ట్ ప్రోటోcall
తో కలపకూడదు, ఇది ఈ Web serviceలను
ట్రాన్స్పోర్ట్  చేస్తుంది.
here HTTP క్యారియర్ ప్రోటోcall
ని access చేస్తుంది.
కనుక, వివిధ బిల్డింగ్ బ్లాక్లు
ఉన్నాయి.
SOAP బిల్డింగ్ బ్లాక్స్ గురించి తెలుసుకుందాం.
ట్రాన్స్పోర్ట్ ప్రోటోcall
ఒక ఎన్వలప్గా ఉంటుంది, దీనిలో
MIME హెడర్  ఉంటుంది.
తర్వాత SOAP ఎన్వలప్, SOAP హెడర్ , SOAP బాడీ
మరియు fault  మరియు డెయిఫికేషన్
 సందర్భాలు ఉన్నాయి, కానీ అన్ని
XML పై ఆధారపడి ఉంటాయి.
మెసేజ్ స్ట్రక్చర్ , ఇది ఒక SOAP
స్పెసిఫికేషన్ ఎన్వలప్ ని డెఫినే
చేస్తుంది.
ట్రాన్స్పోర్ట్ మీద పిగ్గీబ్యాక్
చేయబడుతుంది, ప్రధానంగా ఒక ఎన్వలప్ అవుతుంది
మరియు ఈ http లో ఈ ట్రాన్స్పోర్ట్ ప్రోటోcall
కోసం pay load అవుతుంది, here
పునరావృతం చేసీన ట్రాన్స్పోర్ట్
ప్రోటోcallలను TCP / IP లేదా OSI ప్రోటోcallస్
తో కలపబడదు.
SOAP రెక్వెస్ట్ , ఇది http లో post మెసేజ్
 గా ఉంటుంది.
ఈ విషయంలో SOAP మెసేజ్ కి ఒక post
మెసేజ్ ని మీరు చూస్తే అది ఒక నిర్దిష్ట
stack Tier ను మరియు stack నేమ్ 
కోసం ప్రత్యేకించి IBM మొదలైనవాటి కొరకు
ఉపయోగపడుతుంది.
మరియు తిరిగి రెస్పోంస్  ఇస్తుంది.
మళ్ళీ మీరు ఆ http రెస్పోంస్  చూసినట్లయితే,
దాని రెస్పోంస్  ఒక వాల్యూ  గా ఉంటుంది.
dataను మార్పిడి చేసే స్ట్రక్చర్
వే కంటే ఎక్కువగా ఉంటుంది, ఇది Performance
unit కోసం ఒక విషయం యొక్క ఒక HTML రకాన్ని
కలిగి ఉండవచ్చని చెప్పడం లేదు.
ఎందుకు SOAP?
ఈ రకం application చేయలేని ఇతర టెక్నాలజీస్
ఉన్నాయి, SOAP ఒక platform , తటస్థ ఎంపిక,
సాధారణ XML వైర్ ఫార్మాట్, మీరు మీ లెగసీ
విషయాలను అమలు చేసే టెక్నాలజీ కి limitedులు
లేవు.
మూడు ప్రధాన లక్షణాలు ఉన్నాయి.
అవి ఎక్స్టెంశీబుల్ ,న్యూట్రల్ 
మరియు inడిపెన్డంట్.
కాబట్టి, ఇది distributed application లకు ప్రతి ఇతర మరియు రకం విషయాల
కోసం సరిగ్గా సరిపోతుంది.
మరియు వేర్వేరు వాడుక modelలు ఉన్నాయి,
ఒక మెసేజ్ మార్పిడి లేదా SOAP స్పెసిఫికేషన్
వంటివి RPC గా ఉండవచ్చు.
ఇతర security అంశాలు, వీటి గురించి
మనము తర్వాత తెలుసుకుంటాము.
మరొకటి WSDL, Web service డిస్క్రిప్షన్ లాంగ్వేజ్.
కాబట్టి, ఇది XML బేస్ W3C కంటెంట్, దీనిని
వివరించడానికి మళ్ళీ అనుమతిస్తుంది.
ఇది విభిన్న స్ట్రక్చర్ని కలిగి ఉంటుంది, వాటిలో
పోర్ట్ టైప్ ఒకటి, ఎక్కడ ప్రత్యేకమైన
service లు ఎనేబుల్ చేయబడతాయో మరియు
ఒక Web విషయాలు ఎక్కడ ఉంటాయో తెలుస్తుంది;
మెసేజ్ మరియు టైప్స్  మొదలగునవి
ఉంటాయి.
provider  కి మరియు కొంసుమర్ 
ల మధ్యByండింగ్ ప్రాసెస్  జరుగుతుంది.
ఇది సాంపుల్ WSDL మెసేజ్, here
SOAP మెసేజ్ మరియు WSDLల మధ్యByండింగ్
ఉంటుంది.
దీని అర్ధం, SOAP మెసేజ్ యొక్క డెస్క్రిప్షన్
data ఎలా ట్రాన్సఫర్ చేయబడుతుందో, source
 మరియు దేస్టీనేషన్ కి మధ్య లేదా రెక్వెస్టర్
, రిజిస్ట్రీకి మరియు కోన్స్యూమర్
 మధ్యByండింగ్ ఎలా ఉంటుంది.
చివరగా UDDI, యునివర్సల్ డిస్క్రిప్షన్ డిస్కవరీ
అండ్ ఇంటెగ్రేషన్ .
ఇది ఒక రిజిస్ట్రీ service.
XML ఆధారిత రిజిస్ట్రీ)లను నిర్వచించడానికి
ఇది ఒక ఫ్రేమ్ work.
కాబట్టి, అన్నీ మెటాdata సమాచారాలు here
ఉంటాయి.
కోన్స్యూమర్  లేదా రెక్వెస్టర్
 లు నిర్దిష్ట స్థావరాలకు మరియు
ఎలా ప్రత్యేక provider తో ముడిపడి ఉంటుంది.
మునుపటి స్లైడ్స్ను గుర్తుంచుకున్నట్లయితే
ఇది ఒక Service provider రిజిస్ట్రీ మరియు రెక్వెస్టర్ .
కాబట్టి, ఒరిఎన్టేషన్ భిన్నంగా ఉంటుంది.
రిజిస్ట్రీ లో Service provider దానిని పబ్లిష్ చేస్తారు, రెక్వెస్టర్
 దాన్ని కనుగొని,Byండ్  చేస్తారు.
కాబట్టి, మొత్తం workని కలిసి
పనిచేయడం కోసం అది చాలా ముఖ్యమైన పాత్ర
పోషిస్తుంది.
మీరు అదే విషయం అయితే, ఇది ప్రధానంగా కోన్స్యూమర్
 సర్చ్  చేసే మరో విషయాన్ని పబ్లిష్
చేస్తుంది మరియు provider తో
బైండింగ్ చేయాలి.
రిజిస్ట్రీ serviceDataను ప్రత్యేకమైన
ఫార్మాట్లో ఉంచితే చాలా ప్రయోజనాలు
ఉన్నాయి.
సో, అక్కడ శోధన ఉంటుంది, ఇది సాధ్యం వ్యాపార
onలైన్ ప్రస్తుతం లక్షలాది నుండి కనుగొనడంలో
సాధ్యం.
సో, మీరు ఇష్టపడే వ్యాపార తో connectivityని
ఎనేబుల్ ఎలా చేయవచ్చు మొదలగునవి ఉంటాయి.
ఈ security  ఎలా పని చేస్తుంది
అనే వివరాల్లోకి ఇప్పుడు వెళ్ళడం
లేదు. security  అనేది SOAP యొక్క
మరో ముఖ్యమైన అంశం, Web serviceల
యొక్క అంశం, మనము మునుపటి ఫిగర్ 
లో చూసినట్లుగా ఇది వర్టికల్ లైన్ లో పని చేస్తోంది, ఇది Web service
పాలసీ , ట్రస్ట్, ప్రైవసీ , సెక్యూర్
కాన్వర్సేషన్, ఫెడరేషన్ 
మరియు ఆథరైజేషన్ వంటి విభిన్న భాగాలను
కలిగి ఉంది. కాబట్టి, నిర్వహణ మరియు QoS
లాంటి ఇతర విషయాలు కూడా ఉంటాయి.
కాబట్టి, ఈ ప్రత్యేక lectureలో మనము
చూడాలనుకుంటున్నది ఏమిటంటే, ఈ Web serviceలు మరియు service ఓరియెంటెడ్ architecture
, ఇది cloud ని ఏర్పాటు
చేయడానికి ముఖ్యమైన పాత్ర పోషిస్తుంది.
మొత్తం cloud ప్రాసెస్ ని IaaS, PaaS లేదా SaaS
లేదా XaaS , ఎనీథింగ్ as ఆ service  అని చెప్పవచ్చు.
దీని ప్రాథమిక బిల్డింగ్ బ్లాక్ అనేది
Web service లను పబ్లిష్, ఫైండ్
 మరియుByండ్  చేయడం వంటి అన్ని
విషయాలను సూచిస్తుంది, cloud service లకు కూడా ఇదే వర్తిస్తుంది.
here మనం ప్రాథమికంగా ఎవరు Service provider మరియు కోన్స్యూమర్  , service 
ఏ రకానికి చెందింది,ఎక్కడ లాంచ్ అయ్యింది
అనేది తెలుసుకోవలసిన అవసరం ఉంది. కాబట్టి,ఇది
cloud service లను నిర్వహించడానికి
సరైన మార్గంగా విస్తరించింది.
కనుక, ఈ Web serviceలు మరియు service
ఓరియెంటెడ్ architecture  development,
ఈ cloud computing ని ఆచరనాత్మకంగా
చేయడం లో ముఖ్యమైన పాత్ర పోషించాయి.
ఈ రోజు hereితో మన చర్చను ముగిస్తాము.
cloud computing యొక్క ఇతర అంశాలతో
మన భవిష్య lectureలో కొనసాగుతాము.
ధన్యవాదాలు.
 ఇంతకు ముందుగా స్కీమాలను
payర్కొనడానికి అనుమతిస్తుంది.
దీనిని soap సందేశం ఫార్మాట్ ద్వారా
చేయవచ్చు.
మీరు మరలా చూస్తే XML సందేశము ప్లస్
processing, XML అనేదిData ఎక్స్ఛేంజ్ కోసం యునివర్సల్ ఫార్మాట్.
నేను soap API తో ఈ application ను కలిగి ఉంటాను,
మరియు here ప్రధానంగా రెండు వేర్వేరు రకాల
సరఫరాదారులు ఉంటారు.
అందువల్ల, వివిధ రకాల సరఫరాదారులతో
ఇంటెరక్ట్  అవుతుంది, ఇది మొత్తంగా ఒకే
application, హెచ్‌టి‌టి‌పి  ద్వారా ఇతర application
లతో ఇంటెరక్ట్  అవుతుంది.
కాబట్టి, ఇది soap సందేశం, http లో పిగ్గీబ్యాక్
అవుతుంది.
మరియు ఈ http యొక్క payload లాగా తీసుకెళ్ళి,
విషయాలను పంపిణీ చేస్తుంది, ఇతర ఏంటీటీఎస్
, data  రన్ అవుతున్న ఈ ప్రత్యేక
application  కు ఎక్స్ట్రాక్ట్
చేసి డెలివేరి  చేస్తాయి.
కాబట్టి, మేము XML యొక్క ఈ కుటుంబం చూస్తే.
మధ్య భాగంలో మనకు XML, XSLT, XSL, X పాత్, X పాయింటర్
మరియు ఇతర అంశాలు ఉన్నాయి.
ఇవ్వన్ని చర్చించడానికి మొదటగా మనకు అంత
సమయం లేదు. మరియు రెండోది, మనము ఈ లక్షణం
ఎలా లేదా XML యొక్క విలక్షణమైన లక్షణాలు
ఏవి.
XML నేర్చుకోవాలని ఆసక్తి ఉన్నవారు
W3C స్కూల్  లేదా ఏదైనా ప్రామాణిక
పుస్తకంను అనుసరించవచ్చు, మరియు కొన్ని చిన్న
ప్రాజెక్టులను చేయదానికి ప్రయత్నించండి.
అయితే; ఈ విధమైన API లు విభిన్న స్టైలింగ్
లో ఉన్నాయి, వీటిలో వేర్వేరు ప్రోటోcall,
XML ఉన్న Web services  లు ఉన్నాయి.
here వేరే ఇతర రకాలు ఉండవచ్చు.
ఈ XML యొక్క వర్సటైల్  స్వభావం చూపించడానికి
ప్రయత్నిస్తుంది మరియు ఇది ఒక కొంపనీయన్
 టెక్నాలజి .
ఈ XML మరియు దాని community దిస్తృబుటెడ్ System లో దాని నిర్మాణాన్ని గుర్తించడంలో కీలక
పాత్ర పోషిస్తుంది.
సో, నేను దిస్తృబుటెడ్ System
ను ఇంటెరక్ట్  అవ్వడానికి కలిగి
ఉన్నాను మరియు soap మెసేజ్  ని ఉపయోగించి
కొమ్మునికేట్  అవుతాను, దీనితో
పాటుగా WSDL మెసేజింగ్, WSDL UDTI మొదలైనవన్నీ
ప్రధానంగా XML పై ఆధారపడి ఉంటాయి.
మనము mathml వంటి ఇతర నేమ్ స్payస్
లు కూడా ఉన్నాయి మరియు గ్రాఫిక్స్
సంభందిత విషయాలను ఉత్పత్తి చేయడానికి
SVG ఉంది. కాబట్టి, ఈ XMLData ట్రాన్స్ఫోర్మేషన్
 అనుమతించడంలో సహజంగానే వర్సటైల్
గా ఉంటుంది.
మరియు నేను ఈData ను రెప్రెసెంట్ 
చెయ్యాలి అనుకుంటే appపుడు నేను XSLT లేదా
కొన్ని XLD ద్వారా కొన్ని స్టైలింగ్
లు అవసరం అవుతాయి.
కొన్ని స్టయిల్ షీట్లు కూడాData ను రెప్రెసెంట్
 చెయ్యడానికి ఉపయోగపడతాయి; నేను
ఒక HTML ఫైల్, మరొక వైపు data ను చూడడానికి
రూపొందించవచ్చు.
మనం ప్రాథమికంగా చాలా ప్రాథమిక పరిచయ
విషయాలు లేదా XML యొక్క ప్రధాన భాగాల గురించి,
మరియు ఇంటెరోpayరబిలిటీ  ని రూపొందిచడంలో
ఈ కొంపోనెంట్స్ ఎలా తోడ్పడతాయి అనేవి
తెలుసుకున్నాం.
మీరు కొన్ని రకాల interfaceలు
ఇంటరాక్ట్ అవ్వడం లేదా ఇంటర్పోపెరాబిలిటీ
అవసరము ఉన్న cloud లేదా దిస్తృబుటెడ్
Systemను చూస్తే అక్కడ XML గుర్తించదగ్గ
de facto లాంగ్వేజ్ .
కాబట్టి, మనమిప్పుడు XML యొక్క ఈ బేసిక్స్గురించిన
చర్చను ఈరోజుతో ముగిస్తున్నామ్.
ధన్యవాదాలు.




